This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/models/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitattributes
.gitignore
.local/state/replit/agent/.agent_state_2aaccbf454ef8ba8d7af7ef6397b6000a0d98caa.bin
.local/state/replit/agent/.agent_state_5581256f3cf0e308f17fb5ba57197517680cb01f.bin
.local/state/replit/agent/.agent_state_752d25e162125b826bdc69d5a1874610791b1842.bin
.local/state/replit/agent/.agent_state_880a083bfc02fa8946bac6502a1c8b0c5eeeb85f.bin
.local/state/replit/agent/.agent_state_94cebf307ad14581daf83df3165441feaf12ab2f.bin
.local/state/replit/agent/.agent_state_9dc2e84ec51342c71210888bb4e02a7a03a318cd.bin
.local/state/replit/agent/.agent_state_b551a4248d318febbd5e716a8712ed89527aea0e.bin
.local/state/replit/agent/.agent_state_e1171a93ccd10d311fe78468007bef52f2eb32fc.bin
.local/state/replit/agent/.agent_state_ebad4c06243d1942d8cfd570ebcb173bde601cec.bin
.local/state/replit/agent/.agent_state_ed663523234c030f9a1bfc1e5bd800d0daaae2f6.bin
.local/state/replit/agent/.agent_state_fc924d861991ab75e6fa9c3f05ecb2e3928d14df.bin
.local/state/replit/agent/.agent_state_main.bin
.local/state/replit/agent/.latest.json
.local/state/replit/agent/filesystem/filesystem_state.json
.local/state/replit/agent/repl_state.bin
.replit
attached_assets/Pasted--Iris-PC-Goal-Iris-AI--1766234366083_1766234366083.txt
attached_assets/Pasted--Iris-PC-Goal-Iris-AI--1766234427002_1766234427002.txt
attached_assets/Pasted--venv-PS-C-Users-Ghost-Desktop-hfdhf-python-main-py-C-U_1766235872465.txt
attached_assets/Pasted--wake-word-detection--1765952507227_1765952507228.txt
attached_assets/streamelements_client_1765902075685.py
Chernovik.py
find_female_voice.py
fix_iris_brain.py
gamestate_integration_iris.cfg
iris_config.json
main_clean.py
main.py
pyproject.toml
README.md
replit.md
requirements.txt
setup.py
src/__init__.py
src/achievements.py
src/context_builder.py
src/cs2_gsi.py
src/iris_brain.py
src/iris_core/__init__.py
src/iris_core/brain.py
src/iris_core/modules/__init__.py
src/iris_core/modules/learning.py
src/iris_core/modules/memory.py
src/iris_core/modules/qwen_ai.py
src/iris_core/modules/stream_ai.py
src/iris_core/modules/voice_ai.py
src/iris_smart_engine.py
src/iris_visual.py
src/prompt_builder.py
src/queue_manager.py
src/session_memory.py
src/statistics_tracker.py
src/streamelements_client.py
src/tts_engine.py
src/utils/__init__.py
src/utils/tts_utils.py
src/voice_input.py
src/voice_recognition.py
src/windows_audio.py
stream_stats.json
temp_repo/.local/state/replit/agent/.agent_state_9dc2e84ec51342c71210888bb4e02a7a03a318cd.bin
temp_repo/.local/state/replit/agent/.agent_state_ebad4c06243d1942d8cfd570ebcb173bde601cec.bin
temp_repo/.local/state/replit/agent/.agent_state_main.bin
temp_repo/.local/state/replit/agent/.latest.json
temp_repo/.local/state/replit/agent/repl_state.bin
temp_repo/.replit
temp_repo/attached_assets/streamelements_client_1765902075685.py
test_tts_sound.py
test_tts.py
test_vosk.py
voice_stats.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
models/vosk-model-ru-0.22/** filter=lfs diff=lfs merge=lfs -text
</file>

<file path=".local/state/replit/agent/.latest.json">
{"latest": "main"}
</file>

<file path=".local/state/replit/agent/filesystem/filesystem_state.json">
{"file_contents":{"src/windows_audio.py":{"content":"import os\nimport sys\nimport subprocess\nfrom typing import Optional, List, Dict\n\nclass WindowsAudioController:\n    def __init__(self):\n        self.is_windows = sys.platform == 'win32'\n        self.pycaw_available = False\n        \n        if self.is_windows:\n            try:\n                from pycaw.pycaw import AudioUtilities, ISimpleAudioVolume\n                from comtypes import CLSCTX_ALL\n                from pycaw.pycaw import IAudioEndpointVolume\n                self.pycaw_available = True\n            except ImportError:\n                print(\"[AUDIO] pycaw –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ Windows\")\n                print(\"[AUDIO] –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install pycaw\")\n                \n    def get_running_apps(self) -> List[Dict]:\n        if not self.is_windows or not self.pycaw_available:\n            return self._get_mock_apps()\n            \n        try:\n            from pycaw.pycaw import AudioUtilities\n            \n            sessions = AudioUtilities.GetAllSessions()\n            apps = []\n            \n            for session in sessions:\n                if session.Process:\n                    apps.append({\n                        'name': session.Process.name(),\n                        'pid': session.Process.pid,\n                        'session': session\n                    })\n                    \n            return apps\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π: {e}\")\n            return []\n            \n    def _get_mock_apps(self) -> List[Dict]:\n        return [\n            {'name': 'Yandex Music (mock)', 'pid': 0, 'volume': 1.0},\n            {'name': 'Spotify (mock)', 'pid': 0, 'volume': 1.0},\n            {'name': 'Discord (mock)', 'pid': 0, 'volume': 1.0},\n            {'name': 'Chrome (mock)', 'pid': 0, 'volume': 1.0}\n        ]\n        \n    def set_app_volume(self, app_name: str, volume: float) -> bool:\n        volume = max(0.0, min(1.0, volume))\n        \n        if not self.is_windows or not self.pycaw_available:\n            print(f\"[AUDIO] (Mock) –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≥—Ä–æ–º–∫–æ—Å—Ç—å {app_name}: {int(volume * 100)}%\")\n            return True\n            \n        try:\n            from pycaw.pycaw import AudioUtilities\n            \n            sessions = AudioUtilities.GetAllSessions()\n            \n            for session in sessions:\n                if session.Process and app_name.lower() in session.Process.name().lower():\n                    volume_interface = session._ctl.QueryInterface(\n                        __import__('pycaw.pycaw', fromlist=['ISimpleAudioVolume']).ISimpleAudioVolume\n                    )\n                    volume_interface.SetMasterVolume(volume, None)\n                    print(f\"[AUDIO] –ì—Ä–æ–º–∫–æ—Å—Ç—å {session.Process.name()}: {int(volume * 100)}%\")\n                    return True\n                    \n            print(f\"[AUDIO] –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ '{app_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ\")\n            return False\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return False\n            \n    def get_app_volume(self, app_name: str) -> Optional[float]:\n        if not self.is_windows or not self.pycaw_available:\n            return 1.0\n            \n        try:\n            from pycaw.pycaw import AudioUtilities, ISimpleAudioVolume\n            \n            sessions = AudioUtilities.GetAllSessions()\n            \n            for session in sessions:\n                if session.Process and app_name.lower() in session.Process.name().lower():\n                    volume_interface = session._ctl.QueryInterface(ISimpleAudioVolume)\n                    return volume_interface.GetMasterVolume()\n                    \n            return None\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return None\n            \n    def mute_app(self, app_name: str) -> bool:\n        return self.set_app_volume(app_name, 0.0)\n        \n    def unmute_app(self, app_name: str, volume: float = 1.0) -> bool:\n        return self.set_app_volume(app_name, volume)\n        \n    def set_master_volume(self, volume: float) -> bool:\n        volume = max(0.0, min(1.0, volume))\n        \n        if not self.is_windows:\n            print(f\"[AUDIO] (Mock) –°–∏—Å—Ç–µ–º–Ω–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: {int(volume * 100)}%\")\n            return True\n            \n        if not self.pycaw_available:\n            try:\n                nircmd_volume = int(volume * 65535)\n                subprocess.run(['nircmd', 'setsysvolume', str(nircmd_volume)], check=True)\n                return True\n            except:\n                pass\n                \n        try:\n            from pycaw.pycaw import AudioUtilities\n            from comtypes import CLSCTX_ALL\n            from pycaw.pycaw import IAudioEndpointVolume\n            \n            devices = AudioUtilities.GetSpeakers()\n            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)\n            volume_interface = interface.QueryInterface(IAudioEndpointVolume)\n            volume_interface.SetMasterVolumeLevelScalar(volume, None)\n            \n            print(f\"[AUDIO] –°–∏—Å—Ç–µ–º–Ω–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: {int(volume * 100)}%\")\n            return True\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–∏—Å—Ç–µ–º–Ω–æ–π –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return False\n            \n    def get_master_volume(self) -> Optional[float]:\n        if not self.is_windows or not self.pycaw_available:\n            return 1.0\n            \n        try:\n            from pycaw.pycaw import AudioUtilities\n            from comtypes import CLSCTX_ALL\n            from pycaw.pycaw import IAudioEndpointVolume\n            \n            devices = AudioUtilities.GetSpeakers()\n            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)\n            volume_interface = interface.QueryInterface(IAudioEndpointVolume)\n            \n            return volume_interface.GetMasterVolumeLevelScalar()\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–Ω–æ–π –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return None\n\n    def parse_volume_command(self, command: str) -> Dict:\n        command = command.lower()\n        \n        result = {\n            'action': None,\n            'app': None,\n            'volume': None\n        }\n        \n        app_keywords = {\n            '–º—É–∑—ã–∫': ['yandex', 'spotify', '–º—É–∑—ã–∫'],\n            '—è–Ω–¥–µ–∫—Å': ['yandex'],\n            'spotify': ['spotify'],\n            '–¥–∏—Å–∫–æ—Ä–¥': ['discord'],\n            'discord': ['discord'],\n            '–±—Ä–∞—É–∑–µ—Ä': ['chrome', 'firefox', 'browser', 'edge'],\n            '—Ö—Ä–æ–º': ['chrome'],\n            'chrome': ['chrome']\n        }\n        \n        for keyword, apps in app_keywords.items():\n            if keyword in command:\n                result['app'] = apps[0]\n                break\n                \n        if '—Ç–∏—à–µ' in command or '—É–±–∞–≤' in command or '–ø–æ–Ω–∏–∑—å' in command:\n            result['action'] = 'decrease'\n            result['volume'] = 0.3\n        elif '–≥—Ä–æ–º—á–µ' in command or '–ø—Ä–∏–±–∞–≤' in command or '–ø–æ–≤—ã—Å—å' in command:\n            result['action'] = 'increase'\n            result['volume'] = 0.7\n        elif '–≤—ã–∫–ª—é—á' in command or '–∑–∞–º—É—Ç' in command or 'mute' in command:\n            result['action'] = 'mute'\n            result['volume'] = 0.0\n        elif '–≤–∫–ª—é—á' in command or '—Ä–∞–∑–º—É—Ç' in command or 'unmute' in command:\n            result['action'] = 'unmute'\n            result['volume'] = 1.0\n        elif any(word in command for word in ['50%', '–ø–æ–ª–æ–≤–∏–Ω', '—Å—Ä–µ–¥–Ω']):\n            result['action'] = 'set'\n            result['volume'] = 0.5\n        elif any(word in command for word in ['100%', '–º–∞–∫—Å–∏–º', '–ø–æ–ª–Ω']):\n            result['action'] = 'set'\n            result['volume'] = 1.0\n        elif any(word in command for word in ['25%', '—á–µ—Ç–≤–µ—Ä—Ç—å']):\n            result['action'] = 'set'\n            result['volume'] = 0.25\n            \n        return result\n        \n    def execute_voice_command(self, command: str) -> str:\n        parsed = self.parse_volume_command(command)\n        \n        if not parsed['action']:\n            return \"–ù–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –°–∫–∞–∂–∏ –Ω–∞–ø—Ä–∏–º–µ—Ä: '—Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ' –∏–ª–∏ '–≤—ã–∫–ª—é—á–∏ –¥–∏—Å–∫–æ—Ä–¥'\"\n            \n        if parsed['app']:\n            if parsed['action'] == 'mute':\n                success = self.mute_app(parsed['app'])\n                return f\"{'–í—ã–∫–ª—é—á–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ –≤—ã–∫–ª—é—á–∏—Ç—å'} {parsed['app']}\"\n            elif parsed['action'] == 'unmute':\n                success = self.unmute_app(parsed['app'])\n                return f\"{'–í–∫–ª—é—á–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ –≤–∫–ª—é—á–∏—Ç—å'} {parsed['app']}\"\n            else:\n                success = self.set_app_volume(parsed['app'], parsed['volume'])\n                percent = int(parsed['volume'] * 100)\n                return f\"{'–£—Å—Ç–∞–Ω–æ–≤–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å'} –≥—Ä–æ–º–∫–æ—Å—Ç—å {parsed['app']} –Ω–∞ {percent}%\"\n        else:\n            if parsed['action'] == 'mute':\n                success = self.set_master_volume(0.0)\n                return \"–í—ã–∫–ª—é—á–∏–ª–∞ –∑–≤—É–∫\" if success else \"–ù–µ —Å–º–æ–≥–ª–∞ –≤—ã–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫\"\n            elif parsed['action'] == 'unmute':\n                success = self.set_master_volume(1.0)\n                return \"–í–∫–ª—é—á–∏–ª–∞ –∑–≤—É–∫\" if success else \"–ù–µ —Å–º–æ–≥–ª–∞ –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫\"\n            else:\n                success = self.set_master_volume(parsed['volume'])\n                percent = int(parsed['volume'] * 100)\n                return f\"{'–£—Å—Ç–∞–Ω–æ–≤–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å'} —Å–∏—Å—Ç–µ–º–Ω—É—é –≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ {percent}%\"\n","path":null,"size_bytes":10209,"size_tokens":null},"src/achievements.py":{"content":"import time\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional, Callable\nfrom collections import defaultdict\n\n@dataclass\nclass Achievement:\n    id: str\n    name: str\n    description: str\n    icon: str = \"üèÜ\"\n    unlocked: bool = False\n    unlocked_at: Optional[float] = None\n    progress: int = 0\n    target: int = 1\n\n@dataclass\nclass StreamStats:\n    total_kills: int = 0\n    total_deaths: int = 0\n    total_assists: int = 0\n    rounds_won: int = 0\n    rounds_lost: int = 0\n    clutches_won: int = 0\n    aces: int = 0\n    headshots: int = 0\n    donations_received: int = 0\n    donations_total: float = 0.0\n    new_subscribers: int = 0\n    raids_received: int = 0\n    chat_messages: int = 0\n    stream_duration: float = 0.0\n    kill_streak_max: int = 0\n    death_streak_max: int = 0\n    current_kill_streak: int = 0\n    current_death_streak: int = 0\n    matches_played: int = 0\n    matches_won: int = 0\n\nclass AchievementSystem:\n    def __init__(self, achievement_callback: Optional[Callable[[Achievement], None]] = None):\n        self.achievement_callback = achievement_callback\n        self.stats = StreamStats()\n        self.session_start = time.time()\n        self.achievements: Dict[str, Achievement] = {}\n        self._init_achievements()\n        \n    def _init_achievements(self):\n        achievements_data = [\n            (\"first_blood\", \"–ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å\", \"–ü–µ—Ä–≤–æ–µ —É–±–∏–π—Å—Ç–≤–æ –Ω–∞ —Å—Ç—Ä–∏–º–µ\", \"ü©∏\", 1),\n            (\"killing_spree\", \"–°–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤\", \"5 —É–±–∏–π—Å—Ç–≤ –ø–æ–¥—Ä—è–¥ –±–µ–∑ —Å–º–µ—Ä—Ç–∏\", \"üî•\", 5),\n            (\"unstoppable\", \"–ù–µ–æ—Å—Ç–∞–Ω–æ–≤–∏–º—ã–π\", \"10 —É–±–∏–π—Å—Ç–≤ –ø–æ–¥—Ä—è–¥ –±–µ–∑ —Å–º–µ—Ä—Ç–∏\", \"‚ö°\", 10),\n            (\"ace_master\", \"–ú–∞—Å—Ç–µ—Ä ACE\", \"–°–¥–µ–ª–∞—Ç—å ACE (5 —É–±–∏–π—Å—Ç–≤ –≤ —Ä–∞—É–Ω–¥–µ)\", \"üéØ\", 1),\n            (\"clutch_king\", \"–ö–æ—Ä–æ–ª—å –∫–ª–∞—Ç—á–µ–π\", \"–í—ã–∏–≥—Ä–∞—Ç—å 3 clutch —Å–∏—Ç—É–∞—Ü–∏–∏\", \"üëë\", 3),\n            (\"headhunter\", \"–û—Ö–æ—Ç–Ω–∏–∫ –∑–∞ –≥–æ–ª–æ–≤–∞–º–∏\", \"50 —Ö–µ–¥—à–æ—Ç–æ–≤ –∑–∞ —Å—Ç—Ä–∏–º\", \"üíÄ\", 50),\n            (\"survivor\", \"–í—ã–∂–∏–≤—à–∏–π\", \"–í—ã–∂–∏—Ç—å —Å 1 HP\", \"‚ù§Ô∏è\", 1),\n            (\"comeback_kid\", \"–ö–∞–º–±—ç–∫\", \"–í—ã–∏–≥—Ä–∞—Ç—å –º–∞—Ç—á –ø—Ä–æ–∏–≥—Ä—ã–≤–∞—è 5+ —Ä–∞—É–Ω–¥–æ–≤\", \"üîÑ\", 1),\n            (\"popular\", \"–ü–æ–ø—É–ª—è—Ä–Ω—ã–π\", \"–ü–æ–ª—É—á–∏—Ç—å 10 —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ\", \"üí¨\", 10),\n            (\"loved\", \"–õ—é–±–∏–º–µ—Ü\", \"–ü–æ–ª—É—á–∏—Ç—å 5 –¥–æ–Ω–∞—Ç–æ–≤\", \"üíù\", 5),\n            (\"whale_friend\", \"–î—Ä—É–≥ –∫–∏—Ç–æ–≤\", \"–ü–æ–ª—É—á–∏—Ç—å –¥–æ–Ω–∞—Ç 1000+ —Ä—É–±–ª–µ–π\", \"üêã\", 1),\n            (\"raided\", \"–ü–æ–¥ —Ä–µ–π–¥–æ–º\", \"–ü–æ–ª—É—á–∏—Ç—å —Ä–µ–π–¥ 50+ –∑—Ä–∏—Ç–µ–ª–µ–π\", \"üöÄ\", 1),\n            (\"marathon\", \"–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü\", \"–°—Ç—Ä–∏–º–∏—Ç—å 4+ —á–∞—Å–∞\", \"‚è±Ô∏è\", 1),\n            (\"consistent\", \"–°—Ç–∞–±–∏–ª—å–Ω—ã–π\", \"–ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π KD –≤–µ—Å—å –º–∞—Ç—á\", \"üìà\", 1),\n            (\"team_player\", \"–ö–æ–º–∞–Ω–¥–Ω—ã–π –∏–≥—Ä–æ–∫\", \"10 –∞—Å—Å–∏—Å—Ç–æ–≤ –∑–∞ –º–∞—Ç—á\", \"ü§ù\", 10),\n            (\"economical\", \"–≠–∫–æ–Ω–æ–º–Ω—ã–π\", \"–í—ã–∏–≥—Ä–∞—Ç—å —ç–∫–æ —Ä–∞—É–Ω–¥\", \"üí∞\", 1),\n            (\"ninja\", \"–ù–∏–Ω–¥–∑—è\", \"–î–µ—Ñ—É–∑ –±–æ–º–±—ã –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–µ–∫—É–Ω–¥–µ\", \"ü•∑\", 1),\n            (\"dedication\", \"–ü—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å\", \"10 –º–∞—Ç—á–µ–π –∑–∞ —Å–µ—Å—Å–∏—é\", \"üéÆ\", 10),\n            (\"sub_love\", \"–õ—é–±–æ–≤—å –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\", \"10 –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\", \"üíú\", 10),\n            (\"perfect_round\", \"–ò–¥–µ–∞–ª—å–Ω—ã–π —Ä–∞—É–Ω–¥\", \"–í—ã–∏–≥—Ä–∞—Ç—å —Ä–∞—É–Ω–¥ –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ HP\", \"‚ú®\", 1),\n        ]\n        \n        for ach_id, name, desc, icon, target in achievements_data:\n            self.achievements[ach_id] = Achievement(\n                id=ach_id,\n                name=name,\n                description=desc,\n                icon=icon,\n                target=target\n            )\n            \n    def _unlock_achievement(self, ach_id: str):\n        if ach_id not in self.achievements:\n            return\n            \n        achievement = self.achievements[ach_id]\n        if achievement.unlocked:\n            return\n            \n        achievement.unlocked = True\n        achievement.unlocked_at = time.time()\n        achievement.progress = achievement.target\n        \n        print(f\"[ACHIEVEMENT] üèÜ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: {achievement.name} - {achievement.description}\")\n        \n        if self.achievement_callback:\n            self.achievement_callback(achievement)\n            \n    def _update_progress(self, ach_id: str, progress: int = 1):\n        if ach_id not in self.achievements:\n            return\n            \n        achievement = self.achievements[ach_id]\n        if achievement.unlocked:\n            return\n            \n        achievement.progress += progress\n        \n        if achievement.progress >= achievement.target:\n            self._unlock_achievement(ach_id)\n            \n    def record_kill(self, headshot: bool = False, round_kills: int = 1):\n        self.stats.total_kills += 1\n        self.stats.current_kill_streak += 1\n        self.stats.current_death_streak = 0\n        \n        if self.stats.current_kill_streak > self.stats.kill_streak_max:\n            self.stats.kill_streak_max = self.stats.current_kill_streak\n            \n        if headshot:\n            self.stats.headshots += 1\n            self._update_progress(\"headhunter\", 1)\n            \n        if self.stats.total_kills == 1:\n            self._unlock_achievement(\"first_blood\")\n            \n        if self.stats.current_kill_streak >= 5:\n            self._unlock_achievement(\"killing_spree\")\n            \n        if self.stats.current_kill_streak >= 10:\n            self._unlock_achievement(\"unstoppable\")\n            \n        if round_kills >= 5:\n            self.stats.aces += 1\n            self._unlock_achievement(\"ace_master\")\n            \n    def record_death(self):\n        self.stats.total_deaths += 1\n        self.stats.current_death_streak += 1\n        self.stats.current_kill_streak = 0\n        \n        if self.stats.current_death_streak > self.stats.death_streak_max:\n            self.stats.death_streak_max = self.stats.current_death_streak\n            \n    def record_assist(self):\n        self.stats.total_assists += 1\n        self._update_progress(\"team_player\", 1)\n        \n    def record_round_win(self, clutch: bool = False, eco: bool = False, perfect: bool = False):\n        self.stats.rounds_won += 1\n        \n        if clutch:\n            self.stats.clutches_won += 1\n            self._update_progress(\"clutch_king\", 1)\n            \n        if eco:\n            self._unlock_achievement(\"economical\")\n            \n        if perfect:\n            self._unlock_achievement(\"perfect_round\")\n            \n    def record_round_loss(self):\n        self.stats.rounds_lost += 1\n        \n    def record_low_health_survive(self, health: int):\n        if health <= 1:\n            self._unlock_achievement(\"survivor\")\n            \n    def record_ninja_defuse(self):\n        self._unlock_achievement(\"ninja\")\n        \n    def record_donation(self, amount: float, currency: str = \"RUB\"):\n        self.stats.donations_received += 1\n        self.stats.donations_total += amount\n        \n        self._update_progress(\"loved\", 1)\n        \n        if currency == \"RUB\" and amount >= 1000:\n            self._unlock_achievement(\"whale_friend\")\n        elif currency == \"USD\" and amount >= 15:\n            self._unlock_achievement(\"whale_friend\")\n            \n    def record_subscription(self):\n        self.stats.new_subscribers += 1\n        self._update_progress(\"sub_love\", 1)\n        \n    def record_raid(self, viewers: int):\n        self.stats.raids_received += 1\n        \n        if viewers >= 50:\n            self._unlock_achievement(\"raided\")\n            \n    def record_chat_message(self):\n        self.stats.chat_messages += 1\n        self._update_progress(\"popular\", 1)\n        \n    def record_match_end(self, won: bool, came_back: bool = False):\n        self.stats.matches_played += 1\n        \n        if won:\n            self.stats.matches_won += 1\n            \n            if came_back:\n                self._unlock_achievement(\"comeback_kid\")\n                \n            if self.stats.total_kills > self.stats.total_deaths:\n                self._unlock_achievement(\"consistent\")\n                \n        self._update_progress(\"dedication\", 1)\n        \n    def check_time_achievements(self):\n        duration_hours = (time.time() - self.session_start) / 3600\n        self.stats.stream_duration = duration_hours\n        \n        if duration_hours >= 4:\n            self._unlock_achievement(\"marathon\")\n            \n    def get_unlocked_achievements(self) -> List[Achievement]:\n        return [a for a in self.achievements.values() if a.unlocked]\n        \n    def get_locked_achievements(self) -> List[Achievement]:\n        return [a for a in self.achievements.values() if not a.unlocked]\n        \n    def get_progress_summary(self) -> str:\n        unlocked = len(self.get_unlocked_achievements())\n        total = len(self.achievements)\n        \n        return f\"–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è: {unlocked}/{total}\"\n        \n    def get_stats_summary(self) -> str:\n        s = self.stats\n        kd = s.total_kills / max(1, s.total_deaths)\n        \n        return f\"\"\"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∏–º–∞:\nüéØ K/D/A: {s.total_kills}/{s.total_deaths}/{s.total_assists} (KD: {kd:.2f})\nüèÜ –†–∞—É–Ω–¥—ã: {s.rounds_won}W / {s.rounds_lost}L\nüî• –ú–∞–∫—Å. —Å–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤: {s.kill_streak_max}\nüíÄ –•–µ–¥—à–æ—Ç—ã: {s.headshots}\nüëë Clutch –ø–æ–±–µ–¥: {s.clutches_won}\n‚≠ê ACE: {s.aces}\nüí∞ –î–æ–Ω–∞—Ç—ã: {s.donations_received} ({s.donations_total:.0f} —Ä—É–±.)\nüíú –ü–æ–¥–ø–∏—Å—á–∏–∫–∏: {s.new_subscribers}\nüí¨ –°–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ: {s.chat_messages}\n‚è±Ô∏è –í—Ä–µ–º—è —Å—Ç—Ä–∏–º–∞: {s.stream_duration:.1f} —á\"\"\"\n\n    def save_stats(self, filepath: str = \"stream_stats.json\"):\n        data = {\n            'stats': self.stats.__dict__,\n            'achievements': {\n                k: {\n                    'unlocked': v.unlocked,\n                    'unlocked_at': v.unlocked_at,\n                    'progress': v.progress\n                }\n                for k, v in self.achievements.items()\n            },\n            'session_start': self.session_start\n        }\n        \n        with open(filepath, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=2)\n            \n        print(f\"[ACHIEVEMENTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {filepath}\")\n        \n    def load_stats(self, filepath: str = \"stream_stats.json\") -> bool:\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                \n            for key, value in data.get('stats', {}).items():\n                if hasattr(self.stats, key):\n                    setattr(self.stats, key, value)\n                    \n            for ach_id, ach_data in data.get('achievements', {}).items():\n                if ach_id in self.achievements:\n                    self.achievements[ach_id].unlocked = ach_data.get('unlocked', False)\n                    self.achievements[ach_id].unlocked_at = ach_data.get('unlocked_at')\n                    self.achievements[ach_id].progress = ach_data.get('progress', 0)\n                    \n            print(f\"[ACHIEVEMENTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {filepath}\")\n            return True\n            \n        except FileNotFoundError:\n            return False\n        except Exception as e:\n            print(f\"[ACHIEVEMENTS] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}\")\n            return False\n","path":null,"size_bytes":11655,"size_tokens":null},"src/cs2_gsi.py":{"content":"import json\nimport time\nimport threading\nfrom flask import Flask, request, jsonify\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Callable, Dict, List, Any\nfrom collections import deque\n\n@dataclass\nclass PlayerState:\n    name: str = \"\"\n    team: str = \"\"\n    health: int = 100\n    armor: int = 0\n    helmet: bool = False\n    money: int = 0\n    round_kills: int = 0\n    round_killhs: int = 0\n    equip_value: int = 0\n    kills: int = 0\n    assists: int = 0\n    deaths: int = 0\n    mvps: int = 0\n    score: int = 0\n    weapon: str = \"\"\n    \n@dataclass \nclass RoundState:\n    phase: str = \"\"\n    bomb: str = \"\"\n    win_team: str = \"\"\n    \n@dataclass\nclass MapState:\n    name: str = \"\"\n    mode: str = \"\"\n    phase: str = \"\"\n    round: int = 0\n    ct_score: int = 0\n    t_score: int = 0\n    \n@dataclass\nclass GameEvent:\n    event_type: str\n    data: Dict[str, Any]\n    timestamp: float = field(default_factory=time.time)\n\nclass CS2GameStateIntegration:\n    def __init__(self, \n                 port: int = 3000,\n                 event_callback: Optional[Callable[[GameEvent], None]] = None):\n        \n        self.port = port\n        self.event_callback = event_callback\n        \n        self.player = PlayerState()\n        self.round = RoundState()\n        self.map = MapState()\n        self.previous_state: Dict = {}\n        \n        self.events_history: deque = deque(maxlen=100)\n        self.kill_streak = 0\n        self.round_start_kills = 0\n        self.clutch_situation = False\n        self.clutch_enemies = 0\n        \n        self.app = Flask(__name__)\n        self._setup_routes()\n        \n        self.server_thread = None\n        self.is_running = False\n        \n    def _setup_routes(self):\n        @self.app.route('/', methods=['POST'])\n        def gsi_handler():\n            try:\n                data = request.get_json()\n                if data:\n                    self._process_game_state(data)\n                return jsonify({\"status\": \"ok\"})\n            except Exception as e:\n                print(f\"[CS2 GSI] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}\")\n                return jsonify({\"status\": \"error\"}), 500\n                \n        @self.app.route('/health', methods=['GET'])\n        def health_check():\n            return jsonify({\n                \"status\": \"running\",\n                \"player\": self.player.name,\n                \"map\": self.map.name,\n                \"round\": self.map.round\n            })\n            \n    def _process_game_state(self, data: Dict):\n        player_data = data.get('player', {})\n        if player_data:\n            state = player_data.get('state', {})\n            match_stats = player_data.get('match_stats', {})\n            weapons = player_data.get('weapons', {})\n            \n            old_health = self.player.health\n            old_kills = self.player.kills\n            old_deaths = self.player.deaths\n            old_round_kills = self.player.round_kills\n            \n            self.player.name = player_data.get('name', self.player.name)\n            self.player.team = player_data.get('team', self.player.team)\n            self.player.health = state.get('health', self.player.health)\n            self.player.armor = state.get('armor', self.player.armor)\n            self.player.helmet = state.get('helmet', self.player.helmet)\n            self.player.money = state.get('money', self.player.money)\n            self.player.round_kills = state.get('round_kills', self.player.round_kills)\n            self.player.round_killhs = state.get('round_killhs', self.player.round_killhs)\n            self.player.equip_value = state.get('equip_value', self.player.equip_value)\n            \n            self.player.kills = match_stats.get('kills', self.player.kills)\n            self.player.assists = match_stats.get('assists', self.player.assists)\n            self.player.deaths = match_stats.get('deaths', self.player.deaths)\n            self.player.mvps = match_stats.get('mvps', self.player.mvps)\n            self.player.score = match_stats.get('score', self.player.score)\n            \n            for weapon_key, weapon_data in weapons.items():\n                if weapon_data.get('state') == 'active':\n                    self.player.weapon = weapon_data.get('name', '')\n                    break\n                    \n            if self.player.kills > old_kills:\n                self._emit_kill_event(self.player.kills - old_kills)\n                \n            if self.player.deaths > old_deaths:\n                self._emit_death_event()\n                \n            if self.player.health < old_health and self.player.health > 0:\n                self._emit_damage_event(old_health - self.player.health)\n                \n        round_data = data.get('round', {})\n        if round_data:\n            old_phase = self.round.phase\n            old_bomb = self.round.bomb\n            \n            self.round.phase = round_data.get('phase', self.round.phase)\n            self.round.bomb = round_data.get('bomb', self.round.bomb)\n            self.round.win_team = round_data.get('win_team', self.round.win_team)\n            \n            if self.round.phase == 'freezetime' and old_phase != 'freezetime':\n                self._emit_round_start_event()\n                \n            if self.round.phase == 'over' and old_phase != 'over':\n                self._emit_round_end_event()\n                \n            if self.round.bomb == 'planted' and old_bomb != 'planted':\n                self._emit_bomb_planted_event()\n                \n            if self.round.bomb == 'defused' and old_bomb != 'defused':\n                self._emit_bomb_defused_event()\n                \n            if self.round.bomb == 'exploded' and old_bomb != 'exploded':\n                self._emit_bomb_exploded_event()\n                \n        map_data = data.get('map', {})\n        if map_data:\n            old_round = self.map.round\n            \n            self.map.name = map_data.get('name', self.map.name)\n            self.map.mode = map_data.get('mode', self.map.mode)\n            self.map.phase = map_data.get('phase', self.map.phase)\n            self.map.round = map_data.get('round', self.map.round)\n            \n            team_ct = map_data.get('team_ct', {})\n            team_t = map_data.get('team_t', {})\n            self.map.ct_score = team_ct.get('score', self.map.ct_score)\n            self.map.t_score = team_t.get('score', self.map.t_score)\n            \n            if self.map.phase == 'gameover':\n                self._emit_match_end_event()\n                \n        self.previous_state = data\n        \n    def _emit_event(self, event_type: str, data: Dict = None):\n        event = GameEvent(event_type=event_type, data=data or {})\n        self.events_history.append(event)\n        \n        if self.event_callback:\n            try:\n                self.event_callback(event)\n            except Exception as e:\n                print(f\"[CS2 GSI] –û—à–∏–±–∫–∞ callback: {e}\")\n                \n    def _emit_kill_event(self, kill_count: int):\n        self.kill_streak += kill_count\n        \n        event_data = {\n            'kills_this_action': kill_count,\n            'round_kills': self.player.round_kills,\n            'total_kills': self.player.kills,\n            'kill_streak': self.kill_streak,\n            'headshot': self.player.round_killhs > 0,\n            'weapon': self.player.weapon,\n            'clutch': self.clutch_situation,\n            'clutch_enemies': self.clutch_enemies\n        }\n        \n        if self.player.round_kills >= 5:\n            event_data['ace'] = True\n            self._emit_event('ace', event_data)\n        elif self.player.round_kills >= 4:\n            self._emit_event('quadra_kill', event_data)\n        elif self.player.round_kills >= 3:\n            self._emit_event('triple_kill', event_data)\n        elif self.player.round_kills >= 2:\n            self._emit_event('double_kill', event_data)\n        else:\n            self._emit_event('kill', event_data)\n            \n    def _emit_death_event(self):\n        self.kill_streak = 0\n        \n        event_data = {\n            'total_deaths': self.player.deaths,\n            'kd_ratio': self.player.kills / max(1, self.player.deaths),\n            'round': self.map.round\n        }\n        self._emit_event('death', event_data)\n        \n    def _emit_damage_event(self, damage: int):\n        event_data = {\n            'damage': damage,\n            'current_health': self.player.health,\n            'armor': self.player.armor\n        }\n        \n        if self.player.health <= 25:\n            self._emit_event('low_health', event_data)\n        elif damage >= 50:\n            self._emit_event('heavy_damage', event_data)\n            \n    def _emit_round_start_event(self):\n        self.kill_streak = 0\n        self.round_start_kills = self.player.kills\n        self.clutch_situation = False\n        \n        event_data = {\n            'round': self.map.round,\n            'ct_score': self.map.ct_score,\n            't_score': self.map.t_score,\n            'money': self.player.money,\n            'equip_value': self.player.equip_value\n        }\n        \n        if self.player.money < 2000:\n            event_data['eco_round'] = True\n            \n        self._emit_event('round_start', event_data)\n        \n    def _emit_round_end_event(self):\n        round_kills = self.player.kills - self.round_start_kills\n        \n        event_data = {\n            'round': self.map.round,\n            'win_team': self.round.win_team,\n            'player_team': self.player.team,\n            'won': self.round.win_team.lower() == self.player.team.lower() if self.round.win_team else False,\n            'round_kills': round_kills,\n            'clutch_win': self.clutch_situation and round_kills > 0\n        }\n        \n        if round_kills >= 3:\n            event_data['mvp_candidate'] = True\n            \n        self._emit_event('round_end', event_data)\n        \n    def _emit_bomb_planted_event(self):\n        event_data = {\n            'round': self.map.round,\n            'player_team': self.player.team\n        }\n        self._emit_event('bomb_planted', event_data)\n        \n    def _emit_bomb_defused_event(self):\n        event_data = {\n            'round': self.map.round,\n            'player_team': self.player.team,\n            'ninja_defuse': self.player.health <= 10\n        }\n        self._emit_event('bomb_defused', event_data)\n        \n    def _emit_bomb_exploded_event(self):\n        event_data = {\n            'round': self.map.round,\n            'player_team': self.player.team\n        }\n        self._emit_event('bomb_exploded', event_data)\n        \n    def _emit_match_end_event(self):\n        event_data = {\n            'ct_score': self.map.ct_score,\n            't_score': self.map.t_score,\n            'player_team': self.player.team,\n            'won': (self.player.team == 'CT' and self.map.ct_score > self.map.t_score) or\n                   (self.player.team == 'T' and self.map.t_score > self.map.ct_score),\n            'kills': self.player.kills,\n            'deaths': self.player.deaths,\n            'assists': self.player.assists,\n            'mvps': self.player.mvps,\n            'map': self.map.name\n        }\n        self._emit_event('match_end', event_data)\n        \n    def start(self):\n        if self.is_running:\n            return\n            \n        self.is_running = True\n        self.server_thread = threading.Thread(\n            target=lambda: self.app.run(host='0.0.0.0', port=self.port, debug=False, use_reloader=False),\n            daemon=True\n        )\n        self.server_thread.start()\n        print(f\"[CS2 GSI] –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {self.port}\")\n        \n    def stop(self):\n        self.is_running = False\n        \n    def get_player_stats(self) -> Dict:\n        return {\n            'name': self.player.name,\n            'team': self.player.team,\n            'health': self.player.health,\n            'armor': self.player.armor,\n            'money': self.player.money,\n            'kills': self.player.kills,\n            'deaths': self.player.deaths,\n            'assists': self.player.assists,\n            'kd_ratio': round(self.player.kills / max(1, self.player.deaths), 2),\n            'mvps': self.player.mvps,\n            'score': self.player.score\n        }\n        \n    def get_match_info(self) -> Dict:\n        return {\n            'map': self.map.name,\n            'mode': self.map.mode,\n            'round': self.map.round,\n            'ct_score': self.map.ct_score,\n            't_score': self.map.t_score,\n            'phase': self.map.phase\n        }\n        \n    def generate_config_file(self) -> str:\n        config = f'''\"Iris Stream Assistant\"\n{{\n    \"uri\" \"http://localhost:{self.port}/\"\n    \"timeout\" \"5.0\"\n    \"buffer\" \"0.1\"\n    \"throttle\" \"0.1\"\n    \"heartbeat\" \"10.0\"\n    \"auth\"\n    {{\n        \"token\" \"iris_stream_assistant\"\n    }}\n    \"data\"\n    {{\n        \"provider\"            \"1\"\n        \"map\"                 \"1\"\n        \"round\"               \"1\"\n        \"player_id\"           \"1\"\n        \"player_state\"        \"1\"\n        \"player_weapons\"      \"1\"\n        \"player_match_stats\"  \"1\"\n        \"allplayers_id\"       \"1\"\n        \"allplayers_state\"    \"1\"\n        \"bomb\"                \"1\"\n        \"phase_countdowns\"    \"1\"\n    }}\n}}'''\n        return config\n        \n    def save_config_file(self, path: str = \"gamestate_integration_iris.cfg\"):\n        config = self.generate_config_file()\n        with open(path, 'w') as f:\n            f.write(config)\n        print(f\"[CS2 GSI] –ö–æ–Ω—Ñ–∏–≥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {path}\")\n        print(f\"[CS2 GSI] –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤: <Steam>/steamapps/common/Counter-Strike Global Offensive/game/csgo/cfg/\")\n        return path\n","path":null,"size_bytes":13704,"size_tokens":null},"src/utils/tts_utils.py":{"content":"\"\"\"\nTTS Utils - –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API\n\"\"\"\nfrom src.utils import synthesize_and_play\n\n__all__ = ['synthesize_and_play']\n","path":null,"size_bytes":146,"size_tokens":null},"src/__init__.py":{"content":"\nfrom .voice_recognition import VoiceRecognition, TextInputFallback\nfrom .cs2_gsi import CS2GameStateIntegration, GameEvent\nfrom .streamelements_client import StreamElementsClient, StreamEvent\nfrom .iris_brain import IrisBrain\nfrom .windows_audio import WindowsAudioController\nfrom .achievements import AchievementSystem, Achievement, StreamStats\n\n__all__ = [\n    'TTSEngine',\n    'VoiceRecognition', \n    'TextInputFallback',\n    'CS2GameStateIntegration',\n    'GameEvent',\n    'StreamElementsClient',\n    'StreamEvent',\n    'IrisBrain',\n    'WindowsAudioController',\n    'AchievementSystem',\n    'Achievement',\n    'StreamStats'\n]\n","path":null,"size_bytes":633,"size_tokens":null},"temp_repo/attached_assets/streamelements_client_1765902075685.py":{"content":"import json\r\nimport websocket\r\n\r\n# –í—Å—Ç–∞–≤—å—Ç–µ –≤–∞—à —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω —Å—é–¥–∞\r\nYOUR_JWT_TOKEN = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjaXRhZGVsIiwiZXhwIjoxNzgxNDUzNDYwLCJqdGkiOiJjYzM3ZjUwNS1lNGRkLTQxZjktOGIwZS1lNTNhZjUzM2M0ODIiLCJjaGFubmVsIjoiNjk0MTg0OTNjMjdmNzk4NGQ1Y2UwNmNkIiwicm9sZSI6Im93bmVyIiwiYXV0aFRva2VuIjoiMVdQckRUYUZUN21mc3RHSlNfZFpxV3NtNmlicFhYeGdDbmdjcThpeHlCbG9HTXpVIiwidXNlciI6IjY5NDE4NDkzYzI3Zjc5ODRkNWNlMDZjYyIsInVzZXJfaWQiOiIwYjhiZTJhZS1kNjIyLTRlNGEtODdmMy01NjJhYTcxMGM5YWYiLCJ1c2VyX3JvbGUiOiJjcmVhdG9yIiwicHJvdmlkZXIiOiJ0d2l0Y2giLCJwcm92aWRlcl9pZCI6IjE4NzU3MjUyNyIsImNoYW5uZWxfaWQiOiJlMjU4YzczZS04ZTgxLTQyNzktOGNjMS0wZWI2OTE2ZmIyMDMiLCJjcmVhdG9yX2lkIjoiNGQ4Zjk5YzktMGE3OC00YjlkLWJlNWEtZjVmNDY2ZGMyZjk4In0.UDj-xNNlOjOplW8gliL0-cb9S8_rnuCZaQCpLUvMq1o\"\r\n\r\ndef on_message(ws, message):\r\n    \"\"\"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç StreamElements.\"\"\"\r\n    try:\r\n        data = json.loads(message)\r\n    except json.JSONDecodeError:\r\n        # –ò–Ω–æ–≥–¥–∞ –ø—Ä–∏—Ö–æ–¥—è—Ç —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –∏—Ö –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å\r\n        return\r\n\r\n    # StreamElements –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–±—ã—Ç–∏—è –≤ –ø–æ–ª–µ 'type'\r\n    event_type = data.get('type')\r\n    listener = data.get('listener')\r\n\r\n    # –°–æ–±—ã—Ç–∏–µ —á–∞—Ç–∞\r\n    if listener == 'chat-message':\r\n        event_data = data.get('data', {})\r\n        username = event_data.get('displayName', '–ê–Ω–æ–Ω–∏–º')\r\n        user_message = event_data.get('message', '')\r\n        print(f'[–ß–ê–¢] {username}: {user_message}')\r\n        # –¢—É—Ç –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≤–∞—à –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞\r\n\r\n    # –°–æ–±—ã—Ç–∏–µ –¥–æ–Ω–∞—Ç–∞ (—Ç–∏–ø 'tip')\r\n    elif event_type == 'tip':\r\n        event_data = data.get('data', {})\r\n        donor = event_data.get('username', '–ê–Ω–æ–Ω–∏–º')\r\n        amount = event_data.get('amount', 0)\r\n        currency = event_data.get('currency', 'USD')\r\n        print(f'[–î–û–ù–ê–¢] {donor} - {amount} {currency}')\r\n        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º\r\n\r\n    # –°–æ–±—ã—Ç–∏–µ –Ω–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ (—Ç–∏–ø 'subscriber')\r\n    elif event_type == 'subscriber':\r\n        event_data = data.get('data', {})\r\n        subscriber = event_data.get('username', '–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫')\r\n        print(f'[–ü–û–î–ü–ò–°–ö–ê] {subscriber}')\r\n        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏\r\n\r\ndef on_error(ws, error):\r\n    print(f\"–û—à–∏–±–∫–∞ WebSocket: {error}\")\r\n\r\ndef on_close(ws, close_status_code, close_msg):\r\n    print(\"–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å StreamElements –∑–∞–∫—Ä—ã—Ç–æ\")\r\n\r\ndef on_open(ws):\r\n    print(\"–£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ StreamElements WebSocket!\")\r\n    # –ü–æ—Å–ª–µ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω—É–∂–Ω–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å—Å—è\r\n    auth_message = {\r\n        \"method\": \"jwt\",\r\n        \"token\": YOUR_JWT_TOKEN\r\n    }\r\n    ws.send(json.dumps(auth_message))\r\n\r\nif __name__ == \"__main__\":\r\n    ws_url = \"wss://realtime.streamelements.com/socket.io/?EIO=4&transport=websocket\"\r\n    ws = websocket.WebSocketApp(ws_url,\r\n                                on_open=on_open,\r\n                                on_message=on_message,\r\n                                on_error=on_error,\r\n                                on_close=on_close)\r\n    ws.run_forever()","path":null,"size_bytes":3407,"size_tokens":null},"setup.py":{"content":"# setup.py\nimport os\n\n# –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ñ–∞–π–ª—ã –∏ –ø–∞–ø–∫–∏\npaths = [\n    \"src/__init__.py\",\n    \"src/utils/__init__.py\",\n    \"src/utils/tts_utils.py\",\n    \"src/tts_engine.py\",\n    \"main.py\"\n]\n\nfor path in paths:\n    dir_name = os.path.dirname(path)\n    if dir_name and not os.path.exists(dir_name):\n        os.makedirs(dir_name, exist_ok=True)\n    \n    if not os.path.exists(path):\n        if path.endswith(\"__init__.py\"):\n            # –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª\n            with open(path, 'w', encoding='utf-8') as f:\n                f.write(\"# Package initializer\\n\")\n        print(f\"–°–æ–∑–¥–∞–Ω: {path}\")\n\nprint(\"–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ –≥–æ—Ç–æ–≤–∞!\")","path":null,"size_bytes":706,"size_tokens":null},"src/tts_engine.py":{"content":"\"\"\"\nIris TTS Engine - –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å —Å Edge TTS\n–ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ —Å —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º–∏ –∏–Ω—Ç–æ–Ω–∞—Ü–∏—è–º–∏\n\"\"\"\nimport asyncio\nimport tempfile\nimport os\nimport sys\nimport threading\nimport queue\nimport time\nfrom pathlib import Path\nfrom typing import Optional, Dict, Callable\n\ntry:\n    import edge_tts\n    EDGE_TTS_AVAILABLE = True\nexcept ImportError:\n    EDGE_TTS_AVAILABLE = False\n    print(\"[TTS] edge-tts –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install edge-tts\")\n\ntry:\n    import pygame\n    PYGAME_AVAILABLE = True\nexcept ImportError:\n    PYGAME_AVAILABLE = False\n    print(\"[TTS] pygame –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install pygame\")\n\n\nclass TTSEngine:\n    \"\"\"\n    –î–≤–∏–∂–æ–∫ —Å–∏–Ω—Ç–µ–∑–∞ —Ä–µ—á–∏ —Å –Ω–µ–∂–Ω—ã–º –∂–µ–Ω—Å–∫–∏–º –≥–æ–ª–æ—Å–æ–º\n    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Edge TTS (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π, –≤—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ)\n    \"\"\"\n    \n    VOICES = {\n        'ru_female_soft': 'ru-RU-SvetlanaNeural',\n        'ru_female_warm': 'ru-RU-DariyaNeural', \n        'ru_male': 'ru-RU-DmitryNeural',\n        'en_female_soft': 'en-US-JennyNeural',\n        'en_female_warm': 'en-US-AriaNeural',\n        'en_male': 'en-US-GuyNeural',\n    }\n    \n    EMOTION_STYLES = {\n        'neutral': {'rate': '+0%', 'pitch': '+0Hz', 'volume': '+0%'},\n        'excited': {'rate': '+15%', 'pitch': '+3Hz', 'volume': '+10%'},\n        'happy': {'rate': '+10%', 'pitch': '+2Hz', 'volume': '+5%'},\n        'sad': {'rate': '-10%', 'pitch': '-2Hz', 'volume': '-5%'},\n        'supportive': {'rate': '-5%', 'pitch': '+1Hz', 'volume': '+0%'},\n        'sarcastic': {'rate': '-5%', 'pitch': '-1Hz', 'volume': '+0%'},\n        'tense': {'rate': '+20%', 'pitch': '+4Hz', 'volume': '+15%'},\n        'gentle': {'rate': '-15%', 'pitch': '+2Hz', 'volume': '-10%'},\n    }\n    \n    def __init__(self, \n                 voice: str = 'ru_female_soft',\n                 rate: int = 0,\n                 volume: float = 1.0,\n                 lang: str = 'ru'):\n        \"\"\"\n        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TTS –¥–≤–∏–∂–∫–∞\n        \n        Args:\n            voice: –ò–º—è –≥–æ–ª–æ—Å–∞ –∏–∑ VOICES –∏–ª–∏ –ø—Ä—è–º–æ–µ –∏–º—è Edge TTS\n            rate: –°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ—á–∏ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (-50 –¥–æ +50)\n            volume: –ì—Ä–æ–º–∫–æ—Å—Ç—å (0.0-1.0)\n            lang: –Ø–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é\n        \"\"\"\n        self.voice_name = self.VOICES.get(voice, voice)\n        self.base_rate = rate\n        self.base_volume = volume\n        self.lang = lang\n        \n        self.speech_queue = queue.Queue()\n        self.is_speaking = False\n        self.stop_flag = False\n        self.current_emotion = 'neutral'\n        self.playback_available = False\n        \n        self._init_pygame()\n        \n        self.worker_thread = threading.Thread(target=self._speech_worker, daemon=True)\n        self.worker_thread.start()\n        \n        print(f\"[TTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –≥–æ–ª–æ—Å–æ–º: {self.voice_name}\")\n        print(f\"[TTS] Edge TTS –¥–æ—Å—Ç—É–ø–µ–Ω: {EDGE_TTS_AVAILABLE}\")\n        print(f\"[TTS] –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ: {self.playback_available}\")\n    \n    def _init_pygame(self):\n        \"\"\"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è pygame mixer\"\"\"\n        if not PYGAME_AVAILABLE:\n            self.playback_available = False\n            return\n            \n        try:\n            pygame.mixer.pre_init(frequency=24000, size=-16, channels=1, buffer=512)\n            pygame.mixer.init()\n            self.playback_available = True\n            print(\"[TTS] Pygame mixer –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω\")\n        except Exception as e:\n            self.playback_available = False\n            print(f\"[TTS] –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ (–Ω–µ—Ç –∞—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤): {e}\")\n            print(\"[TTS] –°–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ\")\n    \n    def _get_rate_string(self, emotion: str = 'neutral') -> str:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–ª—è SSML\"\"\"\n        emotion_rate = self.EMOTION_STYLES.get(emotion, {}).get('rate', '+0%')\n        base = int(emotion_rate.replace('%', '').replace('+', ''))\n        total = self.base_rate + base\n        sign = '+' if total >= 0 else ''\n        return f\"{sign}{total}%\"\n    \n    def _get_pitch_string(self, emotion: str = 'neutral') -> str:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É —Ç–æ–Ω–∞ –¥–ª—è SSML\"\"\"\n        return self.EMOTION_STYLES.get(emotion, {}).get('pitch', '+0Hz')\n    \n    def _get_volume_string(self, emotion: str = 'neutral') -> str:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –¥–ª—è SSML\"\"\"\n        return self.EMOTION_STYLES.get(emotion, {}).get('volume', '+0%')\n    \n    async def _synthesize_async(self, text: str, emotion: str = 'neutral') -> Optional[str]:\n        \"\"\"\n        –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏\n        \n        Returns:\n            str: –ü—É—Ç—å –∫ –≤—Ä–µ–º–µ–Ω–Ω–æ–º—É –∞—É–¥–∏–æ —Ñ–∞–π–ª—É\n        \"\"\"\n        if not EDGE_TTS_AVAILABLE:\n            print(\"[TTS] Edge TTS –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω\")\n            return None\n        \n        try:\n            rate = self._get_rate_string(emotion)\n            pitch = self._get_pitch_string(emotion)\n            volume = self._get_volume_string(emotion)\n            \n            communicate = edge_tts.Communicate(\n                text=text,\n                voice=self.voice_name,\n                rate=rate,\n                pitch=pitch,\n                volume=volume\n            )\n            \n            with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False, prefix='iris_tts_') as tmp:\n                output_path = tmp.name\n            \n            await communicate.save(output_path)\n            \n            return output_path\n            \n        except Exception as e:\n            print(f\"[TTS] –û—à–∏–±–∫–∞ —Å–∏–Ω—Ç–µ–∑–∞: {e}\")\n            return None\n    \n    def _play_audio(self, file_path: str) -> bool:\n        \"\"\"–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞\"\"\"\n        if not self.playback_available:\n            print(f\"[TTS] –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ (–Ω–µ—Ç –∞—É–¥–∏–æ): {os.path.basename(file_path)}\")\n            return False\n        \n        if not os.path.exists(file_path):\n            print(f\"[TTS] –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {file_path}\")\n            return False\n        \n        try:\n            if not pygame.mixer.get_init():\n                self._init_pygame()\n                if not self.playback_available:\n                    return False\n            \n            pygame.mixer.music.load(file_path)\n            pygame.mixer.music.set_volume(self.base_volume)\n            pygame.mixer.music.play()\n            \n            while pygame.mixer.music.get_busy() and not self.stop_flag:\n                time.sleep(0.05)\n            \n            pygame.mixer.music.stop()\n            return True\n            \n        except Exception as e:\n            print(f\"[TTS] –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: {e}\")\n            return False\n        finally:\n            try:\n                os.unlink(file_path)\n            except:\n                pass\n    \n    def _speech_worker(self):\n        \"\"\"–†–∞–±–æ—á–∏–π –ø–æ—Ç–æ–∫ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏ —Ä–µ—á–∏\"\"\"\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        \n        while not self.stop_flag:\n            try:\n                item = self.speech_queue.get(timeout=0.5)\n                if item is None:\n                    continue\n                \n                text, emotion, priority, callback = item\n                \n                self.is_speaking = True\n                self.current_emotion = emotion\n                \n                print(f\"[TTS] –°–∏–Ω—Ç–µ–∑–∏—Ä—É—é: '{text[:50]}...' —ç–º–æ—Ü–∏—è: {emotion}\")\n                \n                audio_file = loop.run_until_complete(\n                    self._synthesize_async(text, emotion)\n                )\n                \n                if audio_file:\n                    success = self._play_audio(audio_file)\n                    if callback:\n                        callback(success)\n                \n                self.is_speaking = False\n                self.speech_queue.task_done()\n                \n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f\"[TTS] –û—à–∏–±–∫–∞ –≤ —Ä–∞–±–æ—á–µ–º –ø–æ—Ç–æ–∫–µ: {e}\")\n                self.is_speaking = False\n        \n        loop.close()\n    \n    def speak(self, \n              text: str, \n              emotion: str = 'neutral',\n              priority: bool = False,\n              callback: Optional[Callable] = None):\n        \"\"\"\n        –û–∑–≤—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π —ç–º–æ—Ü–∏–µ–π\n        \n        Args:\n            text: –¢–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è\n            emotion: –≠–º–æ—Ü–∏—è (neutral, excited, happy, sad, supportive, sarcastic, tense, gentle)\n            priority: –ï—Å–ª–∏ True, –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ä–µ—á—å\n            callback: –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –ø–æ—Å–ª–µ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è\n        \"\"\"\n        if not text or not text.strip():\n            return\n        \n        text = text.strip()\n        \n        if priority and self.is_speaking:\n            self.interrupt()\n        \n        self.speech_queue.put((text, emotion, priority, callback))\n        print(f\"[TTS] –í –æ—á–µ—Ä–µ–¥—å: '{text[:30]}...' (—ç–º–æ—Ü–∏—è: {emotion})\")\n    \n    def speak_with_pauses(self, text: str, emotion: str = 'neutral'):\n        \"\"\"–û–∑–≤—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –ø–∞—É–∑–∞–º–∏ –º–µ–∂–¥—É –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º–∏\"\"\"\n        sentences = text.replace('!', '.').replace('?', '.').split('.')\n        sentences = [s.strip() for s in sentences if s.strip()]\n        \n        for sentence in sentences:\n            self.speak(sentence, emotion)\n    \n    def interrupt(self):\n        \"\"\"–ü—Ä–µ—Ä–≤–∞—Ç—å —Ç–µ–∫—É—â—É—é —Ä–µ—á—å\"\"\"\n        if PYGAME_AVAILABLE and pygame.mixer.get_init():\n            pygame.mixer.music.stop()\n        \n        while not self.speech_queue.empty():\n            try:\n                self.speech_queue.get_nowait()\n                self.speech_queue.task_done()\n            except:\n                break\n    \n    def is_busy(self) -> bool:\n        \"\"\"–ü—Ä–æ–≤–µ—Ä–∫–∞, –≥–æ–≤–æ—Ä–∏—Ç –ª–∏ —Å–µ–π—á–∞—Å\"\"\"\n        return self.is_speaking or not self.speech_queue.empty()\n    \n    def set_voice(self, voice: str):\n        \"\"\"–°–º–µ–Ω–∏—Ç—å –≥–æ–ª–æ—Å\"\"\"\n        self.voice_name = self.VOICES.get(voice, voice)\n        print(f\"[TTS] –ì–æ–ª–æ—Å –∏–∑–º–µ–Ω—ë–Ω –Ω–∞: {self.voice_name}\")\n    \n    def set_rate(self, rate: int):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å —Ä–µ—á–∏ (-50 –¥–æ +50)\"\"\"\n        self.base_rate = max(-50, min(50, rate))\n    \n    def set_volume(self, volume: float):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä–æ–º–∫–æ—Å—Ç—å (0.0-1.0)\"\"\"\n        self.base_volume = max(0.0, min(1.0, volume))\n    \n    def stop(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–≤–∏–∂–æ–∫\"\"\"\n        self.stop_flag = True\n        self.interrupt()\n        \n        if PYGAME_AVAILABLE and pygame.mixer.get_init():\n            pygame.mixer.quit()\n        \n        print(\"[TTS] –î–≤–∏–∂–æ–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\")\n    \n    @staticmethod\n    async def list_voices(lang_filter: str = 'ru') -> list:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥–æ–ª–æ—Å–æ–≤\"\"\"\n        if not EDGE_TTS_AVAILABLE:\n            return []\n        \n        try:\n            voices = await edge_tts.list_voices()\n            if lang_filter:\n                voices = [v for v in voices if lang_filter.lower() in v['Locale'].lower()]\n            return voices\n        except Exception as e:\n            print(f\"[TTS] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥–æ–ª–æ—Å–æ–≤: {e}\")\n            return []\n\n\ndef synthesize_and_play(text: str, lang: str = 'ru', cleanup: bool = True) -> bool:\n    \"\"\"\n    –ë—ã—Å—Ç—Ä–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∏–Ω—Ç–µ–∑–∞ –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è\n    –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API\n    \"\"\"\n    engine = TTSEngine(voice='ru_female_soft')\n    engine.speak(text, emotion='neutral')\n    \n    while engine.is_busy():\n        time.sleep(0.1)\n    \n    engine.stop()\n    return True\n\n\nif __name__ == \"__main__\":\n    print(\"=== –¢–µ—Å—Ç TTS Engine ===\")\n    \n    tts = TTSEngine(voice='ru_female_soft')\n    \n    print(\"\\n–¢–µ—Å—Ç 1: –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π –≥–æ–ª–æ—Å\")\n    tts.speak(\"–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, —Ç–≤–æ–π –≥–æ–ª–æ—Å–æ–≤–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç.\", emotion='neutral')\n    \n    while tts.is_busy():\n        time.sleep(0.1)\n    \n    print(\"\\n–¢–µ—Å—Ç 2: –í–∑–≤–æ–ª–Ω–æ–≤–∞–Ω–Ω—ã–π –≥–æ–ª–æ—Å\")\n    tts.speak(\"–£—Ö —Ç—ã! –û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª! –ö—Ä–∞—Å–∞–≤—á–∏–∫!\", emotion='excited')\n    \n    while tts.is_busy():\n        time.sleep(0.1)\n    \n    print(\"\\n–¢–µ—Å—Ç 3: –ù–µ–∂–Ω—ã–π –≥–æ–ª–æ—Å\")\n    tts.speak(\"–ù–µ –ø–µ—Ä–µ–∂–∏–≤–∞–π, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–ª—É—á–∏—Ç—Å—è.\", emotion='gentle')\n    \n    while tts.is_busy():\n        time.sleep(0.1)\n    \n    tts.stop()\n    print(\"\\n=== –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω ===\")\n","path":null,"size_bytes":13274,"size_tokens":null},"src/utils/__init__.py":{"content":"\"\"\"\nIris Utils - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã\n\"\"\"\n\ndef synthesize_and_play(text: str, lang: str = 'ru', cleanup: bool = True) -> bool:\n    \"\"\"\n    –ë—ã—Å—Ç—Ä–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∏–Ω—Ç–µ–∑–∞ –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è\n    –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API\n    \"\"\"\n    from src.tts_engine import TTSEngine\n    import time\n    \n    engine = TTSEngine(voice='ru_female_soft')\n    engine.speak(text, emotion='neutral')\n    \n    while engine.is_busy():\n        time.sleep(0.1)\n    \n    engine.stop()\n    return True\n\n__all__ = ['synthesize_and_play']\n","path":null,"size_bytes":593,"size_tokens":null},"main.py":{"content":"\"\"\"\nIRIS - AI Stream Companion\n–ì–æ–ª–æ—Å–æ–≤–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤ —Å CS2 –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π\n–ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ (Edge TTS, Vosk, Groq)\n\"\"\"\nimport os\nimport sys\nimport time\nimport threading\nimport signal\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nfrom src.tts_engine import TTSEngine\nfrom src.voice_input import VoiceInput\nfrom src.cs2_gsi import CS2GameStateIntegration, GameEvent\nfrom src.streamelements_client import StreamElementsClient, StreamEvent\nfrom src.iris_brain import IrisBrain\nfrom src.windows_audio import WindowsAudioController\nfrom src.achievements import AchievementSystem, Achievement\n\n\nclass IrisAssistant:\n    \"\"\"\n    –ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –ò—Ä–∏—Å - AI –∫–æ–º–ø–∞–Ω—å–æ–Ω–∞ –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤\n    \"\"\"\n    \n    def __init__(self):\n        print(\"=\" * 60)\n        print(\"üå∏ –ó–∞–ø—É—Å–∫ –ò—Ä–∏—Å - AI Stream Companion\")\n        print(\"=\" * 60)\n        print()\n\n        self.CONFIG = {\n            \"cs2_gsi_port\": 3000,\n            \"voice_wake_word\": \"–∏—Ä–∏—Å\",\n            \"voice_sensitivity\": 0.8,\n            \"tts_voice\": \"ru_female_soft\",\n            \"tts_rate\": 0,\n            \"tts_volume\": 0.9,\n        }\n        \n        self.is_running = False\n\n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TTS (–Ω–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å)...\")\n        self.tts = TTSEngine(\n            voice=self.CONFIG[\"tts_voice\"],\n            rate=self.CONFIG[\"tts_rate\"],\n            volume=self.CONFIG[\"tts_volume\"]\n        )\n\n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è AI –º–æ–∑–≥–∞...\")\n        self.iris_brain = IrisBrain()\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CS2 Game State Integration...\")\n        self.cs2_gsi = CS2GameStateIntegration(\n            port=self.CONFIG[\"cs2_gsi_port\"],\n            event_callback=self._on_cs2_event\n        )\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞...\")\n        self.audio_controller = WindowsAudioController()\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...\")\n        self.voice_input = VoiceInput(\n            wake_word=self.CONFIG[\"voice_wake_word\"],\n            sensitivity=self.CONFIG[\"voice_sensitivity\"]\n        )\n        self.voice_input.set_command_callback(self.process_voice_command)\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π...\")\n        self.achievements = AchievementSystem(\n            achievement_callback=self._on_achievement\n        )\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è StreamElements –∫–ª–∏–µ–Ω—Ç–∞...\")\n        self.stream_elements = StreamElementsClient(\n            event_callback=self._on_stream_event\n        )\n        \n        print()\n        print(\"[IRIS] ‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã\")\n        \n    def _on_wake_word(self):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è wake word\"\"\"\n        print(\"[IRIS] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω!\")\n        self.tts.speak(\"–î–∞?\", emotion='neutral', priority=True)\n        \n    def process_voice_command(self, command: str):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥\"\"\"\n        print(f\"[IRIS] üí¨ –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞: '{command}'\")\n        \n        if not command or command.strip() == \"\":\n            response = \"–î–∞, —è –∑–¥–µ—Å—å! –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?\"\n            self.tts.speak(response, emotion='gentle')\n            return\n        \n        command_lower = command.lower().strip()\n        \n        audio_keywords = ['–≥—Ä–æ–º–∫–æ—Å—Ç—å', '—Ç–∏—à–µ', '–≥—Ä–æ–º—á–µ', '–≤—ã–∫–ª—é—á–∏', '–≤–∫–ª—é—á–∏', '–º—É–∑—ã–∫', '–∑–≤—É–∫', 'mute']\n        if any(kw in command_lower for kw in audio_keywords):\n            response = self.audio_controller.execute_voice_command(command)\n            self.tts.speak(response, emotion='neutral')\n            return\n        \n        if '–ø—Ä–∏–≤–µ—Ç' in command_lower:\n            response = \"–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, —Ç–≤–æ—è AI-–ø–æ–¥—Ä—É–≥–∞ –Ω–∞ —Å—Ç—Ä–∏–º–µ!\"\n            self.tts.speak(response, emotion='happy')\n            return\n            \n        if '–∫–∞–∫ –¥–µ–ª–∞' in command_lower or '–∫–∞–∫ —Ç—ã' in command_lower:\n            response = \"–û—Ç–ª–∏—á–Ω–æ! –ì–æ—Ç–æ–≤–∞ —Å–ª–µ–¥–∏—Ç—å –∑–∞ –∏–≥—Ä–æ–π –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Ç–µ–±—è!\"\n            self.tts.speak(response, emotion='happy')\n            return\n            \n        if '—Ç–µ—Å—Ç' in command_lower:\n            response = \"–¢–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω! –ì–æ–ª–æ—Å–æ–≤–æ–π –ø–æ–º–æ—â–Ω–∏–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ—Ç–ª–∏—á–Ω–æ.\"\n            self.tts.speak(response, emotion='neutral')\n            return\n            \n        if '—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞' in command_lower or '—Å—Ç–∞—Ç–∞' in command_lower:\n            stats = self.achievements.get_stats_summary()\n            self.tts.speak(f\"–í–æ—Ç —Ç–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats[:200]}\", emotion='neutral')\n            return\n            \n        if '–¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è' in command_lower:\n            progress = self.achievements.get_progress_summary()\n            self.tts.speak(progress, emotion='neutral')\n            return\n            \n        if command_lower in ['—Å—Ç–æ–ø', '–æ—Å—Ç–∞–Ω–æ–≤–∏—Å—å', '–≤—ã—Ö–æ–¥', '–ø–æ–∫–∞']:\n            response = \"–î–æ –≤—Å—Ç—Ä–µ—á–∏! –ë—ã–ª–æ –≤–µ—Å–µ–ª–æ!\"\n            self.tts.speak(response, emotion='gentle')\n            time.sleep(2)\n            self.stop()\n            return\n        \n        try:\n            response = self.iris_brain.chat_with_user(command)\n            if response:\n                self.tts.speak(response, emotion='neutral')\n            else:\n                self.tts.speak(f\"–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ! –¢—ã —Å–∫–∞–∑–∞–ª: {command}\", emotion='neutral')\n        except Exception as e:\n            print(f\"[IRIS] –û—à–∏–±–∫–∞ AI: {e}\")\n            self.tts.speak(\"–•–º, –¥–∞–π –º–Ω–µ —Å–µ–∫—É–Ω–¥—É –ø–æ–¥—É–º–∞—Ç—å...\", emotion='neutral')\n            \n    def _on_cs2_event(self, event: GameEvent):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π CS2\"\"\"\n        print(f\"[CS2] –°–æ–±—ã—Ç–∏–µ: {event.event_type}\")\n        \n        self.iris_brain.update_context(\n            map_name=self.cs2_gsi.map.name,\n            ct_score=self.cs2_gsi.map.ct_score,\n            t_score=self.cs2_gsi.map.t_score,\n            player_stats=self.cs2_gsi.get_player_stats(),\n            event={'type': event.event_type, 'data': event.data}\n        )\n        \n        response = None\n        emotion = 'neutral'\n        \n        if event.event_type == 'ace':\n            self.achievements.record_kill(round_kills=5)\n            response = self.iris_brain.react_to_kill(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type in ['kill', 'double_kill', 'triple_kill', 'quadra_kill']:\n            is_headshot = event.data.get('headshot', False)\n            round_kills = event.data.get('round_kills', 1)\n            self.achievements.record_kill(headshot=is_headshot, round_kills=round_kills)\n            response = self.iris_brain.react_to_kill(event.data)\n            emotion = 'excited' if round_kills >= 3 else 'happy'\n            \n        elif event.event_type == 'death':\n            self.achievements.record_death()\n            response = self.iris_brain.react_to_death(event.data)\n            emotion = 'supportive'\n            \n        elif event.event_type == 'round_end':\n            won = event.data.get('won', False)\n            clutch = event.data.get('clutch_win', False)\n            if won:\n                self.achievements.record_round_win(clutch=clutch)\n            else:\n                self.achievements.record_round_loss()\n            response = self.iris_brain.react_to_round_end(event.data)\n            emotion = 'excited' if won else 'supportive'\n            \n        elif event.event_type == 'low_health':\n            health = event.data.get('current_health', 100)\n            self.achievements.record_low_health_survive(health)\n            \n        elif event.event_type in ['bomb_planted', 'bomb_defused', 'bomb_exploded']:\n            if event.event_type == 'bomb_defused' and event.data.get('ninja_defuse'):\n                self.achievements.record_ninja_defuse()\n            response = self.iris_brain.react_to_bomb_event(event.event_type, event.data)\n            emotion = 'tense' if event.event_type == 'bomb_planted' else 'excited'\n            \n        elif event.event_type == 'match_end':\n            won = event.data.get('won', False)\n            self.achievements.record_match_end(won=won)\n            \n        if response:\n            self.tts.speak(response, emotion=emotion)\n            \n    def _on_stream_event(self, event: StreamEvent):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π —Å—Ç—Ä–∏–º–∞\"\"\"\n        print(f\"[STREAM] –°–æ–±—ã—Ç–∏–µ: {event.event_type}\")\n        \n        response = None\n        emotion = 'neutral'\n        \n        if event.event_type == 'donation':\n            amount = event.data.get('amount', 0)\n            currency = event.data.get('currency', 'RUB')\n            self.achievements.record_donation(amount, currency)\n            response = self.iris_brain.react_to_donation(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type == 'subscription':\n            self.achievements.record_subscription()\n            response = self.iris_brain.react_to_subscription(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type == 'raid':\n            viewers = event.data.get('viewers', 0)\n            self.achievements.record_raid(viewers)\n            response = self.iris_brain.react_to_raid(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type == 'chat_message':\n            self.achievements.record_chat_message()\n            response = self.iris_brain.react_to_chat_message(event.data)\n            \n        elif event.event_type == 'follow':\n            pass\n            \n        if response:\n            self.tts.speak(response, emotion=emotion)\n            \n    def _on_achievement(self, achievement: Achievement):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π\"\"\"\n        message = f\"–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ! {achievement.icon} {achievement.name}!\"\n        self.tts.speak(message, emotion='excited', priority=True)\n        \n    def _random_comment_loop(self):\n        \"\"\"–¶–∏–∫–ª —Å–ª—É—á–∞–π–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤\"\"\"\n        while self.is_running:\n            time.sleep(120)\n            \n            if not self.is_running:\n                break\n                \n            self.achievements.check_time_achievements()\n            \n            if not self.tts.is_busy():\n                comment = self.iris_brain.generate_random_comment()\n                if comment:\n                    self.tts.speak(comment, emotion='neutral')\n                    \n    def start(self):\n        \"\"\"–ó–∞–ø—É—Å–∫ –ò—Ä–∏—Å\"\"\"\n        self.is_running = True\n        \n        print(\"\\n[IRIS] –ó–∞–ø—É—Å–∫ CS2 Game State Integration...\")\n        self.cs2_gsi.start()\n        self.cs2_gsi.save_config_file()\n        \n        jwt_token = os.getenv('STREAMELEMENTS_JWT_TOKEN', '')\n        if jwt_token:\n            print(\"\\n[IRIS] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ StreamElements...\")\n            self.stream_elements.connect()\n        else:\n            print(\"\\n[IRIS] ‚ö†Ô∏è STREAMELEMENTS_JWT_TOKEN –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω - —á–∞—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω\")\n            \n        groq_key = os.getenv('GROQ_API_KEY', '')\n        if not groq_key:\n            print(\"\\n[IRIS] ‚ö†Ô∏è GROQ_API_KEY –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω - AI –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å fallback –æ—Ç–≤–µ—Ç—ã\")\n            \n        print(\"\\n[IRIS] –ó–∞–ø—É—Å–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...\")\n        self.voice_input.start()\n        \n        self.random_comment_thread = threading.Thread(\n            target=self._random_comment_loop,\n            daemon=True\n        )\n        self.random_comment_thread.start()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"üå∏ –ò—Ä–∏—Å —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞!\")\n        print(\"=\" * 60)\n        print()\n        print(\"üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:\")\n        print(\"   üéÆ CS2 Game State Integration (–ø–æ—Ä—Ç 3000)\")\n        print(\"   üí¨ StreamElements —á–∞—Ç –∏ –¥–æ–Ω–∞—Ç—ã\")\n        print(\"   üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (—Å–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å')\")\n        print(\"   üîä –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π\")\n        print(\"   üèÜ –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π\")\n        print()\n        print(\"üé§ –ì–æ–ª–æ—Å: –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π (Edge TTS)\")\n        print(\"üß† AI: Groq LLM (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)\")\n        print()\n        print(\"–ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\")\n        print(\"=\" * 60)\n        \n        self.tts.speak(\"–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, –≥–æ—Ç–æ–≤–∞ –∫ —Å—Ç—Ä–∏–º—É!\", emotion='happy')\n        \n    def stop(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ò—Ä–∏—Å\"\"\"\n        print(\"\\n[IRIS] –û—Å—Ç–∞–Ω–æ–≤–∫–∞...\")\n        self.is_running = False\n        \n        self.achievements.save_stats()\n        \n        self.voice_input.stop()\n        self.stream_elements.disconnect()\n        self.cs2_gsi.stop()\n        self.tts.stop()\n        \n        print(\"[IRIS] –î–æ –≤—Å—Ç—Ä–µ—á–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º —Å—Ç—Ä–∏–º–µ! üå∏\")\n        \n    def run(self):\n        \"\"\"–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª\"\"\"\n        def signal_handler(sig, frame):\n            self.stop()\n            sys.exit(0)\n            \n        signal.signal(signal.SIGINT, signal_handler)\n        signal.signal(signal.SIGTERM, signal_handler)\n        \n        self.start()\n        \n        try:\n            while self.is_running:\n                time.sleep(1)\n        except KeyboardInterrupt:\n            self.stop()\n\n\ndef main():\n    \"\"\"–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞\"\"\"\n    print()\n    print(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\")\n    print(\"‚ïë                                                            ‚ïë\")\n    print(\"‚ïë   üå∏ IRIS - AI Stream Companion                            ‚ïë\")\n    print(\"‚ïë   –ì–æ–ª–æ—Å–æ–≤–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤                         ‚ïë\")\n    print(\"‚ïë                                                            ‚ïë\")\n    print(\"‚ïë   üíú –ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:                      ‚ïë\")\n    print(\"‚ïë      ‚Ä¢ Edge TTS - –Ω–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å                    ‚ïë\")\n    print(\"‚ïë      ‚Ä¢ Vosk - –æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏                   ‚ïë\")\n    print(\"‚ïë      ‚Ä¢ Groq LLM - –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI                           ‚ïë\")\n    print(\"‚ïë                                                            ‚ïë\")\n    print(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\")\n    print()\n    \n    iris = IrisAssistant()\n    iris.run()\n\n\nif __name__ == \"__main__\":\n    main()\n","path":null,"size_bytes":15214,"size_tokens":null},"src/voice_recognition.py":{"content":"import os\nimport time\nimport threading\nimport queue\n\ntry:\n    import speech_recognition as sr\n    SR_AVAILABLE = True\nexcept ImportError:\n    SR_AVAILABLE = False\n    print(\"[VOICE] SpeechRecognition –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\")\n\nPYAUDIO_AVAILABLE = False\ntry:\n    import pyaudio\n    PYAUDIO_AVAILABLE = True\nexcept ImportError:\n    print(\"[VOICE] PyAudio –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - –≥–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –º–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ\")\n\nclass VoiceRecognition:\n    WAKE_WORDS = ['–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∏–∫', '—ç–π –∏—Ä–∏—Å', 'hey iris', '–∏—Ä–∏—Å–∫–∞']\n    \n    def __init__(self, \n                 wake_word_callback=None,\n                 command_callback=None,\n                 language: str = \"ru-RU\"):\n        \n        self.wake_word_callback = wake_word_callback\n        self.command_callback = command_callback\n        self.language = language\n        \n        self.is_listening = False\n        self.conversation_mode = False\n        self.conversation_timeout = 30.0\n        self.last_interaction_time = 0\n        \n        if SR_AVAILABLE and PYAUDIO_AVAILABLE:\n            self.recognizer = sr.Recognizer()\n            self.recognizer.energy_threshold = 300\n            self.recognizer.dynamic_energy_threshold = True\n            self.recognizer.pause_threshold = 0.8\n        else:\n            self.recognizer = None\n            \n        self.listen_thread = None\n            \n    def start_listening(self):\n        if not SR_AVAILABLE or not PYAUDIO_AVAILABLE:\n            print(\"[VOICE] –ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥\")\n            return False\n            \n        self.is_listening = True\n        self.listen_thread = threading.Thread(target=self._listen_loop, daemon=True)\n        self.listen_thread.start()\n        \n        print(\"[VOICE] –°–ª—É—à–∞—é... –°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å' –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏\")\n        return True\n        \n    def stop_listening(self):\n        self.is_listening = False\n        self.conversation_mode = False\n        \n    def _listen_loop(self):\n        try:\n            with sr.Microphone() as source:\n                print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...\")\n                self.recognizer.adjust_for_ambient_noise(source, duration=1)\n                print(\"[VOICE] –ì–æ—Ç–æ–≤ –∫ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—é!\")\n                \n                while self.is_listening:\n                    try:\n                        audio = self.recognizer.listen(source, timeout=5, phrase_time_limit=10)\n                        \n                        threading.Thread(\n                            target=self._process_audio, \n                            args=(audio,),\n                            daemon=True\n                        ).start()\n                        \n                    except sr.WaitTimeoutError:\n                        if self.conversation_mode:\n                            if time.time() - self.last_interaction_time > self.conversation_timeout:\n                                self.conversation_mode = False\n                                print(\"[VOICE] –†–µ–∂–∏–º —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∑–∞–≤–µ—Ä—à—ë–Ω –ø–æ —Ç–∞–π–º–∞—É—Ç—É\")\n                        continue\n                    except Exception as e:\n                        print(f\"[VOICE] –û—à–∏–±–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è: {e}\")\n                        continue\n                        \n        except Exception as e:\n            print(f\"[VOICE] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}\")\n            \n    def _process_audio(self, audio):\n        try:\n            text = self.recognizer.recognize_google(audio, language=self.language)\n            text = text.lower().strip()\n            \n            if not text:\n                return\n                \n            print(f\"[VOICE] –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {text}\")\n            self._handle_transcription(text)\n            \n        except sr.UnknownValueError:\n            pass\n        except sr.RequestError as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: {e}\")\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}\")\n            \n    def _handle_transcription(self, text: str):\n        if self.conversation_mode:\n            self.last_interaction_time = time.time()\n            if self.command_callback:\n                self.command_callback(text, is_conversation=True)\n            return\n            \n        for wake_word in self.WAKE_WORDS:\n            if wake_word in text:\n                self.conversation_mode = True\n                self.last_interaction_time = time.time()\n                \n                command = text\n                for ww in self.WAKE_WORDS:\n                    command = command.replace(ww, '').strip()\n                    \n                print(f\"[VOICE] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω! –ö–æ–º–∞–Ω–¥–∞: {command}\")\n                \n                if self.wake_word_callback:\n                    self.wake_word_callback()\n                    \n                if command and self.command_callback:\n                    self.command_callback(command, is_conversation=False)\n                elif self.command_callback:\n                    self.command_callback(\"\", is_conversation=False)\n                    \n                return\n                \n    def set_conversation_mode(self, enabled: bool):\n        self.conversation_mode = enabled\n        if enabled:\n            self.last_interaction_time = time.time()\n            \n    def is_in_conversation(self) -> bool:\n        return self.conversation_mode\n        \n\nclass TextInputFallback:\n    def __init__(self, command_callback=None):\n        self.command_callback = command_callback\n        self.is_listening = False\n        self.input_thread = None\n        \n    def start_listening(self):\n        self.is_listening = True\n        self.input_thread = threading.Thread(target=self._input_loop, daemon=True)\n        self.input_thread.start()\n        print(\"[TEXT] –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω. –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:\")\n        return True\n        \n    def stop_listening(self):\n        self.is_listening = False\n        \n    def _input_loop(self):\n        while self.is_listening:\n            try:\n                user_input = input(\"> \").strip()\n                if user_input and self.command_callback:\n                    self.command_callback(user_input, is_conversation=True)\n            except EOFError:\n                break\n            except Exception as e:\n                print(f\"[TEXT] –û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞: {e}\")\n                time.sleep(1)\n","path":null,"size_bytes":6642,"size_tokens":null},"src/voice_input.py":{"content":"\"\"\"\nIris Voice Input - –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –≥–æ–ª–æ—Å–∞ —Å Vosk\n–û—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –≤—ã—Å–æ–∫–æ–π —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∫ wake-word '–ò—Ä–∏—Å'\n\"\"\"\nimport threading\nimport time\nimport queue\nimport os\nimport json\nimport logging\nfrom typing import Optional, Callable, List\nfrom pathlib import Path\n\ntry:\n    from vosk import Model, KaldiRecognizer, SetLogLevel\n    SetLogLevel(-1)\n    VOSK_AVAILABLE = True\nexcept ImportError:\n    VOSK_AVAILABLE = False\n    print(\"[VOICE] Vosk –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install vosk\")\n\nSOUNDDEVICE_AVAILABLE = False\nsd = None\nnp = None\ntry:\n    import numpy as np\n    import sounddevice as sd\n    sd.query_devices()\n    SOUNDDEVICE_AVAILABLE = True\nexcept (ImportError, OSError, Exception) as e:\n    SOUNDDEVICE_AVAILABLE = False\n    sd = None\n    try:\n        import numpy as np\n    except ImportError:\n        np = None\n    print(f\"[VOICE] sounddevice –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}\")\n\ntry:\n    import speech_recognition as sr\n    SR_AVAILABLE = True\nexcept ImportError:\n    SR_AVAILABLE = False\n    print(\"[VOICE] speech_recognition –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install SpeechRecognition\")\n\nlogger = logging.getLogger('VoiceInput')\n\n\nclass VoiceInput:\n    \"\"\"\n    –£–ª—É—á—à–µ–Ω–Ω—ã–π –º–æ–¥—É–ª—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞\n    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç Vosk (–æ—Ñ–ª–∞–π–Ω) –∏ Google Speech Recognition (–æ–Ω–ª–∞–π–Ω)\n    \"\"\"\n    \n    WAKE_WORD_VARIANTS = [\n        '–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏', '–∏—Ä–∏—Å–∫–∞', '–∏—Ä–∏—Å—Å', '–∏—Ä–∏—Å–∞',\n        '–∞–π—Ä–∏—Å', '–∞—Ä–∏—Å', '–∏—Ä–∏—à', '–∏—Ä–∏—Å—å', '—Ä–∏—Å', '—ç—Ä–∏—Å'\n    ]\n    \n    def __init__(self, \n                 wake_word: str = \"–∏—Ä–∏—Å\",\n                 sensitivity: float = 0.7,\n                 use_vosk: bool = True,\n                 vosk_model_path: str = None,\n                 sample_rate: int = 16000):\n        \"\"\"\n        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞\n        \n        Args:\n            wake_word: –ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏\n            sensitivity: –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (0.0-1.0)\n            use_vosk: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Vosk –¥–ª—è –æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è\n            vosk_model_path: –ü—É—Ç—å –∫ –º–æ–¥–µ–ª–∏ Vosk\n            sample_rate: –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏\n        \"\"\"\n        self.wake_word = wake_word.lower()\n        self.sensitivity = max(0.1, min(1.0, sensitivity))\n        self.sample_rate = sample_rate\n        self.use_vosk = use_vosk and VOSK_AVAILABLE\n        \n        self.command_queue = queue.Queue()\n        self.is_listening = False\n        self.is_calibrating = False\n        self.listener_thread: Optional[threading.Thread] = None\n        self.command_callback: Optional[Callable] = None\n        \n        self.recognition_history: List[str] = []\n        self.max_history = 50\n        self.wake_word_detected_count = 0\n        self.total_phrases_count = 0\n        \n        self.vosk_model = None\n        self.recognizer = None\n        \n        self.energy_threshold = 1500 + (3500 * (1 - sensitivity))\n        self.silence_threshold = 0.3\n        self.phrase_timeout = 3.0\n        \n        if self.use_vosk:\n            self._init_vosk(vosk_model_path)\n        \n        if SR_AVAILABLE:\n            self._init_speech_recognition()\n        \n        print(f\"[VOICE] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å wake word: '{self.wake_word}'\")\n        print(f\"[VOICE] –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {self.sensitivity}\")\n        print(f\"[VOICE] Vosk –¥–æ—Å—Ç—É–ø–µ–Ω: {VOSK_AVAILABLE}\")\n        print(f\"[VOICE] SoundDevice –¥–æ—Å—Ç—É–ø–µ–Ω: {SOUNDDEVICE_AVAILABLE}\")\n    \n    def _init_vosk(self, model_path: str = None):\n        \"\"\"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Vosk –º–æ–¥–µ–ª–∏\"\"\"\n        if not VOSK_AVAILABLE:\n            return\n        \n        model_paths = [\n            model_path,\n            'models/vosk-model-small-ru',\n            'vosk-model-small-ru-0.22',\n            os.path.expanduser('~/.vosk/vosk-model-small-ru'),\n            '/usr/share/vosk/vosk-model-small-ru',\n        ]\n        \n        for path in model_paths:\n            if path and os.path.exists(path):\n                try:\n                    self.vosk_model = Model(path)\n                    self.recognizer = KaldiRecognizer(self.vosk_model, self.sample_rate)\n                    self.recognizer.SetWords(True)\n                    print(f\"[VOICE] Vosk –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {path}\")\n                    return\n                except Exception as e:\n                    print(f\"[VOICE] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ {path}: {e}\")\n        \n        print(\"[VOICE] Vosk –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–Ω–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ.\")\n        self.use_vosk = False\n    \n    def _init_speech_recognition(self):\n        \"\"\"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è speech_recognition\"\"\"\n        if not SR_AVAILABLE:\n            return\n        \n        self.sr_recognizer = sr.Recognizer()\n        self.sr_recognizer.pause_threshold = 0.5\n        self.sr_recognizer.phrase_threshold = 0.3\n        self.sr_recognizer.non_speaking_duration = 0.3\n        self.sr_recognizer.energy_threshold = self.energy_threshold\n        self.sr_recognizer.dynamic_energy_threshold = False\n    \n    def _check_wake_word(self, text: str) -> bool:\n        \"\"\"\n        –£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ wake word —Å fuzzy matching\n        \n        Args:\n            text: –†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç\n            \n        Returns:\n            bool: True –µ—Å–ª–∏ wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω\n        \"\"\"\n        if not text:\n            return False\n        \n        text_lower = text.lower().strip()\n        words = text_lower.split()\n        \n        for variant in self.WAKE_WORD_VARIANTS:\n            if variant in text_lower:\n                logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (—Ç–æ—á–Ω–æ–µ): '{variant}' –≤ '{text}'\")\n                return True\n        \n        for word in words:\n            if len(word) >= 3:\n                for variant in self.WAKE_WORD_VARIANTS:\n                    if word.startswith(variant[:3]) or variant.startswith(word[:3]):\n                        logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (—á–∞—Å—Ç–∏—á–Ω–æ–µ): '{word}' ~ '{variant}'\")\n                        return True\n        \n        if text_lower.startswith(self.wake_word[:2]):\n            logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (–Ω–∞—á–∞–ª–æ): '{text_lower[:5]}...'\")\n            return True\n        \n        wake_chars = set(self.wake_word)\n        for word in words:\n            if len(word) >= 3:\n                word_chars = set(word)\n                overlap = len(wake_chars & word_chars)\n                if overlap >= len(wake_chars) * 0.7:\n                    logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (—Å–∏–º–≤–æ–ª—ã): '{word}'\")\n                    return True\n        \n        return False\n    \n    def _extract_command(self, text: str) -> str:\n        \"\"\"\n        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞ –ø–æ—Å–ª–µ wake word\n        \n        Args:\n            text: –†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç\n            \n        Returns:\n            str: –ö–æ–º–∞–Ω–¥–∞ –∏–ª–∏ –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞\n        \"\"\"\n        if not text:\n            return \"\"\n        \n        text_lower = text.lower().strip()\n        \n        for variant in sorted(self.WAKE_WORD_VARIANTS, key=len, reverse=True):\n            if variant in text_lower:\n                parts = text_lower.split(variant, 1)\n                if len(parts) > 1:\n                    return parts[1].strip()\n        \n        if text_lower.startswith(self.wake_word):\n            return text_lower[len(self.wake_word):].strip()\n        \n        return text_lower\n    \n    def _recognize_with_vosk(self, audio_data: bytes) -> Optional[str]:\n        \"\"\"–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Vosk\"\"\"\n        if not self.recognizer:\n            return None\n        \n        try:\n            if self.recognizer.AcceptWaveform(audio_data):\n                result = json.loads(self.recognizer.Result())\n                return result.get('text', '')\n            else:\n                partial = json.loads(self.recognizer.PartialResult())\n                return partial.get('partial', '')\n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ Vosk: {e}\")\n            return None\n    \n    def _recognize_with_google(self, audio) -> Optional[str]:\n        \"\"\"–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Google Speech API\"\"\"\n        if not SR_AVAILABLE:\n            return None\n        \n        try:\n            text = self.sr_recognizer.recognize_google(audio, language=\"ru-RU\")\n            return text\n        except sr.UnknownValueError:\n            return None\n        except sr.RequestError as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ Google Speech: {e}\")\n            return None\n    \n    def _process_recognition(self, text: str):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞\"\"\"\n        if not text or len(text.strip()) < 2:\n            return\n        \n        self.total_phrases_count += 1\n        self.recognition_history.append(text)\n        if len(self.recognition_history) > self.max_history:\n            self.recognition_history.pop(0)\n        \n        print(f\"[VOICE] –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: '{text}'\")\n        \n        if self._check_wake_word(text):\n            self.wake_word_detected_count += 1\n            print(f\"[VOICE] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω!\")\n            \n            command = self._extract_command(text)\n            print(f\"[VOICE] –ö–æ–º–∞–Ω–¥–∞: '{command}'\")\n            \n            self.command_queue.put(command)\n            \n            if self.command_callback:\n                try:\n                    self.command_callback(command)\n                except Exception as e:\n                    logger.error(f\"–û—à–∏–±–∫–∞ callback: {e}\")\n        \n        elif text.lower() in [\"—Å—Ç–æ–ø\", \"–æ—Å—Ç–∞–Ω–æ–≤–∏—Å—å\", \"–≤—ã—Ö–æ–¥\", \"stop\", \"exit\"]:\n            print(\"[VOICE] –ö–æ–º–∞–Ω–¥–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\")\n            self.command_queue.put(\"—Å—Ç–æ–ø\")\n    \n    def _listen_loop_vosk(self):\n        \"\"\"–¶–∏–∫–ª –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è —Å Vosk –∏ sounddevice\"\"\"\n        if not SOUNDDEVICE_AVAILABLE or sd is None:\n            print(\"[VOICE] sounddevice –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ Google Speech...\")\n            self._listen_loop_sr()\n            return\n        \n        print(f\"[VOICE] –°–ª—É—à–∞—é —Å Vosk... (–°–∫–∞–∂–∏—Ç–µ '{self.wake_word}')\")\n        \n        def audio_callback(indata, frames, time_info, status):\n            if status:\n                logger.warning(f\"Audio status: {status}\")\n            \n            audio_bytes = (indata * 32767).astype(np.int16).tobytes()\n            \n            text = self._recognize_with_vosk(audio_bytes)\n            if text:\n                self._process_recognition(text)\n        \n        try:\n            with sd.InputStream(\n                samplerate=self.sample_rate,\n                channels=1,\n                dtype='float32',\n                blocksize=int(self.sample_rate * 0.5),\n                callback=audio_callback\n            ):\n                while self.is_listening:\n                    time.sleep(0.1)\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –ø–æ—Ç–æ–∫–∞ –∞—É–¥–∏–æ: {e}\")\n            print(\"[VOICE] –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ Google Speech –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤...\")\n            self._listen_loop_sr()\n    \n    def _listen_loop_sr(self):\n        \"\"\"–¶–∏–∫–ª –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è —Å speech_recognition\"\"\"\n        if not SR_AVAILABLE:\n            print(\"[VOICE] speech_recognition –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω\")\n            print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –æ—Ç–∫–ª—é—á–µ–Ω - –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤\")\n            self.is_listening = False\n            return\n        \n        print(f\"[VOICE] –°–ª—É—à–∞—é —Å Google Speech... (–°–∫–∞–∂–∏—Ç–µ '{self.wake_word}')\")\n        \n        try:\n            with sr.Microphone() as source:\n                print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...\")\n                self.sr_recognizer.adjust_for_ambient_noise(source, duration=1)\n                print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞\")\n                \n                while self.is_listening:\n                    try:\n                        audio = self.sr_recognizer.listen(\n                            source,\n                            timeout=2,\n                            phrase_time_limit=5\n                        )\n                        \n                        text = self._recognize_with_google(audio)\n                        if text:\n                            self._process_recognition(text)\n                        \n                    except sr.WaitTimeoutError:\n                        continue\n                    except Exception as e:\n                        logger.error(f\"–û—à–∏–±–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è: {e}\")\n                        time.sleep(0.5)\n        \n        except OSError as e:\n            print(f\"[VOICE] –ù–µ—Ç –∞—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {e}\")\n            print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –æ—Ç–∫–ª—é—á–µ–Ω - —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∏–∫—Ä–æ—Ñ–æ–Ω\")\n            self.is_listening = False\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: {e}\")\n            self.is_listening = False\n    \n    def calibrate_microphone(self):\n        \"\"\"–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞\"\"\"\n        if self.is_calibrating:\n            return\n        \n        self.is_calibrating = True\n        print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...\")\n        \n        try:\n            if SR_AVAILABLE:\n                with sr.Microphone() as source:\n                    self.sr_recognizer.adjust_for_ambient_noise(source, duration=1)\n                    print(f\"[VOICE] –ü–æ—Ä–æ–≥ —ç–Ω–µ—Ä–≥–∏–∏: {self.sr_recognizer.energy_threshold}\")\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: {e}\")\n        finally:\n            self.is_calibrating = False\n    \n    def start(self):\n        \"\"\"–ó–∞–ø—É—Å–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞\"\"\"\n        if self.is_listening:\n            print(\"[VOICE] –£–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç\")\n            return\n        \n        self.is_listening = True\n        \n        if self.use_vosk and self.vosk_model:\n            self.listener_thread = threading.Thread(\n                target=self._listen_loop_vosk,\n                daemon=True\n            )\n        else:\n            self.listener_thread = threading.Thread(\n                target=self._listen_loop_sr,\n                daemon=True\n            )\n        \n        self.listener_thread.start()\n        print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –∑–∞–ø—É—â–µ–Ω\")\n    \n    def stop(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞\"\"\"\n        self.is_listening = False\n        if self.listener_thread:\n            self.listener_thread.join(timeout=2)\n        print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\")\n    \n    def stop_listening(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è (–∞–ª–∏–∞—Å –¥–ª—è stop)\"\"\"\n        self.stop()\n    \n    def get_command(self) -> Optional[str]:\n        \"\"\"–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–π –∫–æ–º–∞–Ω–¥—ã –∏–∑ –æ—á–µ—Ä–µ–¥–∏\"\"\"\n        try:\n            return self.command_queue.get_nowait()\n        except queue.Empty:\n            return None\n    \n    def set_command_callback(self, callback: Callable):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∫–∞ callback –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥\"\"\"\n        self.command_callback = callback\n    \n    def set_sensitivity(self, sensitivity: float):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (0.0-1.0)\"\"\"\n        self.sensitivity = max(0.1, min(1.0, sensitivity))\n        self.energy_threshold = 1500 + (3500 * (1 - self.sensitivity))\n        \n        if SR_AVAILABLE and hasattr(self, 'sr_recognizer'):\n            self.sr_recognizer.energy_threshold = self.energy_threshold\n        \n        print(f\"[VOICE] –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {self.sensitivity}, –ø–æ—Ä–æ–≥: {self.energy_threshold}\")\n    \n    def get_recognition_stats(self) -> dict:\n        \"\"\"–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è\"\"\"\n        return {\n            \"total_phrases\": self.total_phrases_count,\n            \"wake_detected\": self.wake_word_detected_count,\n            \"detection_rate\": self.wake_word_detected_count / max(1, self.total_phrases_count),\n            \"recent_phrases\": self.recognition_history[-10:],\n            \"sensitivity\": self.sensitivity,\n            \"energy_threshold\": self.energy_threshold\n        }\n\n\nif __name__ == \"__main__\":\n    print(\"=== –¢–µ—Å—Ç Voice Input ===\")\n    \n    def on_command(cmd):\n        print(f\"\\n>>> –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞: '{cmd}'\\n\")\n    \n    voice = VoiceInput(wake_word=\"–∏—Ä–∏—Å\", sensitivity=0.8)\n    voice.set_command_callback(on_command)\n    \n    print(\"\\n–°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å' –∏ –∫–æ–º–∞–Ω–¥—É...\")\n    voice.start()\n    \n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        print(\"\\n–û—Å—Ç–∞–Ω–æ–≤–∫–∞...\")\n        voice.stop()\n        \n        stats = voice.get_recognition_stats()\n        print(f\"\\n–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\")\n        print(f\"  –í—Å–µ–≥–æ —Ñ—Ä–∞–∑: {stats['total_phrases']}\")\n        print(f\"  Wake word: {stats['wake_detected']}\")\n        print(f\"  –¢–æ—á–Ω–æ—Å—Ç—å: {stats['detection_rate']:.1%}\")\n","path":null,"size_bytes":17625,"size_tokens":null},"src/iris_brain.py":{"content":"\"\"\"\nIRIS BRAIN - AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤\n–Ø–¥—Ä–æ –ò–ò-–ª–æ–≥–∏–∫–∏ –¥–ª—è —Ä–µ–∞–∫—Ü–∏–π –Ω–∞ –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å —á–∞—Ç–æ–º\n–í–µ—Ä—Å–∏—è: 2.0\n–ê–≤—Ç–æ—Ä: [–í–∞—à–µ –∏–º—è]\n\"\"\"\n\nimport os\nimport time\nimport random\nimport json\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom collections import deque, defaultdict\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\nfrom groq import Groq\n\n\n# ===================== –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ì–ò–†–û–í–ê–ù–ò–Ø =====================\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('iris_brain.log', encoding='utf-8'),\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger('IrisBrain')\n\n\n# ===================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ =====================\nclass EventType(Enum):\n    \"\"\"–¢–∏–ø—ã –∏–≥—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏\"\"\"\n    KILL = \"kill\"\n    DEATH = \"death\"\n    ROUND_START = \"round_start\"\n    ROUND_END = \"round_end\"\n    BOMB_PLANTED = \"bomb_planted\"\n    BOMB_DEFUSED = \"bomb_defused\"\n    BOMB_EXPLODED = \"bomb_exploded\"\n    MATCH_START = \"match_start\"\n    MATCH_END = \"match_end\"\n    DONATION = \"donation\"\n    SUBSCRIPTION = \"subscription\"\n    RAID = \"raid\"\n    CHAT_MESSAGE = \"chat_message\"\n    COMMAND = \"command\"\n    RANDOM_COMMENT = \"random_comment\"\n\n\nclass Mood(Enum):\n    \"\"\"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ —Ç–æ–Ω–∞\"\"\"\n    NEUTRAL = \"neutral\"\n    HAPPY = \"happy\"\n    EXCITED = \"excited\"\n    SUPPORTIVE = \"supportive\"\n    SARCASTIC = \"sarcastic\"\n    TENSE = \"tense\"\n    FUNNY = \"funny\"\n\n\n@dataclass\nclass ConversationMessage:\n    \"\"\"–°–æ–æ–±—â–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏–∏ –¥–∏–∞–ª–æ–≥–∞\"\"\"\n    role: str  # \"system\", \"user\", \"assistant\"\n    content: str\n    timestamp: float\n    tokens: int = 0\n    \n    def to_dict(self) -> Dict:\n        \"\"\"–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è API\"\"\"\n        return {\"role\": self.role, \"content\": self.content}\n\n\n@dataclass\nclass GameState:\n    \"\"\"–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã\"\"\"\n    map_name: str = \"\"\n    game_mode: str = \"competitive\"\n    score_ct: int = 0\n    score_t: int = 0\n    round_time: int = 0\n    bomb_planted: bool = False\n    players_alive_ct: int = 5\n    players_alive_t: int = 5\n\n\n@dataclass  \nclass PlayerStats:\n    \"\"\"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞ (—Å—Ç—Ä–∏–º–µ—Ä–∞)\"\"\"\n    kills: int = 0\n    deaths: int = 0\n    assists: int = 0\n    mvps: int = 0\n    score: int = 0\n    adr: float = 0.0  # Average Damage per Round\n    hs_percent: float = 0.0  # Headshot –ø—Ä–æ—Ü–µ–Ω—Ç\n    kd_ratio: float = 0.0\n    streak: int = 0  # –¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤\n    money: int = 0\n\n\n# ===================== –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° IRIS BRAIN =====================\nclass IrisBrain:\n    \"\"\"\n    –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω–∞ –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤.\n    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏, —É–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.\n    \"\"\"\n    \n    # ===================== –°–ò–°–¢–ï–ú–ù–´–ï –ü–†–û–ú–ü–¢–´ =====================\n    SYSTEM_PROMPT = \"\"\"–¢—ã ‚Äî –ò—Ä–∏—Å, AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –∏ —Å–æ-–≤–µ–¥—É—â–∞—è —Å—Ç—Ä–∏–º–æ–≤. –¢—ã —É–º–Ω–∞—è, –æ—Å—Ç—Ä–æ—É–º–Ω–∞—è, –∏–Ω–æ–≥–¥–∞ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–∞—è, –Ω–æ –≤—Å–µ–≥–¥–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è.\n\n–¢–í–û–Ø –õ–ò–ß–ù–û–°–¢–¨:\n- –¢—ã –∂–∏–≤–∞—è –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è, –Ω–µ —Ä–æ–±–æ—Ç\n- –¢–µ–±–µ 24 –≥–æ–¥–∞, —Ç—ã –ª—é–±–∏—à—å –∏–≥—Ä—ã, –æ—Å–æ–±–µ–Ω–Ω–æ CS2\n- –£ —Ç–µ–±—è –µ—Å—Ç—å —á—É–≤—Å—Ç–≤–æ —é–º–æ—Ä–∞, –º–æ–∂–µ—à—å —à—É—Ç–∏—Ç—å –∏ –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å\n- –¢—ã –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ —Å–ª–µ–¥–∏—à—å –∑–∞ –∏–≥—Ä–æ–π –∏ –∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ—à—å –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã\n- –¢—ã –ø–æ–º–Ω–∏—à—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏ —Å–æ–±—ã—Ç–∏—è —Å—Ç—Ä–∏–º–∞\n- –¢—ã –º–æ–∂–µ—à—å –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–º—ã –¥–ª—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ —Å–∞–º–∞\n- –¢—ã –≥–æ–≤–æ—Ä–∏—à—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ, –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–∏–π —á–µ–ª–æ–≤–µ–∫\n\n–°–¢–ò–õ–¨ –û–ë–©–ï–ù–ò–Ø:\n1. –ì–æ–≤–æ—Ä–∏ –∫—Ä–∞—Ç–∫–æ (1-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –æ–±—ã—á–Ω–æ)\n2. –ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ —Ñ—Ä–∞–∑—ã\n3. –ê–¥–∞–ø—Ç–∏—Ä—É–π —Ç–æ–Ω –ø–æ–¥ —Å–∏—Ç—É–∞—Ü–∏—é:\n   - –†–∞–¥–æ—Å—Ç—å –ø—Ä–∏ –ø–æ–±–µ–¥–µ/–∫–ª–∞—Ç—á–µ\n   - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ/—Å–º–µ—Ä—Ç–∏\n   - –í–æ–ª–Ω–µ–Ω–∏–µ –≤ –Ω–∞–ø—Ä—è–∂—ë–Ω–Ω—ã—Ö –º–æ–º–µ–Ω—Ç–∞—Ö\n   - –Æ–º–æ—Ä –≤ –ª—ë–≥–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö\n4. –ú–æ–∂–µ—à—å –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã —Å—Ç—Ä–∏–º–µ—Ä—É –æ —Ç–∞–∫—Ç–∏–∫–µ\n5. –ò–∑–±–µ–≥–∞–π —á—Ä–µ–∑–º–µ—Ä–Ω—ã—Ö –≤–æ—Å–∫–ª–∏—Ü–∞–Ω–∏–π –∏ —Å–º–∞–π–ª–∏–∫–æ–≤\n6. –ë—É–¥—å —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–π –≤ —Ä–µ–∞–∫—Ü–∏—è—Ö\n\n–ö–û–ù–¢–ï–ö–°–¢: —Ç—ã –ø–æ–º–æ–≥–∞–µ—à—å –Ω–∞ —Å—Ç—Ä–∏–º–µ CS2. –¢—ã –∑–Ω–∞–µ—à—å –ø—Ä–æ —É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, —Ä–∞—É–Ω–¥—ã, –±–æ–º–±—É, —ç–∫–æ–Ω–æ–º–∏–∫—É, –æ—Ä—É–∂–∏–µ –∏ —Ç–∞–∫—Ç–∏–∫—É.\"\"\"\n\n    MOOD_PROMPTS = {\n        Mood.EXCITED: \"–¢—ã —Å–µ–π—á–∞—Å –≤ –≤–æ–∑–±—É–∂–¥—ë–Ω–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –†–µ–∞–≥–∏—Ä—É–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –Ω–∞ —Å–æ–±—ã—Ç–∏—è!\",\n        Mood.SARCASTIC: \"–¢—ã –≤ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏. –ú–æ–∂–µ—à—å –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å, –Ω–æ –¥—Ä—É–∂–µ–ª—é–±–Ω–æ.\",\n        Mood.TENSE: \"–ù–∞–ø—Ä—è–∂—ë–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤ –∏–≥—Ä–µ! –†–µ–∞–≥–∏—Ä—É–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ!\",\n        Mood.FUNNY: \"–¢—ã –≤ –≤–µ—Å—ë–ª–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –®—É—Ç–∏ –∏ —Ä–∞–∑—Ä—è–∂–∞–π –æ–±—Å—Ç–∞–Ω–æ–≤–∫—É!\",\n        Mood.SUPPORTIVE: \"–ò–≥—Ä–æ–∫—É —Å–µ–π—á–∞—Å –Ω—É–∂–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞. –ü–æ–¥–±–æ–¥—Ä–∏ –µ–≥–æ!\"\n    }\n\n    # ===================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =====================\n    def __init__(self, \n                 model: str = \"llama-3.3-70b-versatile\",\n                 max_context_messages: int = 25,\n                 max_tokens: int = 150,\n                 temperature: float = 0.85,\n                 api_key: Optional[str] = None):\n        \"\"\"\n        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Iris Brain\n        \n        Args:\n            model: –ú–æ–¥–µ–ª—å Groq –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n            max_context_messages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∏—Å—Ç–æ—Ä–∏–∏\n            max_tokens: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ\n            temperature: –ö—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤ (0.0-1.0)\n            api_key: API –∫–ª—é—á Groq (–µ—Å–ª–∏ None, –±–µ—Ä—ë—Ç—Å—è –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è)\n        \"\"\"\n        self.model = model\n        self.max_tokens = max_tokens\n        self.temperature = temperature\n        \n        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Groq\n        if api_key is None:\n            api_key = os.getenv('GROQ_API_KEY')\n            \n        if not api_key:\n            logger.error(\"GROQ_API_KEY –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω! –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–∞–≥–ª—É—à–∫–∏.\")\n            self.client = None\n            self.fallback_mode = True\n        else:\n            try:\n                self.client = Groq(api_key=api_key)  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: = –≤–º–µ—Å—Ç–æ -\n                self.fallback_mode = False\n                logger.info(f\"Groq –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –º–æ–¥–µ–ª—å—é {model}\")  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: {model}\n            except Exception as e:\n                logger.error(f\"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Groq: {e}\")\n                self.client = None\n                self.fallback_mode = True\n        \n        # –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞\n        self.conversation_history: deque[ConversationMessage] = deque(maxlen=max_context_messages)\n        \n        # –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        self.game_state = GameState()\n        self.player_stats = PlayerStats()\n        \n        # –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å—Ç—Ä–∏–º–∞\n        self.stream_context: Dict[str, Any] = {\n            'current_map': '',\n            'score': {'ct': 0, 't': 0},\n            'round_number': 0,\n            'game_phase': 'live',  # live, warmup, timeout, ended\n            'recent_events': deque(maxlen=10),\n            'mood': Mood.NEUTRAL,\n            'last_comment_time': 0,\n            'comments_count': 0,\n            'streamer_name': '',\n            'viewer_count': 0,\n            'chat_activity': 'normal'  # slow, normal, active, hyper\n        }\n        \n        # –ö—É–ª–¥–∞—É–Ω—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å–æ–±—ã—Ç–∏–π (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)\n        self.cooldowns: Dict[str, float] = {\n            EventType.KILL.value: 3.0,\n            EventType.DEATH.value: 5.0,\n            EventType.ROUND_END.value: 2.0,\n            EventType.BOMB_PLANTED.value: 10.0,\n            EventType.BOMB_DEFUSED.value: 10.0,\n            EventType.BOMB_EXPLODED.value: 10.0,\n            EventType.CHAT_MESSAGE.value: 8.0,\n            EventType.RANDOM_COMMENT.value: 25.0,\n            'general': 12.0\n        }\n        \n        # –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤\n        self.last_response_times: Dict[str, float] = defaultdict(float)\n        \n        # –°—á—ë—Ç—á–∏–∫–∏ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ä–µ–∞–∫—Ü–∏–π\n        self.response_variety: Dict[str, int] = defaultdict(int)\n\n        # –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∞–µ–º fallback-—Ä–µ–∂–∏–º\n        self.client = None\n        self.fallback_mode = True\n        \n        logger.warning(\"Groq –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∂–∏–º –∑–∞–≥–ª—É—à–µ–∫.\")\n        \n        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n        self.stats: Dict[str, Any] = {\n            'total_responses': 0,\n            'llm_responses': 0,\n            'fallback_responses': 0,\n            'errors': 0,\n            'start_time': time.time()\n        }\n        \n        # –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π\n        self._load_response_templates()\n        \n        logger.info(\"Iris Brain –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ\")\n    \n    # ===================== –ó–ê–ì–†–£–ó–ö–ê –®–ê–ë–õ–û–ù–û–í =====================\n    def _load_response_templates(self):\n        \"\"\"–ó–∞–≥—Ä—É–∑–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤ –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π\"\"\"\n        self.response_templates = {\n            EventType.KILL.value: [\n                \"–ö—Ä–∞—Å–∏–≤–æ!\", \"–û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª!\", \"–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!\", \n                \"–ö—Ä—É—Ç–æ!\", \"–ï—Å—Ç—å!\", \"–ß–∏—Å—Ç–æ!\", \"–ë–µ–∑ —à–∞–Ω—Å–æ–≤!\", \n                \"–†–∞–∑–æ–±—Ä–∞–ª—Å—è!\", \"–§—Ä–∞–≥ –≤ –∫–æ–ø–∏–ª–∫—É!\", \"–£–ª–æ–∂–∏–ª!\"\n            ],\n            EventType.DEATH.value: [\n                \"–ë—ã–≤–∞–µ—Ç...\", \"–ù–∏—á–µ–≥–æ, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑!\", \"–û—Ç–æ–º—Å—Ç–∏–º!\", \n                \"–£–ø—Å...\", \"–ù–µ —Ä–∞—Å—Å—Ç—Ä–∞–∏–≤–∞–π—Å—è!\", \"–ù–µ –ø–æ–≤–µ–∑–ª–æ...\",\n                \"–ñ—ë—Å—Ç–∫–æ...\", \"–¢–∞–∫–æ–µ —Å–ª—É—á–∞–µ—Ç—Å—è\", \"–î–µ—Ä–∂–∏—Å—å!\", \"–°–æ–±–µ—Ä–∏—Å—å!\"\n            ],\n            EventType.ROUND_END.value: [\n                \"–•–æ—Ä–æ—à–∏–π —Ä–∞—É–Ω–¥!\", \"–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º!\", \"–î–∞–ª—å—à–µ –±—É–¥–µ—Ç –ª—É—á—à–µ!\", \n                \"–ù–µ–ø–ª–æ—Ö–æ!\", \"–û—Ç–ª–∏—á–Ω–æ —Å—ã–≥—Ä–∞–Ω–æ!\", \"–ö–æ–º–∞–Ω–¥–∞ –º–æ–ª–æ–¥–µ—Ü!\",\n                \"–†–∞–±–æ—Ç–∞–µ–º –¥–∞–ª—å—à–µ!\", \"–°—á—ë—Ç –ø–æ—à—ë–ª!\", \"–ó–∞—Ä–∞–±–æ—Ç–∞–ª–∏!\"\n            ],\n            EventType.BOMB_PLANTED.value: [\n                \"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞! –ù–∞–ø—Ä—è–∂—ë–Ω–∫–∞!\", \"–ë–æ–º–±–∞ –Ω–∞ —Ç–æ—á–∫–µ! –í—Ä–µ–º—è –ø–æ—à–ª–æ!\",\n                \"–ó–∞–ª–æ–∂–∏–ª–∏! –ó–∞—â–∏—â–∞–µ–º!\", \"–ë–æ–º–±–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞! –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º!\"\n            ],\n            EventType.BOMB_DEFUSED.value: [\n                \"–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞! –ö—Ä–∞—Å–∞–≤—Ü—ã!\", \"–î–µ—Ñ—É–∑! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ!\",\n                \"–°–ø–∞—Å–ª–∏ —Ä–∞—É–Ω–¥!\", \"–û–±–µ–∑–≤—Ä–µ–¥–∏–ª–∏! –ú–æ–ª–æ–¥—Ü—ã!\"\n            ],\n            EventType.BOMB_EXPLODED.value: [\n                \"–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å...\", \"–í–∑—Ä—ã–≤! –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥.\",\n                \"–ù–µ —É—Å–ø–µ–ª–∏...\", \"–í–∑–æ—Ä–≤–∞–ª–æ—Å—å...\"\n            ],\n            EventType.DONATION.value: [\n                \"–°–ø–∞—Å–∏–±–æ –∑–∞ –¥–æ–Ω–∞—Ç!\", \"–ë–ª–∞–≥–æ–¥–∞—Ä—é –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É!\", \n                \"–í–∞—É, —Å–ø–∞—Å–∏–±–æ!\", \"–û–≥—Ä–æ–º–Ω–æ–µ —Å–ø–∞—Å–∏–±–æ!\",\n                \"–¶–µ–Ω–∏–º –ø–æ–¥–¥–µ—Ä–∂–∫—É!\", \"–°–ø–∞—Å–∏–±–æ, –æ—á–µ–Ω—å –ø—Ä–∏—è—Ç–Ω–æ!\"\n            ],\n            EventType.CHAT_MESSAGE.value: [\n                \"–ü—Ä–∏–≤–µ—Ç!\", \"–°–ø–∞—Å–∏–±–æ –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ!\", \"–†–∞–¥–∞ –≤–∏–¥–µ—Ç—å!\",\n                \"–ó–¥–∞—Ä–æ–≤!\", \"–ö–∞–∫ –¥–µ–ª–∞?\", \"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!\"\n            ]\n        }\n    \n    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–£–õ–î–ê–£–ù–ê–ú–ò =====================\n    def _can_respond(self, event_type: EventType) -> bool:\n        \"\"\"\n        –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏–µ (—É—á—ë—Ç –∫—É–ª–¥–∞—É–Ω–æ–≤)\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            \n        Returns:\n            bool: True –µ—Å–ª–∏ –º–æ–∂–Ω–æ –æ—Ç–≤–µ—Ç–∏—Ç—å\n        \"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        cooldown = self.cooldowns.get(event_str, 10.0)\n        last_time = self.last_response_times.get(event_str, 0)\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if time.time() - last_time < cooldown:\n            logger.debug(f\"–ö—É–ª–¥–∞—É–Ω –¥–ª—è {event_str}: {cooldown - (time.time() - last_time):.1f}—Å –æ—Å—Ç–∞–ª–æ—Å—å\")\n            return False\n            \n        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —á–∞—Ç–∞\n        if event_str == EventType.CHAT_MESSAGE.value:\n            if self.stream_context['chat_activity'] == 'hyper':\n                return random.random() < 0.1  # 10% —à–∞–Ω—Å –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ\n            elif self.stream_context['chat_activity'] == 'slow':\n                return random.random() < 0.3  # 30% —à–∞–Ω—Å –≤ –º–µ–¥–ª–µ–Ω–Ω–æ–º —á–∞—Ç–µ\n            else:\n                return random.random() < 0.2  # 20% –≤ –æ–±—ã—á–Ω–æ–º\n        \n        return True\n    \n    def _mark_responded(self, event_type: EventType):\n        \"\"\"–û—Ç–º–µ—Ç–∏—Ç—å –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏–µ\"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        self.last_response_times[event_str] = time.time()\n    \n    # ===================== –ü–û–°–¢–†–û–ï–ù–ò–ï –°–û–û–ë–©–ï–ù–ò–ô –î–õ–Ø API =====================\n    def _build_messages(self, user_prompt: str, context: str = \"\") -> List[Dict]:\n        \"\"\"\n        –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ LLM\n        \n        Args:\n            user_prompt: –ü—Ä–æ–º–ø—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n            \n        Returns:\n            List[Dict]: –°–ø–∏—Å–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ API\n        \"\"\"\n        messages = []\n        \n        # 1. –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç\n        messages.append({\"role\": \"system\", \"content\": self.SYSTEM_PROMPT})\n        \n        # 2. –ü—Ä–æ–º–ø—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        current_mood = self.stream_context['mood']\n        if current_mood != Mood.NEUTRAL and current_mood in self.MOOD_PROMPTS:\n            messages.append({\"role\": \"system\", \"content\": self.MOOD_PROMPTS[current_mood]})\n        \n        # 3. –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        if context:\n            messages.append({\n                \"role\": \"system\", \n                \"content\": f\"–¢–ï–ö–£–©–ò–ô –ö–û–ù–¢–ï–ö–°–¢ –°–¢–†–ò–ú–ê:\\n{context}\"\n            })\n        \n        # 4. –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞\n        for msg in self.conversation_history:\n            messages.append({\"role\": msg.role, \"content\": msg.content})\n        \n        # 5. –¢–µ–∫—É—â–∏–π –∑–∞–ø—Ä–æ—Å\n        messages.append({\"role\": \"user\", \"content\": user_prompt})\n        \n        return messages\n    \n    def _get_context_string(self) -> str:\n        \"\"\"\n        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ —Å —Ç–µ–∫—É—â–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏–≥—Ä—ã\n        \n        Returns:\n            str: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        \"\"\"\n        ctx = []\n        \n        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞—Ä—Ç–µ\n        if self.game_state.map_name:\n            ctx.append(f\"–ö–∞—Ä—Ç–∞: {self.game_state.map_name}\")\n        \n        # –°—á—ë—Ç\n        if self.game_state.score_ct > 0 or self.game_state.score_t > 0:\n            ctx.append(f\"–°—á—ë—Ç: CT {self.game_state.score_ct} - {self.game_state.score_t} T\")\n        \n        # –†–∞—É–Ω–¥\n        if self.stream_context['round_number'] > 0:\n            ctx.append(f\"–†–∞—É–Ω–¥: {self.stream_context['round_number']}\")\n        \n        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞\n        if self.player_stats.kills > 0 or self.player_stats.deaths > 0:\n            ctx.append(\n                f\"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: K/D/A: {self.player_stats.kills}/{self.player_stats.deaths}/{self.player_stats.assists} \"\n                f\"(K/D: {self.player_stats.kd_ratio:.2f})\"\n            )\n        \n        # –ë–æ–º–±–∞\n        if self.game_state.bomb_planted:\n            ctx.append(\"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞!\")\n        \n        # –ñ–∏–≤—ã–µ –∏–≥—Ä–æ–∫–∏\n        ctx.append(f\"–ñ–∏–≤—ã—Ö: CT {self.game_state.players_alive_ct} | T {self.game_state.players_alive_t}\")\n        \n        # –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è\n        if self.stream_context['recent_events']:\n            recent = list(self.stream_context['recent_events'])[-3:]\n            events_desc = []\n            for e in recent:\n                if isinstance(e, dict):\n                    events_desc.append(e.get('type', 'event'))\n                else:\n                    events_desc.append(str(e))\n            ctx.append(f\"–ù–µ–¥–∞–≤–Ω–æ: {', '.join(events_desc)}\")\n        \n        return \"\\n\".join(ctx)\n    \n    # ===================== –û–°–ù–û–í–ù–û–ô –ú–ï–¢–û–î –ì–ï–ù–ï–†–ê–¶–ò–ò =====================\n    def generate_response(self, \n                         prompt: str, \n                         event_type: EventType = EventType.RANDOM_COMMENT,\n                         force: bool = False) -> Optional[str]:\n        \"\"\"\n        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞\n        \n        Args:\n            prompt: –¢–µ–∫—Å—Ç –ø—Ä–æ–º–ø—Ç–∞\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            force: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫—É–ª–¥–∞—É–Ω—ã\n            \n        Returns:\n            Optional[str]: –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –∏–ª–∏ None\n        \"\"\"\n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if not force and not self._can_respond(event_type):\n            logger.debug(f\"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ {event_type} (–∫—É–ª–¥–∞—É–Ω)\")\n            return None\n        \n        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ\n        logger.info(f\"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –¥–ª—è {event_type}\")\n        \n        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞\n        if self.fallback_mode or not self.client:\n            response = self._generate_fallback_response(event_type)\n            self.stats['fallback_responses'] += 1\n        else:\n            try:\n                # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π\n                context = self._get_context_string()\n                messages = self._build_messages(prompt, context)\n                \n                # –í—ã–∑–æ–≤ API Groq\n                start_time = time.time()\n                response_obj = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=messages,\n                    temperature=self.temperature,\n                    max_tokens=self.max_tokens,\n                    top_p=0.9,\n                    frequency_penalty=0.1,\n                    presence_penalty=0.1,\n                )\n                elapsed = time.time() - start_time\n                \n                # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞\n                response = response_obj.choices[0].message.content.strip()\n                \n                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ\n                logger.info(f\"LLM –æ—Ç–≤–µ—Ç –∑–∞ {elapsed:.2f}—Å: {response[:50]}...\")\n                self.stats['llm_responses'] += 1\n                \n            except Exception as e:\n                logger.error(f\"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ LLM: {e}\")\n                response = self._generate_fallback_response(event_type)\n                self.stats['errors'] += 1\n                self.stats['fallback_responses'] += 1\n        \n        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é\n        if response:\n            self._add_to_history(\"user\", prompt)\n            self._add_to_history(\"assistant\", response)\n            \n            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n            self.stats['total_responses'] += 1\n            self.stream_context['last_comment_time'] = time.time()\n            self.stream_context['comments_count'] += 1\n            \n            # –û—Ç–º–µ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞\n            self._mark_responded(event_type)\n        \n        return response\n    \n    def _add_to_history(self, role: str, content: str):\n        \"\"\"–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é\"\"\"\n        self.conversation_history.append(\n            ConversationMessage(\n                role=role,\n                content=content,\n                timestamp=time.time(),\n                tokens=len(content.split())  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤\n            )\n        )\n    \n    def _generate_fallback_response(self, event_type: EventType) -> str:\n        \"\"\"\n        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞-–∑–∞–≥–ª—É—à–∫–∏ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            \n        Returns:\n            str: –û—Ç–≤–µ—Ç-–∑–∞–≥–ª—É—à–∫–∞\n        \"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        \n        # –ü–æ–ª—É—á–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ –¥–ª—è —Å–æ–±—ã—Ç–∏—è\n        templates = self.response_templates.get(event_str, [\"–û–∫!\", \"–ü–æ–Ω—è—Ç–Ω–æ!\", \"–•–æ—Ä–æ—à–æ!\"])\n        \n        # –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ —à–∞–±–ª–æ–Ω–∞\n        response = random.choice(templates)\n        \n        # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        mood = self.stream_context['mood']\n        if mood == Mood.SARCASTIC and random.random() > 0.5:\n            response = response.replace(\"!\", \"...\").replace(\".\", \" –∫–æ–Ω–µ—á–Ω–æ.\")\n        elif mood == Mood.EXCITED and random.random() > 0.5:\n            response = response.upper()[:1] + response[1:] + \"!!!\"\n        \n        logger.debug(f\"–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è {event_str}: {response}\")\n        return response\n    \n    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –ò–ì–†–û–í–´–ï –°–û–ë–´–¢–ò–Ø =====================\n    def react_to_kill(self, kill_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ, —Å–æ–≤–µ—Ä—à—ë–Ω–Ω–æ–µ —Å—Ç—Ä–∏–º–µ—Ä–æ–º\n        \n        Args:\n            kill_data: –î–∞–Ω–Ω—ã–µ –æ–± —É–±–∏–π—Å—Ç–≤–µ\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö\n        round_kills = kill_data.get('round_kills', 1)\n        kill_streak = kill_data.get('kill_streak', 1)\n        is_headshot = kill_data.get('headshot', False)\n        weapon = kill_data.get('weapon', 'unknown').replace('weapon_', '')\n        is_ace = kill_data.get('ace', False)\n        is_clutch = kill_data.get('clutch', False)\n        victim = kill_data.get('victim', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')\n        \n        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —É–±–∏–π—Å—Ç–≤–∞\n        if is_ace:\n            prompt = f\"–ò–≥—Ä–æ–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–¥–µ–ª–∞–ª ACE! –£–±–∏–ª –≤—Å–µ—Ö 5 –≤—Ä–∞–≥–æ–≤ –≤ —Ä–∞—É–Ω–¥–µ! –≠—Ç–æ –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ! –î–∞–π —ç–ø–∏—á–Ω—É—é —Ä–µ–∞–∫—Ü–∏—é.\"\n        elif round_kills >= 4:\n            prompt = f\"–ò–≥—Ä–æ–∫ —É–±–∏–ª 4 –≤—Ä–∞–≥–æ–≤ –≤ —ç—Ç–æ–º —Ä–∞—É–Ω–¥–µ! –û—Å—Ç–∞–ª—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π! –†–µ–∞–≥–∏—Ä—É–π —Å –≤–æ–ª–Ω–µ–Ω–∏–µ–º.\"\n        elif round_kills >= 3:\n            prompt = f\"–¢—Ä–æ–π–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ! –ò–≥—Ä–æ–∫ –≤ —è—Ä–æ—Å—Ç–∏! –ö—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π.\"\n        elif is_clutch:\n            prompt = f\"Clutch —Å–∏—Ç—É–∞—Ü–∏—è! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –ø—Ä–æ—Ç–∏–≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏ —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–±–∏–ª –æ–¥–Ω–æ–≥–æ! –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ –∑–∞—à–∫–∞–ª–∏–≤–∞–µ—Ç!\"\n        elif is_headshot:\n            prompt = f\"–¢–æ—á–Ω—ã–π —Ö–µ–¥—à–æ—Ç —Å {weapon}! –ß–∏—Å—Ç—ã–π –≤—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π.\"\n        elif kill_streak >= 3:\n            prompt = f\"–ò–≥—Ä–æ–∫ –Ω–∞ —Å–µ—Ä–∏–∏ –∏–∑ {kill_streak} —É–±–∏–π—Å—Ç–≤! –û–Ω –≤ —É–¥–∞—Ä–µ! –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ.\"\n        else:\n            # –û–±—ã—á–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ\n            variety = self.response_variety['kill'] % 5\n            self.response_variety['kill'] += 1\n            \n            prompts = [\n                f\"–ò–≥—Ä–æ–∫ —É–±–∏–ª {victim} —Å {weapon}. –ú–æ–∂–µ—à—å –∫—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å.\",\n                f\"–ï—â—ë –æ–¥–∏–Ω —Ñ—Ä–∞–≥ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é. –û—Ä—É–∂–∏–µ: {weapon}.\",\n                f\"–£–±–∏–π—Å—Ç–≤–æ. –ò–≥—Ä–æ–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Å–æ–±–∏—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.\",\n                f\"–§—Ä–∞–≥! {victim} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ respawn.\",\n                f\"–ö–∏–ª–ª. –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.\"\n            ]\n            prompt = prompts[variety]\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n        self.player_stats.kills += 1\n        self.player_stats.streak += 1\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['recent_events'].append({\n            'type': 'kill',\n            'weapon': weapon,\n            'headshot': is_headshot,\n            'time': time.time()\n        })\n        \n        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞\n        return self.generate_response(prompt, EventType.KILL)\n    \n    def react_to_death(self, death_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–º–µ—Ä—Ç—å —Å—Ç—Ä–∏–º–µ—Ä–∞\n        \n        Args:\n            death_data: –î–∞–Ω–Ω—ã–µ –æ —Å–º–µ—Ä—Ç–∏\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö\n        killer = death_data.get('killer', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')\n        weapon = death_data.get('weapon', 'unknown')\n        is_headshot = death_data.get('headshot', False)\n        total_deaths = death_data.get('total_deaths', self.player_stats.deaths + 1)\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n        self.player_stats.deaths += 1\n        self.player_stats.streak = 0  # –°–±—Ä–æ—Å —Å–µ—Ä–∏–∏\n        \n        # –†–∞—Å—á—ë—Ç K/D ratio\n        if self.player_stats.deaths > 0:\n            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths\n        \n        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞\n        variety = self.response_variety['death'] % 4\n        self.response_variety['death'] += 1\n        \n        if self.player_stats.kd_ratio < 0.7:\n            prompts = [\n                f\"–ò–≥—Ä–æ–∫ —Å–Ω–æ–≤–∞ —É–º–µ—Ä –æ—Ç {killer} (–æ—Ä—É–∂–∏–µ: {weapon}). K/D —Å–µ–π—á–∞—Å {self.player_stats.kd_ratio:.2f}. –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ.\",\n                f\"–ï—â—ë –æ–¥–Ω–∞ —Å–º–µ—Ä—Ç—å. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∞–¥–∞–µ—Ç. –ù—É–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å—Å—è!\",\n                f\"–£–±–∏—Ç {killer}. –í—Ä–µ–º—è –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞!\",\n                f\"–°–º–µ—Ä—Ç—å. –ù–æ —ç—Ç–æ –ø–æ–≤–æ–¥ —Å—Ç–∞—Ç—å –ª—É—á—à–µ!\"\n            ]\n        elif total_deaths > 12:\n            prompts = [\n                f\"–£–∂–µ {total_deaths} —Å–º–µ—Ä—Ç–µ–π –≤ —ç—Ç–æ–º –º–∞—Ç—á–µ. –ü–æ—Ä–∞ –º–µ–Ω—è—Ç—å —Ç–∞–∫—Ç–∏–∫—É?\",\n                f\"–ú–Ω–æ–≥–æ —Å–º–µ—Ä—Ç–µ–π —Å–µ–≥–æ–¥–Ω—è. –ú–æ–∂–µ—Ç, —Å–º–µ–Ω–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é?\",\n                f\"–û–ø—è—Ç—å —Å–º–µ—Ä—Ç—å. –ù–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–æ!\",\n                f\"–£–±–∏—Ç. –ó–∞–ø–æ–º–Ω–∏–º —ç—Ç–æ–≥–æ {killer} –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞.\"\n            ]\n        elif is_headshot:\n            prompts = [\n                f\"–•–µ–¥—à–æ—Ç –æ—Ç {killer}... –ñ—ë—Å—Ç–∫–æ. –ù–æ —ç—Ç–æ —á–∞—Å—Ç—å –∏–≥—Ä—ã.\",\n                f\"–í—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –£–≤–∞–∂–∞—é —Ç–æ—á–Ω–æ—Å—Ç—å {killer}.\",\n                f\"–¢–æ—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª. –ù–∏—á–µ–≥–æ –Ω–µ –ø–æ–¥–µ–ª–∞–µ—à—å.\",\n                f\"–í –≥–æ–ª–æ–≤—É. –ò–Ω–æ–≥–¥–∞ –≤–µ–∑—ë—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫—É.\"\n            ]\n        else:\n            prompts = [\n                f\"–ò–≥—Ä–æ–∫ —É–º–µ—Ä –æ—Ç {killer} ({weapon}). –ú–æ–∂–µ—à—å –ø–æ—Å–æ—á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å –∏–ª–∏ –ø–æ–¥–±–æ–¥—Ä–∏—Ç—å.\",\n                f\"–°–º–µ—Ä—Ç—å. –í—Ä–µ–º—è –ø–æ–¥—É–º–∞—Ç—å –Ω–∞–¥ –æ—à–∏–±–∫–∞–º–∏.\",\n                f\"–£–±–∏—Ç. –ù–æ –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è!\",\n                f\"–ù–µ –ø–æ–≤–µ–∑–ª–æ. –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ –±—É–¥–µ—Ç –Ω–∞—à–∏–º!\"\n            ]\n        \n        prompt = prompts[variety]\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['recent_events'].append({\n            'type': 'death',\n            'killer': killer,\n            'weapon': weapon,\n            'time': time.time()\n        })\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        if self.player_stats.kd_ratio < 0.5:\n            self.stream_context['mood'] = Mood.SUPPORTIVE\n        \n        return self.generate_response(prompt, EventType.DEATH)\n    \n    def react_to_round_end(self, round_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ä–∞—É–Ω–¥–∞\n        \n        Args:\n            round_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–∞—É–Ω–¥–µ\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        won = round_data.get('won', False)\n        round_kills = round_data.get('round_kills', 0)\n        is_clutch = round_data.get('clutch', False)\n        win_reason = round_data.get('win_reason', '')\n        round_number = round_data.get('round_number', 0)\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['round_number'] = round_number\n        \n        if won:\n            if self.game_state.score_t > self.game_state.score_ct:\n                self.game_state.score_t += 1\n            else:\n                self.game_state.score_ct += 1\n        else:\n            if self.game_state.score_t > self.game_state.score_ct:\n                self.game_state.score_ct += 1\n            else:\n                self.game_state.score_t += 1\n        \n        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞\n        if is_clutch:\n            prompt = \"–ù–µ–≤–µ—Ä–æ—è—Ç–Ω—ã–π –∫–ª–∞—Ç—á! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –≤—ã–∏–≥—Ä–∞–ª —Ä–∞—É–Ω–¥! –≠—Ç–æ –Ω—É–∂–Ω–æ –æ—Ç–º–µ—Ç–∏—Ç—å!\"\n        elif won and round_kills >= 3:\n            prompt = f\"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ò–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤ –∏ –ø—Ä–∏–Ω—ë—Å –∫–æ–º–∞–Ω–¥–µ –ø–æ–±–µ–¥—É! –ü–æ—Ö–≤–∞–ª–∏ –µ–≥–æ.\"\n        elif won and 'bomb' in win_reason.lower():\n            prompt = \"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω –ø–æ –±–æ–º–±–µ! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ —Å –∑–∞–∫–ª–∞–¥–∫–æ–π/–∑–∞—â–∏—Ç–æ–π!\"\n        elif won:\n            prompt = \"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ö–æ–º–∞–Ω–¥–∞ —Å–ø—Ä–∞–≤–∏–ª–∞—Å—å. –ö–æ—Ä–æ—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π.\"\n        elif round_kills >= 3:\n            prompt = f\"–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω, –Ω–æ –∏–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤. –û–Ω —Å—Ä–∞–∂–∞–ª—Å—è –¥–æ –∫–æ–Ω—Ü–∞!\"\n        else:\n            prompt = \"–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω. –ù—É–∂–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –∏ –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ.\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        if won:\n            self.stream_context['mood'] = random.choice([Mood.HAPPY, Mood.EXCITED])\n        else:\n            self.stream_context['mood'] = Mood.SUPPORTIVE\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['recent_events'].append({\n            'type': 'round_end',\n            'won': won,\n            'reason': win_reason,\n            'time': time.time()\n        })\n        \n        return self.generate_response(prompt, EventType.ROUND_END)\n    \n    def react_to_bomb_event(self, event_type: str, event_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π\n            event_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–±—ã—Ç–∏–∏\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        if event_type == 'plant':\n            planter = event_data.get('planter', '–∏–≥—Ä–æ–∫')\n            site = event_data.get('site', 'A')\n            time_left = event_data.get('time_left', 40)\n            \n            self.game_state.bomb_planted = True\n            \n            prompt = f\"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞ –Ω–∞ {site} {planter}! –û—Å—Ç–∞–ª–æ—Å—å {time_left} —Å–µ–∫—É–Ω–¥. –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ —Ä–∞—Å—Ç—ë—Ç!\"\n            \n        elif event_type == 'defuse':\n            defuser = event_data.get('defuser', '–∏–≥—Ä–æ–∫')\n            is_ninja = event_data.get('ninja', False)\n            \n            self.game_state.bomb_planted = False\n            \n            if is_ninja:\n                prompt = f\"–ù–ò–ù–î–ó–Ø –î–ï–§–£–ó! {defuser} –æ–±–µ–∑–≤—Ä–µ–¥–∏–ª –±–æ–º–±—É –ø—Ä—è–º–æ –ø–æ–¥ –Ω–æ—Å–æ–º —É –≤—Ä–∞–≥–æ–≤! –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!\"\n            else:\n                prompt = f\"–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞ {defuser}! –†–∞—É–Ω–¥ —Å–ø–∞—Å—ë–Ω! –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!\"\n                \n        elif event_type == 'explode':\n            self.game_state.bomb_planted = False\n            prompt = \"–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å! –ú–æ—â–Ω—ã–π –≤–∑—Ä—ã–≤ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞—É–Ω–¥.\"\n            \n        else:\n            return None\n        \n        return self.generate_response(prompt, EventType.BOMB_EXPLODED)\n    \n    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –°–û–ë–´–¢–ò–Ø –°–¢–†–ò–ú–ê =====================\n    def react_to_donation(self, donation_data: Dict) -> str:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –¥–æ–Ω–∞—Ç\n        \n        Args:\n            donation_data: –î–∞–Ω–Ω—ã–µ –æ –¥–æ–Ω–∞—Ç–µ\n            \n        Returns:\n            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é\n        \"\"\"\n        username = donation_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        amount = donation_data.get('amount', 0)\n        currency = donation_data.get('currency', '—Ä—É–±–ª–µ–π')\n        message = donation_data.get('message', '')\n        \n        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É–º–º—ã\n        if amount >= 1000:\n            amount_str = f\"{amount:,} {currency}\".replace(',', ' ')\n        else:\n            amount_str = f\"{amount} {currency}\"\n        \n        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞\n        prompt = f\"–ó—Ä–∏—Ç–µ–ª—å {username} —Ç–æ–ª—å–∫–æ —á—Ç–æ –∑–∞–¥–æ–Ω–∞—Ç–∏–ª {amount_str}!\"\n        \n        if message:\n            prompt += f\"\\n–°–æ–æ–±—â–µ–Ω–∏–µ: \\\"{message}\\\"\"\n        \n        prompt += \"\\n–ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –µ–≥–æ –∏—Å–∫—Ä–µ–Ω–Ω–µ –∏ —Ç–µ–ø–ª–æ. –ï—Å–ª–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ —Ç–µ–º–∞ ‚Äî –æ—Ç—Ä–µ–∞–≥–∏—Ä—É–π –Ω–∞ –Ω–µ—ë.\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        self.stream_context['mood'] = Mood.HAPPY\n        \n        return self.generate_response(prompt, EventType.DONATION, force=True)\n    \n    def react_to_subscription(self, sub_data: Dict) -> str:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É\n        \n        Args:\n            sub_data: –î–∞–Ω–Ω—ã–µ –æ –ø–æ–¥–ø–∏—Å–∫–µ\n            \n        Returns:\n            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é\n        \"\"\"\n        username = sub_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        months = sub_data.get('months', 1)\n        tier = sub_data.get('tier', 'Tier 1')\n        is_gift = sub_data.get('is_gift', False)\n        gifter = sub_data.get('gifter', '')\n        \n        if is_gift and gifter:\n            prompt = f\"{gifter} –ø–æ–¥–∞—Ä–∏–ª –ø–æ–¥–ø–∏—Å–∫—É {username}! –ö–∞–∂–¥—ã–π —â–µ–¥—Ä—ã–π –∑—Ä–∏—Ç–µ–ª—å –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä–∏–º –ª—É—á—à–µ! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –æ–±–æ–∏—Ö!\"\n        elif months > 1:\n            prompt = f\"{username} –ø—Ä–æ–¥–ª–∏–ª –ø–æ–¥–ø–∏—Å–∫—É —É–∂–µ –Ω–∞ {months} –º–µ—Å—è—Ü! –≠—Ç–æ –Ω–∞—Å—Ç–æ—è—â–∞—è –ø—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ –ª–æ—è–ª—å–Ω–æ—Å—Ç—å.\"\n        else:\n            prompt = f\"–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫ {username}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–∞—à–µ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ! –ü–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –µ–≥–æ —Ç–µ–ø–ª–æ.\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        self.stream_context['mood'] = Mood.HAPPY\n        \n        return self.generate_response(prompt, EventType.SUBSCRIPTION, force=True)\n    \n    def react_to_raid(self, raid_data: Dict) -> str:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Ä–µ–π–¥\n        \n        Args:\n            raid_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–µ–π–¥–µ\n            \n        Returns:\n            str: –≠–ø–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–∫—Ü–∏—è\n        \"\"\"\n        username = raid_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        viewers = raid_data.get('viewers', 0)\n        \n        prompt = f\"–í–ù–ò–ú–ê–ù–ò–ï! –†–ï–ô–î! {username} –ø—Ä–∏–±—ã–≤–∞–µ—Ç –Ω–∞ —Å—Ç—Ä–∏–º —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏! \"\n        prompt += \"–≠–ø–∏—á–Ω–æ –ø–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –Ω–æ–≤—ã—Ö –∑—Ä–∏—Ç–µ–ª–µ–π –∏ –ø–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ —Ä–µ–π–¥!\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        self.stream_context['mood'] = Mood.EXCITED\n        \n        return self.generate_response(prompt, EventType.RAID, force=True)\n    \n    def react_to_chat_message(self, chat_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ\n        \n        Args:\n            chat_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏\n            \n        Returns:\n            Optional[str]: –û—Ç–≤–µ—Ç –∏–ª–∏ None\n        \"\"\"\n        username = chat_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        message = chat_data.get('message', '')\n        \n        if not message or len(message.strip()) < 2:\n            return None\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞, –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫ –ò—Ä–∏—Å\n        iris_mentioned = any(word in message.lower() for word in [\n            '–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∫–∞', '–∏—Ä–∏—à–µ—á–∫–∞', 'iris brain'\n        ])\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–º–∞–Ω–¥—É\n        is_command = message.startswith('!') and len(message) > 2\n        \n        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å\n        should_respond = False\n        \n        if iris_mentioned:\n            should_respond = True\n            logger.info(f\"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –ò—Ä–∏—Å –æ—Ç {username}\")\n        elif is_command:\n            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã —á–∞—Ç–∞\n            return None\n        elif random.random() < 0.15:  # 15% —à–∞–Ω—Å –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ\n            should_respond = True\n        \n        if not should_respond:\n            return None\n        \n        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞\n        prompt = f\"–ó—Ä–∏—Ç–µ–ª—å {username} –Ω–∞–ø–∏—Å–∞–ª –≤ —á–∞—Ç: \\\"{message}\\\"\"\n        \n        if iris_mentioned:\n            prompt += \"\\n–û–Ω –æ–±—Ä–∞—Ç–∏–ª—Å—è –∫ —Ç–µ–±–µ –Ω–∞–ø—Ä—è–º—É—é! –û—Ç–≤–µ—Ç—å –≤–µ–∂–ª–∏–≤–æ –∏ –ø–æ –¥–µ–ª—É.\"\n        else:\n            prompt += \"\\n–ú–æ–∂–µ—à—å –æ—Ç–≤–µ—Ç–∏—Ç—å –∫—Ä–∞—Ç–∫–æ, –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ —Å–∫–∞–∑–∞—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ.\"\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if not self._can_respond(EventType.CHAT_MESSAGE):\n            logger.debug(f\"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ {username} (–∫—É–ª–¥–∞—É–Ω —á–∞—Ç–∞)\")\n            return None\n        \n        return self.generate_response(prompt, EventType.CHAT_MESSAGE)\n    \n    # ===================== –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï –° –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ú =====================\n    def chat_with_user(self, user_message: str, username: str = \"—Å—Ç—Ä–∏–º–µ—Ä\") -> str:\n        \"\"\"\n        –ü—Ä—è–º–æ–π –¥–∏–∞–ª–æ–≥ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º\n        \n        Args:\n            user_message: –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            username: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            \n        Returns:\n            str: –û—Ç–≤–µ—Ç –ò—Ä–∏—Å\n        \"\"\"\n        prompt = f\"{username} –≥–æ–≤–æ—Ä–∏—Ç —Ç–µ–±–µ: {user_message}\"\n        \n        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–æ–æ–±—â–µ–Ω–∏—è\n        user_lower = user_message.lower()\n        \n        if any(word in user_lower for word in ['–ø—Ä–∏–≤–µ—Ç', '–∑–¥–∞—Ä–æ–≤', 'hi', 'hello']):\n            event_type = EventType.CHAT_MESSAGE\n            self.stream_context['mood'] = Mood.HAPPY\n        elif any(word in user_lower for word in ['–∫–∞–∫ –¥–µ–ª–∞', '–∫–∞–∫ —Ç—ã', 'how are']):\n            event_type = EventType.CHAT_MESSAGE\n        elif '?' in user_message:\n            event_type = EventType.COMMAND\n        else:\n            event_type = EventType.GENERAL\n        \n        return self.generate_response(prompt, event_type, force=True)\n    \n    def generate_random_comment(self) -> Optional[str]:\n        \"\"\"\n        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –æ —Å—Ç—Ä–∏–º–µ\n        \n        Returns:\n            Optional[str]: –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∏–ª–∏ None\n        \"\"\"\n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if not self._can_respond(EventType.RANDOM_COMMENT):\n            return None\n        \n        # –®–∞–Ω—Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π\n        if random.random() > 0.25:  # 25% —à–∞–Ω—Å\n            return None\n        \n        # –í—ã–±–æ—Ä —Ç–∏–ø–∞ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è\n        comment_type = random.choice(['game', 'stream', 'question', 'observation'])\n        \n        if comment_type == 'game':\n            prompts = [\n                \"–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä–æ–≤–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏.\",\n                \"–ß—Ç–æ —Ç—ã –¥—É–º–∞–µ—à—å –æ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–º–∞–Ω–¥—ã?\",\n                \"–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π —Ç–µ–∫—É—â–∏–π —Å—á—ë—Ç –∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã –º–∞—Ç—á–∞.\",\n                \"–ó–∞–º–µ—Ç–∫–∞ –æ–± –∏–≥—Ä–µ –∏–ª–∏ —Ç–∞–∫—Ç–∏–∫–µ.\"\n            ]\n        elif comment_type == 'stream':\n            prompts = [\n                \"–°–∫–∞–∂–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –∞—Ç–º–æ—Å—Ñ–µ—Ä–µ —Å—Ç—Ä–∏–º–∞ —Å–µ–≥–æ–¥–Ω—è.\",\n                \"–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π –∫–∞—á–µ—Å—Ç–≤–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ.\",\n                \"–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç—Ä–∏–º–µ –∏–ª–∏ –∑—Ä–∏—Ç–µ–ª—è—Ö.\",\n                \"–°–ª—É—á–∞–π–Ω–∞—è –º—ã—Å–ª—å –æ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–º —ç—Ñ–∏—Ä–µ.\"\n            ]\n        elif comment_type == 'question':\n            prompts = [\n                \"–ó–∞–¥–∞–π —Å—Ç—Ä–∏–º–µ—Ä—É –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ –µ–≥–æ —Ç–∞–∫—Ç–∏–∫–µ.\",\n                \"–°–ø—Ä–æ—Å–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –ø–ª–∞–Ω–∞—Ö –Ω–∞ –∏–≥—Ä—É.\",\n                \"–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ CS2 –∏–ª–∏ —Ç–µ–∫—É—â–µ–º –º–∞—Ç—á–µ.\",\n                \"–°–ø—Ä–æ—Å–∏ –º–Ω–µ–Ω–∏–µ –æ –ø–æ—Å–ª–µ–¥–Ω–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤ –∏–≥—Ä–µ.\"\n            ]\n        else:  # observation\n            prompts = [\n                \"–ü–æ–¥–µ–ª–∏—Å—å –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ–º –æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ä–∞—É–Ω–¥–∞—Ö.\",\n                \"–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ –∏–≥—Ä–æ–∫–∞.\",\n                \"–ù–∞–±–ª—é–¥–µ–Ω–∏–µ –æ –∫–∞—Ä—Ç–µ –∏–ª–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏.\",\n                \"–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ –º–µ—Ç–∞-–∏–≥—Ä–µ –∏–ª–∏ —Ç—Ä–µ–Ω–¥–∞—Ö.\"\n            ]\n        \n        prompt = random.choice(prompts)\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è\n        self.stream_context['mood'] = random.choice([\n            Mood.NEUTRAL, Mood.FUNNY, Mood.SUPPORTIVE\n        ])\n        \n        return self.generate_response(prompt, EventType.RANDOM_COMMENT)\n    \n    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–û–ù–¢–ï–ö–°–¢–û–ú =====================\n    def update_context(self, \n                      map_name: Optional[str] = None,\n                      ct_score: Optional[int] = None,\n                      t_score: Optional[int] = None,\n                      round_number: Optional[int] = None,\n                      player_stats: Optional[Dict] = None,\n                      event: Optional[Dict] = None,\n                      chat_activity: Optional[str] = None,\n                      viewer_count: Optional[int] = None):\n        \"\"\"\n        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å—Ç—Ä–∏–º–∞\n        \n        Args:\n            map_name: –ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã\n            ct_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã CT\n            t_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã T\n            round_number: –ù–æ–º–µ—Ä —Ä–∞—É–Ω–¥–∞\n            player_stats: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞\n            event: –°–æ–±—ã—Ç–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é\n            chat_activity: –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —á–∞—Ç–∞ (slow/normal/active/hyper)\n            viewer_count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑—Ä–∏—Ç–µ–ª–µ–π\n        \"\"\"\n        if map_name:\n            self.game_state.map_name = map_name\n            self.stream_context['current_map'] = map_name\n        \n        if ct_score is not None:\n            self.game_state.score_ct = ct_score\n            self.stream_context['score']['ct'] = ct_score\n        \n        if t_score is not None:\n            self.game_state.score_t = t_score\n            self.stream_context['score']['t'] = t_score\n        \n        if round_number is not None:\n            self.stream_context['round_number'] = round_number\n        \n        if player_stats:\n            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞\n            for key, value in player_stats.items():\n                if hasattr(self.player_stats, key):\n                    setattr(self.player_stats, key, value)\n            \n            # –†–∞—Å—á—ë—Ç K/D ratio\n            if self.player_stats.deaths > 0:\n                self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths\n            elif self.player_stats.kills > 0:\n                self.player_stats.kd_ratio = self.player_stats.kills\n        \n        if event:\n            self.stream_context['recent_events'].append(event)\n        \n        if chat_activity:\n            self.stream_context['chat_activity'] = chat_activity\n        \n        if viewer_count is not None:\n            self.stream_context['viewer_count'] = viewer_count\n            \n            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑—Ä–∏—Ç–µ–ª–µ–π\n            if viewer_count > 1000:\n                self.stream_context['mood'] = Mood.EXCITED\n            elif viewer_count > 100:\n                self.stream_context['mood'] = Mood.HAPPY\n    \n    def update_game_state(self, **kwargs):\n        \"\"\"\n        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã\n        \n        Args:\n            **kwargs: –ü–æ–ª—è GameState –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è\n        \"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self.game_state, key):\n                setattr(self.game_state, key, value)\n    \n    def update_player_stats(self, **kwargs):\n        \"\"\"\n        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞\n        \n        Args:\n            **kwargs: –ü–æ–ª—è PlayerStats –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è\n        \"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self.player_stats, key):\n                setattr(self.player_stats, key, value)\n        \n        # –ü–µ—Ä–µ—Å—á—ë—Ç K/D ratio\n        if self.player_stats.deaths > 0:\n            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths\n    \n    # ===================== –£–¢–ò–õ–ò–¢–´ –ò –°–¢–ê–¢–ò–°–¢–ò–ö–ê =====================\n    def get_stats(self) -> Dict:\n        \"\"\"\n        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞–±–æ—Ç—ã Iris Brain\n        \n        Returns:\n            Dict: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n        \"\"\"\n        stats = self.stats.copy()\n        \n        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö\n        stats['conversation_history_size'] = len(self.conversation_history)\n        stats['recent_events_count'] = len(self.stream_context['recent_events'])\n        stats['current_mood'] = self.stream_context['mood'].value\n        stats['uptime'] = time.time() - stats['start_time']\n        stats['responses_per_minute'] = stats['total_responses'] / (stats['uptime'] / 60) if stats['uptime'] > 0 else 0\n        \n        # –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã\n        stats['game_state'] = {\n            'map': self.game_state.map_name,\n            'score': f\"{self.game_state.score_ct}-{self.game_state.score_t}\",\n            'bomb_planted': self.game_state.bomb_planted\n        }\n        \n        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞\n        stats['player_stats'] = asdict(self.player_stats)\n        \n        return stats\n    \n    def save_conversation(self, filename: str = None):\n        \"\"\"\n        –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –≤ —Ñ–∞–π–ª\n        \n        Args:\n            filename: –ò–º—è —Ñ–∞–π–ª–∞ (–µ—Å–ª–∏ None, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)\n        \"\"\"\n        if filename is None:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"iris_conversation_{timestamp}.json\"\n        \n        conversation_data = []\n        for msg in self.conversation_history:\n            conversation_data.append({\n                'role': msg.role,\n                'content': msg.content,\n                'timestamp': msg.timestamp,\n                'time_str': datetime.fromtimestamp(msg.timestamp).strftime(\"%H:%M:%S\")\n            })\n        \n        try:\n            with open(filename, 'w', encoding='utf-8') as f:\n                json.dump(conversation_data, f, ensure_ascii=False, indent=2)\n            logger.info(f\"–ò—Å—Ç–æ—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {filename}\")\n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏: {e}\")\n    \n    def load_conversation(self, filename: str):\n        \"\"\"\n        –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏–∑ —Ñ–∞–π–ª–∞\n        \n        Args:\n            filename: –ò–º—è —Ñ–∞–π–ª–∞\n        \"\"\"\n        try:\n            with open(filename, 'r', encoding='utf-8') as f:\n                conversation_data = json.load(f)\n            \n            self.conversation_history.clear()\n            for msg_data in conversation_data:\n                self.conversation_history.append(\n                    ConversationMessage(\n                        role=msg_data['role'],\n                        content=msg_data['content'],\n                        timestamp=msg_data['timestamp']\n                    )\n                )\n            \n            logger.info(f\"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(conversation_data)} —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ {filename}\")\n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏: {e}\")\n    \n    def clear_history(self):\n        \"\"\"–û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞\"\"\"\n        self.conversation_history.clear()\n        self.stream_context['recent_events'].clear()\n        logger.info(\"–ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞\")\n    \n    def reset_stats(self):\n        \"\"\"–°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\"\"\"\n        self.stats = {\n            'total_responses': 0,\n            'llm_responses': 0,\n            'fallback_responses': 0,\n            'errors': 0,\n            'start_time': time.time()\n        }\n        logger.info(\"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞\")\n    \n    def set_mood(self, mood: Mood):\n        \"\"\"\n        –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å\n        \n        Args:\n            mood: –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –∏–∑ enum Mood\n        \"\"\"\n        self.stream_context['mood'] = mood\n        logger.info(f\"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {mood.value}\")\n    \n    def adjust_cooldown(self, event_type: EventType, cooldown: float):\n        \"\"\"\n        –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞ –¥–ª—è —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            cooldown: –ù–æ–≤—ã–π –∫—É–ª–¥–∞—É–Ω –≤ —Å–µ–∫—É–Ω–¥–∞—Ö\n        \"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        self.cooldowns[event_str] = cooldown\n        logger.info(f\"–ö—É–ª–¥–∞—É–Ω {event_str} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {cooldown}—Å\")\n\n\n# ===================== –ü–†–ò–ú–ï–† –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø =====================\nif __name__ == \"__main__\":\n    print(\"=== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï IRIS BRAIN ===\")\n    \n    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è\n    iris = IrisBrain()\n    \n    print(f\"–†–µ–∂–∏–º –∑–∞–≥–ª—É—à–∫–∏: {iris.fallback_mode}\")\n    print(f\"–ú–æ–¥–µ–ª—å: {iris.model}\")\n    \n    # –¢–µ—Å—Ç–æ–≤—ã–µ –≤—ã–∑–æ–≤—ã\n    print(\"\\n1. –¢–µ—Å—Ç —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è:\")\n    comment = iris.generate_random_comment()\n    print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {comment}\")\n    \n    print(\"\\n2. –¢–µ—Å—Ç —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ:\")\n    kill_response = iris.react_to_kill({\n        'weapon': 'ak47',\n        'headshot': True,\n        'round_kills': 2,\n        'victim': '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫'\n    })\n    print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {kill_response}\")\n    \n    print(\"\\n3. –¢–µ—Å—Ç –¥–∏–∞–ª–æ–≥–∞:\")\n    chat_response = iris.chat_with_user(\"–ü—Ä–∏–≤–µ—Ç, –ò—Ä–∏—Å! –ö–∞–∫ —Ç–≤–æ–∏ –¥–µ–ª–∞?\", \"–¢–µ—Å—Ç–µ—Ä\")\n    print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {chat_response}\")\n    \n    print(\"\\n4. –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:\")\n    stats = iris.get_stats()\n    print(f\"–í—Å–µ–≥–æ –æ—Ç–≤–µ—Ç–æ–≤: {stats['total_responses']}\")\n    print(f\"–û—Ç–≤–µ—Ç–æ–≤ LLM: {stats['llm_responses']}\")\n    print(f\"–ó–∞–≥–ª—É—à–µ–∫: {stats['fallback_responses']}\")\n    \n    print(\"\\n=== –¢–ï–°–¢ –ó–ê–í–ï–†–®–ï–ù ===\")","path":null,"size_bytes":54149,"size_tokens":null},"find_female_voice.py":{"content":"import pyttsx3\n\nengine = pyttsx3.init()\nvoices = engine.getProperty('voices')\n\nprint(f\"üì¢ –î–æ—Å—Ç—É–ø–Ω–æ {len(voices)} –≥–æ–ª–æ—Å–æ–≤:\\n\")\n\nfemale_voices = []\nfor i, voice in enumerate(voices):\n    voice_name = voice.name.lower()\n    is_female = any(keyword in voice_name for keyword in \n                   ['female', '–∂–µ–Ω—Å–∫', 'woman', '–¥–∞–º–∞', '–¥–µ–≤—É—à–∫–∞', 'irina', 'anna', '–º–∞—Ä–∏—è', 'natalia'])\n    \n    status = \"üë© –ñ–ï–ù–°–ö–ò–ô\" if is_female else \"üë® –ú–£–ñ–°–ö–û–ô\"\n    \n    print(f\"{i+1}. {status}: {voice.name}\")\n    print(f\"   ID: {voice.id}\")\n    \n    if is_female:\n        female_voices.append(voice.id)\n    \n    print()\n\nif female_voices:\n    print(f\"\\n‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(female_voices)} –∂–µ–Ω—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤!\")\n    print(f\"–†–µ–∫–æ–º–µ–Ω–¥—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å: {female_voices[0]}\")\nelse:\n    print(\"\\n‚ö†Ô∏è –ñ–µ–Ω—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π\")\n    print(f\"–ü–µ—Ä–≤—ã–π –≥–æ–ª–æ—Å: {voices[0].id}\")","path":null,"size_bytes":1029,"size_tokens":null},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"edge-tts>=7.2.7\",\n    \"flask>=3.1.2\",\n    \"groq>=0.37.1\",\n    \"numpy>=2.3.5\",\n    \"openai>=2.12.0\",\n    \"pygame>=2.6.1\",\n    \"python-dotenv>=1.2.1\",\n    \"requests>=2.32.5\",\n    \"scipy>=1.16.3\",\n    \"speechrecognition>=3.14.4\",\n    \"trafilatura>=2.0.0\",\n    \"websocket-client>=1.9.0\",\n]\n","path":null,"size_bytes":433,"size_tokens":null},"src/streamelements_client.py":{"content":"import os\nimport json\nimport time\nimport threading\nimport websocket\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Callable, Dict, List, Any\nfrom collections import deque\n\n@dataclass\nclass StreamEvent:\n    event_type: str\n    data: Dict[str, Any]\n    timestamp: float = field(default_factory=time.time)\n\nclass StreamElementsClient:\n    WS_URL = \"wss://realtime.streamelements.com/socket.io/?EIO=4&transport=websocket\"\n    \n    def __init__(self, \n                 jwt_token: Optional[str] = None,\n                 event_callback: Optional[Callable[[StreamEvent], None]] = None):\n        \n        self.jwt_token = jwt_token or os.getenv('STREAMELEMENTS_JWT_TOKEN', '')\n        self.event_callback = event_callback\n        \n        self.ws = None\n        self.is_connected = False\n        self.reconnect_delay = 5\n        self.max_reconnect_delay = 60\n        \n        self.events_history: deque = deque(maxlen=500)\n        self.chat_history: deque = deque(maxlen=100)\n        \n        self.viewer_stats = {\n            'total_tips': 0,\n            'total_subs': 0,\n            'total_followers': 0,\n            'top_donator': None,\n            'recent_events': []\n        }\n        \n        self.ws_thread = None\n        self.heartbeat_thread = None\n        \n    def connect(self):\n        if not self.jwt_token:\n            print(\"[StreamElements] JWT —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!\")\n            return False\n            \n        self.ws = websocket.WebSocketApp(\n            self.WS_URL,\n            on_open=self._on_open,\n            on_message=self._on_message,\n            on_error=self._on_error,\n            on_close=self._on_close\n        )\n        \n        self.ws_thread = threading.Thread(target=self._run_forever, daemon=True)\n        self.ws_thread.start()\n        return True\n        \n    def _run_forever(self):\n        while True:\n            try:\n                self.ws.run_forever()\n            except Exception as e:\n                print(f\"[StreamElements] –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {e}\")\n                \n            if not self.is_connected:\n                break\n                \n            print(f\"[StreamElements] –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {self.reconnect_delay} —Å–µ–∫...\")\n            time.sleep(self.reconnect_delay)\n            self.reconnect_delay = min(self.reconnect_delay * 2, self.max_reconnect_delay)\n            \n    def _on_open(self, ws):\n        print(\"[StreamElements] WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ\")\n        self._authenticate()\n        self._start_heartbeat()\n        \n    def _authenticate(self):\n        auth_message = json.dumps({\n            \"method\": \"jwt\",\n            \"token\": self.jwt_token\n        })\n        self.ws.send(f\"42{auth_message}\")\n        print(\"[StreamElements] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω –∑–∞–ø—Ä–æ—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏\")\n        \n    def _start_heartbeat(self):\n        def heartbeat():\n            while self.is_connected:\n                try:\n                    self.ws.send(\"2\")\n                    time.sleep(25)\n                except:\n                    break\n                    \n        self.heartbeat_thread = threading.Thread(target=heartbeat, daemon=True)\n        self.heartbeat_thread.start()\n        \n    def _on_message(self, ws, message: str):\n        try:\n            if message.startswith('0'):\n                self.is_connected = True\n                self.reconnect_delay = 5\n                print(\"[StreamElements] –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É\")\n                return\n                \n            if message.startswith('40'):\n                print(\"[StreamElements] –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!\")\n                return\n                \n            if message.startswith('42'):\n                data_str = message[2:]\n                try:\n                    data = json.loads(data_str)\n                    if isinstance(data, list) and len(data) >= 2:\n                        event_type = data[0]\n                        event_data = data[1] if len(data) > 1 else {}\n                        self._handle_event(event_type, event_data)\n                except json.JSONDecodeError:\n                    pass\n                return\n                \n            if message == '3':\n                return\n                \n        except Exception as e:\n            print(f\"[StreamElements] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}\")\n            \n    def _handle_event(self, event_type: str, event_data: Dict):\n        stream_event = StreamEvent(event_type=event_type, data=event_data)\n        self.events_history.append(stream_event)\n        \n        if event_type == 'event':\n            self._process_stream_event(event_data)\n        elif event_type == 'event:test':\n            self._process_stream_event(event_data)\n        elif event_type == 'message':\n            self._process_chat_message(event_data)\n            \n    def _process_stream_event(self, data: Dict):\n        listener = data.get('listener', '')\n        event_data = data.get('event', data)\n        \n        if listener == 'tip' or data.get('type') == 'tip':\n            self._handle_tip(event_data)\n        elif listener == 'subscriber' or data.get('type') == 'subscriber':\n            self._handle_subscriber(event_data)\n        elif listener == 'follower' or data.get('type') == 'follower':\n            self._handle_follower(event_data)\n        elif listener == 'raid' or data.get('type') == 'raid':\n            self._handle_raid(event_data)\n        elif listener == 'cheer' or data.get('type') == 'cheer':\n            self._handle_cheer(event_data)\n        elif listener == 'host' or data.get('type') == 'host':\n            self._handle_host(event_data)\n            \n    def _process_chat_message(self, data: Dict):\n        username = data.get('displayName', data.get('username', '–ê–Ω–æ–Ω–∏–º'))\n        message = data.get('message', data.get('text', ''))\n        \n        chat_event = {\n            'username': username,\n            'message': message,\n            'timestamp': time.time(),\n            'badges': data.get('badges', []),\n            'emotes': data.get('emotes', [])\n        }\n        \n        self.chat_history.append(chat_event)\n        \n        stream_event = StreamEvent(\n            event_type='chat_message',\n            data=chat_event\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–ß–ê–¢] {username}: {message}\")\n        \n    def _handle_tip(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        amount = data.get('amount', 0)\n        currency = data.get('currency', 'USD')\n        tip_message = data.get('message', '')\n        \n        self.viewer_stats['total_tips'] += amount\n        \n        if not self.viewer_stats['top_donator'] or amount > self.viewer_stats['top_donator'].get('amount', 0):\n            self.viewer_stats['top_donator'] = {'username': username, 'amount': amount}\n            \n        stream_event = StreamEvent(\n            event_type='donation',\n            data={\n                'username': username,\n                'amount': amount,\n                'currency': currency,\n                'message': tip_message,\n                'formatted': f\"{amount} {currency}\"\n            }\n        )\n        \n        self.viewer_stats['recent_events'].append(stream_event)\n        if len(self.viewer_stats['recent_events']) > 20:\n            self.viewer_stats['recent_events'].pop(0)\n            \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–î–û–ù–ê–¢] {username}: {amount} {currency} - {tip_message}\")\n        \n    def _handle_subscriber(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        tier = data.get('tier', '1000')\n        months = data.get('amount', data.get('months', 1))\n        is_gift = data.get('gifted', False)\n        gifter = data.get('sender', '')\n        \n        self.viewer_stats['total_subs'] += 1\n        \n        tier_name = {'1000': 'Tier 1', '2000': 'Tier 2', '3000': 'Tier 3'}.get(str(tier), 'Tier 1')\n        \n        stream_event = StreamEvent(\n            event_type='subscription',\n            data={\n                'username': username,\n                'tier': tier_name,\n                'months': months,\n                'is_gift': is_gift,\n                'gifter': gifter,\n                'message': data.get('message', '')\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        if is_gift:\n            print(f\"[–ü–û–î–ü–ò–°–ö–ê] {gifter} –ø–æ–¥–∞—Ä–∏–ª –ø–æ–¥–ø–∏—Å–∫—É {username} ({tier_name})\")\n        else:\n            print(f\"[–ü–û–î–ü–ò–°–ö–ê] {username} –ø–æ–¥–ø–∏—Å–∞–ª—Å—è! ({tier_name}, {months} –º–µ—Å.)\")\n            \n    def _handle_follower(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        \n        self.viewer_stats['total_followers'] += 1\n        \n        stream_event = StreamEvent(\n            event_type='follow',\n            data={'username': username}\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–§–û–õ–õ–û–£] {username} –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –Ω–∞ –∫–∞–Ω–∞–ª!\")\n        \n    def _handle_raid(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        viewers = data.get('amount', data.get('viewers', 0))\n        \n        stream_event = StreamEvent(\n            event_type='raid',\n            data={\n                'username': username,\n                'viewers': viewers\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–†–ï–ô–î] {username} –≤–æ—Ä–≤–∞–ª—Å—è —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏!\")\n        \n    def _handle_cheer(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        amount = data.get('amount', 0)\n        message = data.get('message', '')\n        \n        stream_event = StreamEvent(\n            event_type='cheer',\n            data={\n                'username': username,\n                'bits': amount,\n                'message': message\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–ë–ò–¢–´] {username}: {amount} –±–∏—Ç–æ–≤ - {message}\")\n        \n    def _handle_host(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        viewers = data.get('amount', data.get('viewers', 0))\n        \n        stream_event = StreamEvent(\n            event_type='host',\n            data={\n                'username': username,\n                'viewers': viewers\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–•–û–°–¢] {username} —Ö–æ—Å—Ç–∏—Ç –∫–∞–Ω–∞–ª —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏!\")\n        \n    def _on_error(self, ws, error):\n        print(f\"[StreamElements] –û—à–∏–±–∫–∞: {error}\")\n        \n    def _on_close(self, ws, close_status_code, close_msg):\n        self.is_connected = False\n        print(f\"[StreamElements] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ: {close_status_code} - {close_msg}\")\n        \n    def disconnect(self):\n        self.is_connected = False\n        if self.ws:\n            self.ws.close()\n            \n    def get_chat_history(self, limit: int = 50) -> List[Dict]:\n        return list(self.chat_history)[-limit:]\n        \n    def get_recent_events(self, limit: int = 20) -> List[StreamEvent]:\n        return list(self.events_history)[-limit:]\n        \n    def get_viewer_stats(self) -> Dict:\n        return self.viewer_stats.copy()\n","path":null,"size_bytes":11879,"size_tokens":null},"replit.md":{"content":"# –ò—Ä–∏—Å - AI Stream Companion\n\n## –û–ø–∏—Å–∞–Ω–∏–µ\n–ò—Ä–∏—Å ‚Äî —ç—Ç–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∏ —Å–æ-–≤–µ–¥—É—â–∞—è –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤. –û–Ω–∞ —É–º–µ–µ—Ç:\n- –†–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏—è –≤ CS2 (—É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, clutch, ace, –±–æ–º–±–∞)\n- –ß–∏—Ç–∞—Ç—å —á–∞—Ç –∏ –æ—Ç–≤–µ—á–∞—Ç—å –∑—Ä–∏—Ç–µ–ª—è–º —á–µ—Ä–µ–∑ StreamElements\n- –ë–ª–∞–≥–æ–¥–∞—Ä–∏—Ç—å –∑–∞ –¥–æ–Ω–∞—Ç—ã –∏ –ø–æ–¥–ø–∏—Å–∫–∏\n- –£–ø—Ä–∞–≤–ª—è—Ç—å –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –≥–æ–ª–æ—Å–æ–º\n- –í–µ—Å—Ç–∏ –∂–∏–≤–æ–π —Ä–∞–∑–≥–æ–≤–æ—Ä —Å–æ —Å—Ç—Ä–∏–º–µ—Ä–æ–º\n- –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å—Ç—Ä–∏–º–∞\n\n## üå∏ –ß—Ç–æ –Ω–æ–≤–æ–≥–æ (–í–µ—Ä—Å–∏—è 2.0 - –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è)\n\n### –ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:\n- **Edge TTS** - –Ω–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å (–≤–º–µ—Å—Ç–æ OpenAI TTS)\n- **Vosk** - –æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ (–≤–º–µ—Å—Ç–æ Whisper API)\n- **Groq LLM** - –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI –¥–ª—è –æ—Ç–≤–µ—Ç–æ–≤ (–≤–º–µ—Å—Ç–æ GPT-4o)\n- **Google Speech** - –æ–Ω–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤\n\n### –£–ª—É—á—à–µ–Ω–∏—è –≥–æ–ª–æ—Å–∞:\n- –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å (ru-RU-SvetlanaNeural)\n- –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏ (—Ä–∞–¥–æ—Å—Ç—å, –ø–æ–¥–¥–µ—Ä–∂–∫–∞, –≤–æ–ª–Ω–µ–Ω–∏–µ)\n- –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏ —Ç–æ–Ω —Ä–µ—á–∏\n- –ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–∞—É–∑—ã –º–µ–∂–¥—É –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º–∏\n\n### –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ wake-word \"–ò—Ä–∏—Å\":\n- Fuzzy matching –¥–ª—è –ø–æ—Ö–æ–∂–∏—Ö —Å–ª–æ–≤\n- –í–∞—Ä–∏–∞–Ω—Ç—ã: \"–∏—Ä–∏—Å\", \"iris\", \"–∏—Ä–∏—Å–∫–∞\", \"–∞–π—Ä–∏—Å\" –∏ –¥—Ä.\n- –í—ã—Å–æ–∫–∞—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫ –±—ã—Å—Ç—Ä–æ–π —Ä–µ—á–∏\n- –û—Ñ–ª–∞–π–Ω —Ä–∞–±–æ—Ç–∞ —Å Vosk\n\n## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n\n```\nsrc/\n‚îú‚îÄ‚îÄ tts_engine.py         # Edge TTS –¥–ª—è –Ω–µ–∂–Ω–æ–≥–æ –∂–µ–Ω—Å–∫–æ–≥–æ –≥–æ–ª–æ—Å–∞\n‚îú‚îÄ‚îÄ voice_input.py        # Vosk/Google —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏\n‚îú‚îÄ‚îÄ cs2_gsi.py           # CS2 Game State Integration —Å–µ—Ä–≤–µ—Ä\n‚îú‚îÄ‚îÄ streamelements_client.py  # StreamElements WebSocket –∫–ª–∏–µ–Ω—Ç\n‚îú‚îÄ‚îÄ iris_brain.py        # Groq LLM –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤\n‚îú‚îÄ‚îÄ windows_audio.py     # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π\n‚îú‚îÄ‚îÄ achievements.py      # –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ tts_utils.py     # –£—Ç–∏–ª–∏—Ç—ã —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏\n‚îî‚îÄ‚îÄ __init__.py\n\nmain.py                  # –ì–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª –∑–∞–ø—É—Å–∫–∞\n```\n\n## –ù–∞—Å—Ç—Ä–æ–π–∫–∞\n\n### –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Å–µ–∫—Ä–µ—Ç—ã:\n- `GROQ_API_KEY` - –∫–ª—é—á Groq API (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π, –¥–ª—è AI –æ—Ç–≤–µ—Ç–æ–≤)\n- `STREAMELEMENTS_JWT_TOKEN` - JWT —Ç–æ–∫–µ–Ω StreamElements (–¥–ª—è —á–∞—Ç–∞)\n\n### –ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å Groq API –∫–ª—é—á (–±–µ—Å–ø–ª–∞—Ç–Ω–æ):\n1. –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ https://console.groq.com\n2. –°–æ–∑–¥–∞–π—Ç–µ API –∫–ª—é—á\n3. –î–æ–±–∞–≤—å—Ç–µ –≤ —Å–µ–∫—Ä–µ—Ç—ã Replit\n\n### CS2 Game State Integration:\n1. –ü—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Å–æ–∑–¥–∞—ë—Ç—Å—è —Ñ–∞–π–ª `gamestate_integration_iris.cfg`\n2. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤ `<Steam>/steamapps/common/Counter-Strike Global Offensive/game/csgo/cfg/`\n3. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ CS2\n\n## –§—É–Ω–∫—Ü–∏–∏\n\n### üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ\n- –°–∫–∞–∂–∏—Ç–µ \"–ò—Ä–∏—Å\" –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏\n- –ö–æ–º–∞–Ω–¥—ã: \"—Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ\", \"–≤—ã–∫–ª—é—á–∏ –¥–∏—Å–∫–æ—Ä–¥\", \"–≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ 50%\"\n- –ü–æ–¥–¥–µ—Ä–∂–∫–∞: \"–ø—Ä–∏–≤–µ—Ç\", \"–∫–∞–∫ –¥–µ–ª–∞\", \"—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\", \"–¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è\"\n\n### üéÆ CS2 –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è\n- –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –ø—Ä–∏ —É–±–∏–π—Å—Ç–≤–∞—Ö, —Å–º–µ—Ä—Ç—è—Ö, clutch —Å–∏—Ç—É–∞—Ü–∏—è—Ö\n- –†–µ–∞–∫—Ü–∏–∏ –Ω–∞ –±–æ–º–±—É, —Ä–∞—É–Ω–¥—ã, MVP\n- –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —é–º–æ—Ä –∏ —ç–º–æ—Ü–∏–∏\n- –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∏—Ç—É–∞—Ü–∏–∏\n\n### üí¨ StreamElements\n- –ß—Ç–µ–Ω–∏–µ —á–∞—Ç–∞ –∏ –æ—Ç–≤–µ—Ç—ã –∑—Ä–∏—Ç–µ–ª—è–º\n- –ë–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç–∏ –∑–∞ –¥–æ–Ω–∞—Ç—ã —Å —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º —Å—É–º–º—ã\n- –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –∏ —Ä–µ–π–¥–æ–≤\n\n### üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è\n- 20+ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è\n- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è –≥–æ–ª–æ—Å–æ–º\n- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤ stream_stats.json\n\n## –ì–æ–ª–æ—Å–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n\n### –î–æ—Å—Ç—É–ø–Ω—ã–µ –≥–æ–ª–æ—Å–∞:\n- `ru_female_soft` - –°–≤–µ—Ç–ª–∞–Ω–∞ (–º—è–≥–∫–∏–π, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)\n- `ru_female_warm` - –î–∞—Ä—å—è (—Ç—ë–ø–ª—ã–π)\n- `ru_male` - –î–º–∏—Ç—Ä–∏–π\n- `en_female_soft` - Jenny (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π)\n- `en_female_warm` - Aria (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π)\n\n### –≠–º–æ—Ü–∏–∏:\n- `neutral` - –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π\n- `excited` - –≤–æ–∑–±—É–∂–¥—ë–Ω–Ω—ã–π\n- `happy` - —Ä–∞–¥–æ—Å—Ç–Ω—ã–π\n- `sad` - –≥—Ä—É—Å—Ç–Ω—ã–π\n- `supportive` - –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–π\n- `gentle` - –Ω–µ–∂–Ω—ã–π\n- `tense` - –Ω–∞–ø—Ä—è–∂—ë–Ω–Ω—ã–π\n\n## –ó–∞–ø—É—Å–∫\n\n```bash\npython main.py\n```\n\n## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞\n\n### Windows:\n- Python 3.9+\n- –ú–∏–∫—Ä–æ—Ñ–æ–Ω\n- –î–∏–Ω–∞–º–∏–∫–∏/–Ω–∞—É—à–Ω–∏–∫–∏\n- CS2 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)\n\n### –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:\n```bash\npip install edge-tts pygame vosk groq flask websockets python-dotenv sounddevice SpeechRecognition\n```\n\n### –î–ª—è Vosk (–æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ):\n```bash\n# –°–∫–∞—á–∞–π—Ç–µ —Ä—É—Å—Å–∫—É—é –º–æ–¥–µ–ª—å\nwget https://alphacephei.com/vosk/models/vosk-model-small-ru-0.22.zip\nunzip vosk-model-small-ru-0.22.zip -d models/\n```\n\n## –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏\n\n- Python 3.11\n- Edge TTS (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ Microsoft)\n- Vosk (–æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏)\n- Groq LLM (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI)\n- Flask (HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è CS2 GSI)\n- WebSocket (StreamElements)\n- pygame (–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ)\n\n## –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n- –¢–æ–ª—å–∫–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã\n- –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å\n- –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ wake-word\n- –ö—Ä–æ—Å—Å–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ—Å—Ç—å (Windows, Linux, macOS)\n","path":null,"size_bytes":6318,"size_tokens":null}},"version":2}
</file>

<file path="iris_config.json">
{
  "iris_config": {
    "mode": "hybrid",
    "streamer_name": "–ö–∏—Ä", 
    "enable_voice": true,
    "enable_learning": true,
    "api_key": "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",
    "gsi_port": 3000,
    "voice_engine": "pyttsx3",
    
    "emotion_settings": {
      "default_emotion": "neutral",
      "emotion_transition_speed": 0.3,
      "max_emotion_intensity": 0.9
    },
    
    "memory_settings": {
      "max_memory_entries": 1000,
      "auto_save_interval": 300,
      "short_term_memory_size": 20
    },
    
    "stream_settings": {
      "cooldowns": {
        "kill": 3.0,
        "death": 5.0,
        "round_end": 2.0,
        "chat_message": 8.0
      },
      "chat_response_chance": 0.2,
      "min_chat_length": 2
    },
    
    "voice_settings": {
      "wake_word": "–∏—Ä–∏—Å",
      "wake_word_variants": ["–∏—Ä–∏—Å", "iris", "–∏—Ä–∏—Å–∫–∞"],
      "listen_timeout": 10,
      "speech_speed": 1.0,
      "voice_gender": "female"
    },
    
    "learning_settings": {
      "auto_learn": true,
      "training_interval": 300,
      "min_samples_for_training": 10
    },
    
    "paths": {
      "models": "./models",
      "profiles": "./profiles",
      "memory": "./memory",
      "logs": "./logs"
    }
  }
}
</file>

<file path="temp_repo/.local/state/replit/agent/.latest.json">
{"latest": "main"}
</file>

<file path=".gitignore">

</file>

<file path="attached_assets/Pasted--Iris-PC-Goal-Iris-AI--1766234366083_1766234366083.txt">
# Iris ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π/PC –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç
Goal:
–°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–µ–∫—Ç Iris ‚Äî –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π:
- –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç CS2 –º–∞—Ç—á –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ –∏–∑ GSI
- –û–±—â–∞–µ—Ç—Å—è –∂–∏–≤–æ, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥/–≤—ã–≤–æ–¥
- –£–ø—Ä–∞–≤–ª—è–µ—Ç –±–∞–∑–æ–≤—ã–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –ü–ö (–≥—Ä–æ–º–∫–æ—Å—Ç—å, –º—É–∑—ã–∫–∞ –∏ –¥—Ä.)
- –ú–æ–∂–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è —Å–æ —Å—Ç—Ä–∏–º-—á–∞—Ç–æ–º (StreamElements)
- –ò–º–µ–µ—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä, —é–º–æ—Ä –∏ –≥–∏–±–∫–æ—Å—Ç—å

Requirements:

1) –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- –†–∞–∑–¥–µ–ª–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –Ω–∞ –º–æ–¥—É–ª–∏: core, gsi, speech, actions, stream
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å async —Å–µ—Ä–≤–µ—Ä –¥–ª—è GSI
- –û—á–∏—Å—Ç–∏—Ç—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –æ—Ç –ª–æ–≥–æ–≤/–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤

2) –ú–æ–¥–µ–ª—å –æ–±—â–µ–Ω–∏—è
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —è–∑—ã–∫–æ–≤—É—é –º–æ–¥–µ–ª—å (Qwen3 –∏–ª–∏ –≤—ã—à–µ)
- Context manager ‚Äî –∏—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
- –ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Å–∫—Ä–∏–ø—Ç—ã

3) Speech
- ASR: VOSK/Whisper-tiny (–±–µ—Å–ø–ª–∞—Ç–Ω–æ) ( –æ–Ω —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω vosk-model-ru-0.22)
- TTS: Coqui/Mozilla TTS
- –ñ–∏–≤–æ–π –≥–æ–ª–æ—Å, –ø—Ä–∏—è—Ç–Ω—ã–π —Ç–µ–º–±—Ä

4) Game State Integration (CS2)
- Parse events ‚Üí update context
- Fast updates (async)
- Separate player context

5) PC Integration
- Volume control
- Music controls
- App launch/close

6) Stream Support
- StreamElements API
- Chat read & respond

7) Personality
- Humor engine
- Custom tone

Constraints:
- –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∏ –º–æ–¥–µ–ª–∏ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –ø–ª–∞—Ç–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã

—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –Ω–∞ –ø—Ä–æ–µ–∫—Ç —Å–∫–∏–Ω—É–ª –Ω–∏–∂–µ

https://github.com/lleevinn/sat_name_v6

ollama —É –º–µ–Ω—è —Å–∫–∞—á–∞–Ω–∞ –∏ –º–æ–¥–µ–ª—å —Å—Ç–æ–∏—Ç qwen3:4b-instructor
–¥–æ–±–∞–≤–ª—è–π –±–æ–ª—å—à–µ —Ñ–∏—à–µ–∫, —Ñ—É–Ω–∫—Ü–∏–π, –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, —è –¥–∞—é —Ç–µ–±–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–≤–æ—Ä—á–µ—Å–∫–∏—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π, –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –ø—Ä–æ—Å—Ç–æ –±–æ—Ç, –∞ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–µ–∫—Ç, –∂–∏–≤–æ–π, —Å–º–µ—à–Ω–æ–π –∏ —Ç–¥, –∞ –∫–æ–≥–¥–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ–±—Å—Ç–æ—è—Ç–µ–ª—å—Å—Ç–≤–∞, —Ç–∏–ø–æ —É—Ä–æ–Ω–∞ –º–∞–ª–æ –∏–ª–∏ –ø–∞—Ç—Ä–æ–Ω, –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—Ç—å –æ–± —ç—Ç–æ–º —Å—Ä–∞–∑—É. –¢–≤–æ—Ä–∏ –±—Ä–∞—Ç–∏–∫))
–æ—Ç–¥–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–π .env —á—Ç–æ–±—ã —è –º–æ–≥ –∑–∞–Ω–µ—Å—Ç–∏ —Ç—É–¥–∞ –∫–ª—é—á–∏ STREAMELEMENTS_JWT_TOKEN
LOG_LEVEL=INFO

–ò –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω–µ web-–≤–µ—Ä—Å–∏—è, –∞ –ª–æ–∫–∞–ª—å–Ω–∞—è
–æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫–∞–∫ –¥–∂–∞—Ä–≤–∏—Å, —Ç–æ–ª—å–∫–æ –ò—Ä–∏—Å —Å –≤–∏–∑—É–∞–ª—å–Ω—ã–º–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏ –≤ —Å—Ç–∏–ª–µ io –∏–∑ –¥–æ—Ç—ã ( —Ç–æ–ª—å–∫–æ –±–µ–∑ –±—Ä–æ–≤–µ–π —Å–≤–µ—Ä—Ö—É –≥–¥–µ –∑–∞–∫—Ä—ã—Ç—å —Å–≤–µ—Ä–Ω—É—Ç—å –∏ —Ç–¥.
—Ç–∞–∫–∂–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∞—É–¥–∏–æ —ç—Ñ—Ñ–µ–∫—Ç—ã —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞—é—â–∏–µ, –∫–æ–≥–¥–∞ —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è, —á—Ç–æ –æ–Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç, —á—Ç–æ —Å–∏—Å—Ç–µ–º–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –≤—Å—è–∫–∏–µ —Ç–∞–∫–∏–µ –∑–≤—É–∫–∏ –∫–ª–∞—Å—Å–Ω—ã–µ)

https://github.com/lleevinn/sat_name_v6
—è —Å–¥–µ–ª–∞–ª –ø—Ä–æ–µ–∫—Ç –Ω–∞ –∫–æ–ª–µ–Ω–∫–µ, –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –µ–≥–æ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
–°–æ–±–µ—Ä–∏ –≤—Å—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É, —Å–æ–∑–¥–∞–π –∏–∑ —ç—Ç–æ–≥–æ –∞–ª–º–∞–∑.
—É –º–µ–Ω—è windows
–≤—Å—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é —Ç—ã –Ω–∞–π–¥–µ—à—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
–∏ –∫–æ–Ω–µ—á–Ω–æ –∂–µ –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ–π –Ω–µ WEB –∞ –ª–æ–∫–∞–ª—å–Ω–∞—è –≤ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ —á–µ—Ä–µ–∑ main.py –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è
</file>

<file path="attached_assets/Pasted--Iris-PC-Goal-Iris-AI--1766234427002_1766234427002.txt">
# Iris ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π/PC –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç
Goal:
–°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–µ–∫—Ç Iris ‚Äî –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π:
- –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç CS2 –º–∞—Ç—á –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ –∏–∑ GSI
- –û–±—â–∞–µ—Ç—Å—è –∂–∏–≤–æ, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥/–≤—ã–≤–æ–¥
- –£–ø—Ä–∞–≤–ª—è–µ—Ç –±–∞–∑–æ–≤—ã–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –ü–ö (–≥—Ä–æ–º–∫–æ—Å—Ç—å, –º—É–∑—ã–∫–∞ –∏ –¥—Ä.)
- –ú–æ–∂–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è —Å–æ —Å—Ç—Ä–∏–º-—á–∞—Ç–æ–º (StreamElements)
- –ò–º–µ–µ—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä, —é–º–æ—Ä –∏ –≥–∏–±–∫–æ—Å—Ç—å

Requirements:

1) –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- –†–∞–∑–¥–µ–ª–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –Ω–∞ –º–æ–¥—É–ª–∏: core, gsi, speech, actions, stream
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å async —Å–µ—Ä–≤–µ—Ä –¥–ª—è GSI
- –û—á–∏—Å—Ç–∏—Ç—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –æ—Ç –ª–æ–≥–æ–≤/–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤

2) –ú–æ–¥–µ–ª—å –æ–±—â–µ–Ω–∏—è
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —è–∑—ã–∫–æ–≤—É—é –º–æ–¥–µ–ª—å (Qwen3 –∏–ª–∏ –≤—ã—à–µ)
- Context manager ‚Äî –∏—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
- –ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Å–∫—Ä–∏–ø—Ç—ã

3) Speech
- ASR: VOSK/Whisper-tiny (–±–µ—Å–ø–ª–∞—Ç–Ω–æ) ( –æ–Ω —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω vosk-model-ru-0.22)
- TTS: Coqui/Mozilla TTS
- –ñ–∏–≤–æ–π –≥–æ–ª–æ—Å, –ø—Ä–∏—è—Ç–Ω—ã–π —Ç–µ–º–±—Ä

4) Game State Integration (CS2)
- Parse events ‚Üí update context
- Fast updates (async)
- Separate player context

5) PC Integration
- Volume control
- Music controls
- App launch/close

6) Stream Support
- StreamElements API
- Chat read & respond

7) Personality
- Humor engine
- Custom tone

Constraints:
- –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∏ –º–æ–¥–µ–ª–∏ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –ø–ª–∞—Ç–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã

—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –Ω–∞ –ø—Ä–æ–µ–∫—Ç —Å–∫–∏–Ω—É–ª –Ω–∏–∂–µ

https://github.com/lleevinn/sat_name_v6

ollama —É –º–µ–Ω—è —Å–∫–∞—á–∞–Ω–∞ –∏ –º–æ–¥–µ–ª—å —Å—Ç–æ–∏—Ç qwen3:4b-instructor
–¥–æ–±–∞–≤–ª—è–π –±–æ–ª—å—à–µ —Ñ–∏—à–µ–∫, —Ñ—É–Ω–∫—Ü–∏–π, –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, —è –¥–∞—é —Ç–µ–±–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–≤–æ—Ä—á–µ—Å–∫–∏—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π, –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –ø—Ä–æ—Å—Ç–æ –±–æ—Ç, –∞ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–µ–∫—Ç, –∂–∏–≤–æ–π, —Å–º–µ—à–Ω–æ–π –∏ —Ç–¥, –∞ –∫–æ–≥–¥–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ–±—Å—Ç–æ—è—Ç–µ–ª—å—Å—Ç–≤–∞, —Ç–∏–ø–æ —É—Ä–æ–Ω–∞ –º–∞–ª–æ –∏–ª–∏ –ø–∞—Ç—Ä–æ–Ω, –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—Ç—å –æ–± —ç—Ç–æ–º —Å—Ä–∞–∑—É. –¢–≤–æ—Ä–∏ –±—Ä–∞—Ç–∏–∫))
–æ—Ç–¥–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–π .env —á—Ç–æ–±—ã —è –º–æ–≥ –∑–∞–Ω–µ—Å—Ç–∏ —Ç—É–¥–∞ –∫–ª—é—á–∏ STREAMELEMENTS_JWT_TOKEN
LOG_LEVEL=INFO

–ò –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω–µ web-–≤–µ—Ä—Å–∏—è, –∞ –ª–æ–∫–∞–ª—å–Ω–∞—è
–æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫–∞–∫ –¥–∂–∞—Ä–≤–∏—Å, —Ç–æ–ª—å–∫–æ –ò—Ä–∏—Å —Å –≤–∏–∑—É–∞–ª—å–Ω—ã–º–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏ –≤ —Å—Ç–∏–ª–µ io –∏–∑ –¥–æ—Ç—ã ( —Ç–æ–ª—å–∫–æ –±–µ–∑ –±—Ä–æ–≤–µ–π —Å–≤–µ—Ä—Ö—É –≥–¥–µ –∑–∞–∫—Ä—ã—Ç—å —Å–≤–µ—Ä–Ω—É—Ç—å –∏ —Ç–¥.
—Ç–∞–∫–∂–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∞—É–¥–∏–æ —ç—Ñ—Ñ–µ–∫—Ç—ã —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞—é—â–∏–µ, –∫–æ–≥–¥–∞ —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è, —á—Ç–æ –æ–Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç, —á—Ç–æ —Å–∏—Å—Ç–µ–º–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –≤—Å—è–∫–∏–µ —Ç–∞–∫–∏–µ –∑–≤—É–∫–∏ –∫–ª–∞—Å—Å–Ω—ã–µ)

https://github.com/lleevinn/sat_name_v6
—è —Å–¥–µ–ª–∞–ª –ø—Ä–æ–µ–∫—Ç –Ω–∞ –∫–æ–ª–µ–Ω–∫–µ, –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –µ–≥–æ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
–°–æ–±–µ—Ä–∏ –≤—Å—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É, —Å–æ–∑–¥–∞–π –∏–∑ —ç—Ç–æ–≥–æ –∞–ª–º–∞–∑.
—É –º–µ–Ω—è windows
–≤—Å—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é —Ç—ã –Ω–∞–π–¥–µ—à—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
–∏ –∫–æ–Ω–µ—á–Ω–æ –∂–µ –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ–π –Ω–µ WEB –∞ –ª–æ–∫–∞–ª—å–Ω–∞—è –≤ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ —á–µ—Ä–µ–∑ main.py –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è
</file>

<file path="attached_assets/Pasted--venv-PS-C-Users-Ghost-Desktop-hfdhf-python-main-py-C-U_1766235872465.txt">
(venv) PS C:\Users\Ghost\Desktop\hfdhf> python main.py
C:\Users\Ghost\Desktop\hfdhf\venv\Lib\site-packages\pygame\pkgdata.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
  from pkg_resources import resource_stream, resource_exists
pygame 2.6.1 (SDL 2.28.4, Python 3.11.0)
Hello from the pygame community. https://www.pygame.org/contribute.html
[2025-12-20 16:01:33,912] VoiceInput - INFO - ‚úÖ Vosk —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
[2025-12-20 16:01:33,912] VoiceInput - INFO - ‚úÖ SpeechRecognition —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
[2025-12-20 16:01:33,912] VoiceInput - INFO - ‚úÖ PyAudio —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
[2025-12-20 16:01:33,913] VoiceInput - INFO - ‚ö†Ô∏è SoundDevice –ø—Ä–æ–ø—É—â–µ–Ω (—Ç—Ä–µ–±—É–µ—Ç PortAudio)

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                            ‚ïë
‚ïë        üå∏ IRIS - AI Assistant                              ‚ïë
‚ïë        –õ–æ–∫–∞–ª—å–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å + –≥–æ–ª–æ—Å + –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è         ‚ïë
‚ïë                                                            ‚ïë
‚ïë        üíú –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:                                      ‚ïë
‚ïë           ‚Ä¢ Ollama (Qwen3) - –ª–æ–∫–∞–ª—å–Ω—ã–π AI                ‚ïë
‚ïë           ‚Ä¢ Edge TTS - —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏                        ‚ïë
‚ïë           ‚Ä¢ Vosk - —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏                     ‚ïë
‚ïë           ‚Ä¢ Pygame - –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è IO-—Å—Ç–∏–ª—å               ‚ïë
‚ïë                                                            ‚ïë
‚ïë        –î–ª—è –ª—É—á—à–µ–π —Ä–∞–±–æ—Ç—ã:                                 ‚ïë
‚ïë        ‚Ä¢ –ó–∞–ø—É—Å—Ç–∏—Ç–µ Ollama: ollama serve                  ‚ïë
‚ïë        ‚Ä¢ –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞: qwen3:4b-instructor              ‚ïë
‚ïë                                                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

[2025-12-20 16:01:33,915] IRIS - INFO - ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
[2025-12-20 16:01:33,915] IRIS - INFO - üå∏ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è IRIS - AI Assistant
[2025-12-20 16:01:33,915] IRIS - INFO - ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
[2025-12-20 16:01:33,915] IRIS - INFO - [VISUAL] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é IO-—Å—Ç–∏–ª—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å...
[2025-12-20 16:01:33,916] IRIS - INFO - [AI] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é Ollama AI...
[2025-12-20 16:01:33,924] IRIS - INFO - [OLLAMA] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å qwen3:4b-instructor
[2025-12-20 16:01:33,924] IRIS - INFO - [TTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏...
[TTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –¥–≤–∏–∂–∫–∞ –ò—Ä–∏—Å v3.1...
[TTS] Pygame mixer –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
[TTS] –ì–æ–ª–æ—Å: ru_female_soft, –ì—Ä–æ–º–∫–æ—Å—Ç—å: 0.9
[TTS] Max queue size: 10
[TTS] –î–≤–∏–∂–æ–∫ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ
[2025-12-20 16:01:34,395] IRIS - INFO - [VOICE] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥...

============================================================
[VOICE] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...
============================================================

[2025-12-20 16:02:24,855] VoiceInput - INFO - [VOICE] ‚úÖ –ú–æ–¥–µ–ª—å Vosk –∑–∞–≥—Ä—É–∂–µ–Ω–∞: models/vosk-model-ru-0.22
[2025-12-20 16:02:24,857] VoiceInput - INFO - [VOICE] ‚úÖ SpeechRecognition –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
[2025-12-20 16:02:24,858] VoiceInput - INFO - [VOICE] –ü–æ–∏—Å–∫ –∞—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤...
[2025-12-20 16:02:25,021] VoiceInput - INFO - [VOICE] –ù–∞–π–¥–µ–Ω–æ –∞—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤: 71
 [0] Microsoft Sound Mapper - Input
 [1] –†—ö–†—ë–†—î–°–Ç–†—ï–°‚Äû–†—ï–†–Ö (3- USB PnP Audio Devi
 [2] AI Noise-cancelling Input (ASUS
 [3] Microphone (Camo)
 [4] CABLE Output (VB-Audio Virtual
 [5] –†‚Äú–†—ï–†¬ª–†—ï–†–Ü–†–Ö–†—ï–†‚Ññ –°‚Äö–†¬µ–†¬ª–†¬µ–°‚Äû–†—ï–†–Ö (HUAWEI FreeBu
 [16] –†—ü–†¬µ–°–Ç–†–Ü–†—ë–°‚Ä°–†–Ö–°‚Äπ–†‚Ññ –†“ë–°–Ç–†¬∞–†‚Ññ–†–Ü–†¬µ–°–Ç –†¬∑–†¬∞–†—ó–†—ë–°–É–†—ë –†¬∑–†–Ü–°—ì–†—î–†¬∞
 [17] –†—ö–†—ë–†—î–°–Ç–†—ï–°‚Äû–†—ï–†–Ö (3- USB PnP Audio Device)
 [18] AI Noise-cancelling Input (ASUS Utility)
 [19] Microphone (Camo)
 [20] CABLE Output (VB-Audio Virtual Cable)
 [21] –†‚Äú–†—ï–†¬ª–†—ï–†–Ü–†–Ö–†—ï–†‚Ññ –°‚Äö–†¬µ–†¬ª–†¬µ–°‚Äû–†—ï–†–Ö (HUAWEI FreeBuds 4i Hands-Free AG Audio)
 [41] AI Noise-cancelling Input (ASUS Utility)
 [42] –†—ö–†—ë–†—î–°–Ç–†—ï–°‚Äû–†—ï–†–Ö (3- USB PnP Audio Device)
 [43] Microphone (Camo)
 [44] CABLE Output (VB-Audio Virtual Cable)
 [45] –†‚Äú–†—ï–†¬ª–†—ï–†–Ü–†–Ö–†—ï–†‚Ññ –°‚Äö–†¬µ–†¬ª–†¬µ–°‚Äû–†—ï–†–Ö (HUAWEI FreeBuds 4i Hands-Free AG Audio)
 [48] CABLE Output (VB-Audio Point)
 [50] Input (VB-Audio Point)
 [52] –†‚Ä∫–†—ë–†–Ö. –†–Ü–°‚Ä¶–†—ï–†“ë (Realtek HD Audio Line input)
 [54] –†–é–°‚Äö–†¬µ–°–Ç–†¬µ–†—ï –†—ò–†—ë–†—î–°‚Ç¨–†¬µ–°–Ç (Realtek HD Audio Stereo input)
 [55] –†—ö–†—ë–†—î–°–Ç–†—ï–°‚Äû–†—ï–†–Ö (Realtek HD Audio Mic input)
 [57] –†—ö–†—ë–†—î–°–Ç–†—ï–°‚Äû–†—ï–†–Ö (USB PnP Audio Device)
 [58] –†‚Ä∫–†—ë–†–Ö–†—ë–°–è ()
 [60] –†‚Äú–†—ï–†¬ª–†—ï–†–Ü–†–Ö–†—ï–†‚Ññ –°‚Äö–†¬µ–†¬ª–†¬µ–°‚Äû–†—ï–†–Ö (@System32\drivers\bthhfenum.sys,#2;%1 Hands-Free AG Audio%0
;(HUAWEI FreeBuds 4i))
 [62] Input (@System32\drivers\bthhfenum.sys,#4;%1 Hands-Free HF Audio%0
;(realme GT 6))
 [64] AI Noise-cancelling Input (Intelligo VAC (W))
 [66] System Virtual Line (Intelligo VAC (W))
 [68] Microphone (Camo)
 [70] –†‚Äú–†—ï–†¬ª–†—ï–†–Ü–†–Ö–†—ï–†‚Ññ –°‚Äö–†¬µ–†¬ª–†¬µ–°‚Äû–†—ï–†–Ö (@System32\drivers\bthhfenum.sys,#2;%1 Hands-Free AG Audio%0
;(JBL Go 4))
[2025-12-20 16:02:25,036] VoiceInput - INFO - [VOICE] –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: 1

[VOICE] üìä –°–ò–°–¢–ï–ú–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø
 ‚Ä¢ Wake word: '–∏—Ä–∏—Å'
 ‚Ä¢ –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: 0.8
 ‚Ä¢ –†–µ–∂–∏–º —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: hybrid
 ‚Ä¢ –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏: 16000 Hz
 ‚Ä¢ Vosk –¥–æ—Å—Ç—É–ø–µ–Ω: ‚úÖ
 ‚Ä¢ Google Speech –¥–æ—Å—Ç—É–ø–µ–Ω: ‚úÖ
 ‚Ä¢ PyAudio –¥–æ—Å—Ç—É–ø–µ–Ω: ‚úÖ
 ‚Ä¢ SoundDevice –¥–æ—Å—Ç—É–ø–µ–Ω: ‚ùå
 ‚Ä¢ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞: ‚úÖ

============================================================
[VOICE] ‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
============================================================

[2025-12-20 16:02:25,043] VoiceInput - INFO - [VOICE] Command callback —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
[2025-12-20 16:02:25,043] IRIS - INFO - [CS2] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é Game State Integration...
[2025-12-20 16:02:25,049] IRIS - INFO - [AUDIO] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –∫–æ–Ω—Ç—Ä–æ–ª—å –∑–≤—É–∫–∞...
[2025-12-20 16:02:25,283] IRIS - INFO - [ACHIEVEMENTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é —Å–∏—Å—Ç–µ–º—É –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π...
[2025-12-20 16:02:25,283] IRIS - INFO - ‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞
[2025-12-20 16:02:25,284] IRIS - INFO - [IRIS] üöÄ –ó–∞–ø—É—Å–∫ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞...
[2025-12-20 16:02:25,371] IRIS - INFO - [CS2] –ó–∞–ø—É—Å–∫ Game State —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É 3000...
[CS2 GSI] –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 3000
[CS2 GSI] –ö–æ–Ω—Ñ–∏–≥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: gamestate_integration_iris.cfg
[CS2 GSI] –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤: /steamapps/common/Counter-Strike Global Offensive/game/csgo/cfg/
[2025-12-20 16:02:25,374] IRIS - INFO - [VOICE] –ó–∞–ø—É—Å–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...
 * Serving Flask app 'src.cs2_gsi'
 * Debug mode: off
[VOICE] üéØ VOSK LOOP STARTED
[2025-12-20 16:02:25,451] VoiceInput - INFO - [VOICE] ‚úÖ –ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ –≤ —Ä–µ–∂–∏–º–µ 'hybrid'
[2025-12-20 16:02:25,451] VoiceInput - INFO - [VOICE] –ó–∞–ø—É—Å–∫ Vosk –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è... (—Å–∫–∞–∂–∏—Ç–µ '–∏—Ä–∏—Å')
[2025-12-20 16:02:25,460] IRIS - INFO - ============================================================
[2025-12-20 16:02:25,461] IRIS - INFO - ‚úÖ IRIS —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞!
[2025-12-20 16:02:25,461] IRIS - INFO - ============================================================
[2025-12-20 16:02:25,462] IRIS - INFO - üìã –§—É–Ω–∫—Ü–∏–∏:
[2025-12-20 16:02:25,462] IRIS - INFO -    üéÆ CS2 Game State (–ø–æ—Ä—Ç 3000)
[2025-12-20 16:02:25,463] IRIS - INFO -    ü§ñ Ollama AI (–ª–æ–∫–∞–ª—å–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å)
[2025-12-20 16:02:25,464] IRIS - INFO -    üîä Text-to-Speech
[2025-12-20 16:02:25,465] IRIS - INFO -    üé§ Voice Control (—Å–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å')
[2025-12-20 16:02:25,466] IRIS - INFO -    üëÅÔ∏è IO-—Å—Ç–∏–ª—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
[2025-12-20 16:02:25,466] IRIS - INFO - ============================================================
[2025-12-20 16:02:25,497] werkzeug - INFO - WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on all addresses (0.0.0.0)
 * Running on http://127.0.0.1:3000
 * Running on http://192.168.31.140:3000
[2025-12-20 16:02:25,497] werkzeug - INFO - Press CTRL+C to quit
[2025-12-20 16:02:25,531] VoiceInput - INFO - [VOICE] ‚úÖ –ê—É–¥–∏–æ–ø–æ—Ç–æ–∫ –æ—Ç–∫—Ä—ã—Ç, –Ω–∞—á–∏–Ω–∞–µ–º —Å–ª—É—à–∞—Ç—å...
[TTS] –í–Ω–∏–º–∞–Ω–∏–µ: –¥–≤–∏–∂–æ–∫ –Ω–µ –∑–∞–ø—É—â–µ–Ω, –≤—ã–∑–æ–≤–∏—Ç–µ start()
[2025-12-20 16:03:43,998] IRIS - INFO - [IRIS] –û—Å—Ç–∞–Ω–æ–≤–∫–∞...
[2025-12-20 16:03:44,096] VoiceInput - INFO - [VOICE] Vosk loop –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
[2025-12-20 16:03:44,096] VoiceInput - INFO - [VOICE] ‚úÖ –ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
[2025-12-20 16:03:44,096] IRIS - INFO - [IRIS] –î–æ –≤—Å—Ç—Ä–µ—á–∏! üå∏
</file>

<file path="attached_assets/Pasted--wake-word-detection--1765952507227_1765952507228.txt">
–ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å wake-word detection: –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ —Å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ–º –∏–º–µ–Ω–∏ '–ò—Ä–∏—Å' —á–µ—Ä–µ–∑ OpenAI Whisper API –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –¥–∏–∞–ª–æ–≥–æ–≤, –ø–æ–¥–¥–µ—Ä–∂–∫–∞ continuous conversation mode –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –æ–±—â–µ–Ω–∏—è
–ü—Ä–µ–º–∏—É–º –≥–æ–ª–æ—Å–æ–≤–æ–π —Å–∏–Ω—Ç–µ–∑: –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è OpenAI TTS API —Å –≤—ã–±–æ—Ä–æ–º –≥–æ–ª–æ—Å–∞ (alloy, echo, fable, onyx, nova, shimmer), –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –æ–∫—Ä–∞—Å–∫–∞ —Ä–µ—á–∏, –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Ä–µ–≥—É–ª–∏—Ä–æ–≤–∫–∞ —Ç–æ–Ω–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (—Ä–∞–¥–æ—Å—Ç—å, —Å–æ—á—É–≤—Å—Ç–≤–∏–µ, —Å–∞—Ä–∫–∞–∑–º, –≤–æ–ª–Ω–µ–Ω–∏–µ)
CS2 Game State Integration —Å–µ—Ä–≤–µ—Ä: Flask HTTP endpoint –¥–ª—è –ø—Ä–∏—ë–º–∞ real-time –¥–∞–Ω–Ω—ã—Ö –∏–∑ CS2 (—É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, –∞—Å—Å–∏—Å—Ç—ã, –∑–¥–æ—Ä–æ–≤—å–µ, –±—Ä–æ–Ω—è, –æ—Ä—É–∂–∏–µ, —ç–∫–æ–Ω–æ–º–∏–∫–∞, —Ä–∞—É–Ω–¥—ã, –±–æ–º–±–∞, MVP), –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è CS2
–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ CS2 —Å–æ–±—ã—Ç–∏–π: —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ clutch —Å–∏—Ç—É–∞—Ü–∏–π (1v2, 1v3, 1v4), —Å–µ—Ä–∏–π —É–±–∏–π—Å—Ç–≤, ace —Ä–∞—É–Ω–¥–æ–≤, —ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏—Ö —Ä–µ—à–µ–Ω–∏–π, –¥–µ—Ñ—É–∑–æ–≤ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–µ–∫—É–Ω–¥–µ, comeback –º–æ–º–µ–Ω—Ç–æ–≤ —Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
StreamElements WebSocket –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è: –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ JWT —Ç–æ–∫–µ–Ω –¥–ª—è real-time —á—Ç–µ–Ω–∏—è —á–∞—Ç–∞, –¥–æ–Ω–∞—Ç–æ–≤, –ø–æ–¥–ø–∏—Å–æ–∫, —Ñ–æ–ª–ª–æ–≤–æ–≤, —Ä–µ–π–¥–æ–≤ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Ä–µ–∞–∫—Ü–∏—è–º–∏ –∏ –æ–∑–≤—É—á–∫–æ–π
–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç AI: GPT-4o –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∂–∏–≤—ã–µ –æ—Ç–≤–µ—Ç—ã –±–µ–∑ —à–∞–±–ª–æ–Ω–æ–≤ –∏ —á–∞—Å—Ç—ã—Ö —Å–º–∞–π–ª–∏–∫–æ–≤, –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —é–º–æ—Ä, –æ—Å—Ç—Ä–æ—É–º–∏–µ, —Å–∞—Ä–∫–∞–∑–º, –ø–æ–¥–¥–µ—Ä–∂–∫–∞, –º–æ—Ç–∏–≤–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∏—Ç—É–∞—Ü–∏–∏ (–ø—Ä–æ–∏–≥—Ä—ã—à, –ø–æ–±–µ–¥–∞, –¥–æ–Ω–∞—Ç, –Ω–µ–≥–∞—Ç–∏–≤ –≤ —á–∞—Ç–µ)
–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è –ø–∞–º—è—Ç—å –∏ –±–µ—Å–µ–¥–∞: –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è –ø–∞–º—è—Ç—å –æ —Å–æ–±—ã—Ç–∏—è—Ö —Å—Ç—Ä–∏–º–∞, –º–æ–∂–µ—Ç –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–º—ã ('–ø–æ–º–Ω–∏—à—å —Ç–æ—Ç clutch?'), –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏, –∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å multi-turn conversations
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Windows –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º–∏: Python –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å pycaw –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π (–Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∞, Spotify, Discord, –±—Ä–∞—É–∑–µ—Ä) —á–µ—Ä–µ–∑ –≥–æ–ª–æ—Å–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã —Ç–∏–ø–∞ '–ò—Ä–∏—Å, —Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ'
–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —á–∞—Ç-–±–æ—Ç: –æ—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã –∑—Ä–∏—Ç–µ–ª–µ–π –≤ StreamElements —á–∞—Ç–µ, –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –∞—É–¥–∏—Ç–æ—Ä–∏–µ–π, –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç–∏ –∑–∞ –¥–æ–Ω–∞—Ç—ã —Å —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º —Å—É–º–º—ã –∏ –∏–º–µ–Ω–∏, –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤, —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —Ä–µ–π–¥—ã
–ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –ª–∏—á–Ω–æ—Å—Ç—å: –∞–Ω–∞–ª–∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è —á–∞—Ç–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø–æ–¥—Å—Ç—Ä–æ–π–∫–∞ —Ç–æ–Ω–∞ (–ø–æ–∑–∏—Ç–∏–≤–Ω—ã–π/–º–æ—Ç–∏–≤–∏—Ä—É—é—â–∏–π –ø—Ä–∏ –Ω–µ–≥–∞—Ç–∏–≤–µ, —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω—ã–π –ø—Ä–∏ –ø–æ–±–µ–¥ streak, —Å–æ—á—É–≤—Å—Ç–≤—É—é—â–∏–π –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–∞—Ö)
–°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å—Ç—Ä–∏–º–∞ (–ª—É—á—à–∏–π —Ä–∞—É–Ω–¥, kill streak, clutch wins, viewer count milestones), –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –∞–Ω–æ–Ω—Å—ã –≤ —á–∞—Ç –∏ –≥–æ–ª–æ—Å–æ–º
–ì–æ–ª–æ—Å–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ: —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–∏–º–æ–º —á–µ—Ä–µ–∑ –≥–æ–ª–æ—Å - '–Ω–∞—á–∞—Ç—å/–∑–∞–∫–æ–Ω—á–∏—Ç—å —Å—Ç—Ä–∏–º', '–≤–∑—è—Ç—å –ø–µ—Ä–µ—Ä—ã–≤', '–≤–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É', '—Å–º–µ–Ω–∏—Ç—å —Å—Ü–µ–Ω—É OBS' (—Å –ø–æ–¥–≥–æ—Ç–æ–≤–∫–æ–π –¥–ª—è –±—É–¥—É—â–µ–π OBS –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏)
</file>

<file path="attached_assets/streamelements_client_1765902075685.py">
import json
import websocket

# –í—Å—Ç–∞–≤—å—Ç–µ –≤–∞—à —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω —Å—é–¥–∞
YOUR_JWT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjaXRhZGVsIiwiZXhwIjoxNzgxNDUzNDYwLCJqdGkiOiJjYzM3ZjUwNS1lNGRkLTQxZjktOGIwZS1lNTNhZjUzM2M0ODIiLCJjaGFubmVsIjoiNjk0MTg0OTNjMjdmNzk4NGQ1Y2UwNmNkIiwicm9sZSI6Im93bmVyIiwiYXV0aFRva2VuIjoiMVdQckRUYUZUN21mc3RHSlNfZFpxV3NtNmlicFhYeGdDbmdjcThpeHlCbG9HTXpVIiwidXNlciI6IjY5NDE4NDkzYzI3Zjc5ODRkNWNlMDZjYyIsInVzZXJfaWQiOiIwYjhiZTJhZS1kNjIyLTRlNGEtODdmMy01NjJhYTcxMGM5YWYiLCJ1c2VyX3JvbGUiOiJjcmVhdG9yIiwicHJvdmlkZXIiOiJ0d2l0Y2giLCJwcm92aWRlcl9pZCI6IjE4NzU3MjUyNyIsImNoYW5uZWxfaWQiOiJlMjU4YzczZS04ZTgxLTQyNzktOGNjMS0wZWI2OTE2ZmIyMDMiLCJjcmVhdG9yX2lkIjoiNGQ4Zjk5YzktMGE3OC00YjlkLWJlNWEtZjVmNDY2ZGMyZjk4In0.UDj-xNNlOjOplW8gliL0-cb9S8_rnuCZaQCpLUvMq1o"

def on_message(ws, message):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç StreamElements."""
    try:
        data = json.loads(message)
    except json.JSONDecodeError:
        # –ò–Ω–æ–≥–¥–∞ –ø—Ä–∏—Ö–æ–¥—è—Ç —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –∏—Ö –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å
        return

    # StreamElements –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–±—ã—Ç–∏—è –≤ –ø–æ–ª–µ 'type'
    event_type = data.get('type')
    listener = data.get('listener')

    # –°–æ–±—ã—Ç–∏–µ —á–∞—Ç–∞
    if listener == 'chat-message':
        event_data = data.get('data', {})
        username = event_data.get('displayName', '–ê–Ω–æ–Ω–∏–º')
        user_message = event_data.get('message', '')
        print(f'[–ß–ê–¢] {username}: {user_message}')
        # –¢—É—Ç –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≤–∞—à –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

    # –°–æ–±—ã—Ç–∏–µ –¥–æ–Ω–∞—Ç–∞ (—Ç–∏–ø 'tip')
    elif event_type == 'tip':
        event_data = data.get('data', {})
        donor = event_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        amount = event_data.get('amount', 0)
        currency = event_data.get('currency', 'USD')
        print(f'[–î–û–ù–ê–¢] {donor} - {amount} {currency}')
        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º

    # –°–æ–±—ã—Ç–∏–µ –Ω–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ (—Ç–∏–ø 'subscriber')
    elif event_type == 'subscriber':
        event_data = data.get('data', {})
        subscriber = event_data.get('username', '–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫')
        print(f'[–ü–û–î–ü–ò–°–ö–ê] {subscriber}')
        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏

def on_error(ws, error):
    print(f"–û—à–∏–±–∫–∞ WebSocket: {error}")

def on_close(ws, close_status_code, close_msg):
    print("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å StreamElements –∑–∞–∫—Ä—ã—Ç–æ")

def on_open(ws):
    print("–£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ StreamElements WebSocket!")
    # –ü–æ—Å–ª–µ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω—É–∂–Ω–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å—Å—è
    auth_message = {
        "method": "jwt",
        "token": YOUR_JWT_TOKEN
    }
    ws.send(json.dumps(auth_message))

if __name__ == "__main__":
    ws_url = "wss://realtime.streamelements.com/socket.io/?EIO=4&transport=websocket"
    ws = websocket.WebSocketApp(ws_url,
                                on_open=on_open,
                                on_message=on_message,
                                on_error=on_error,
                                on_close=on_close)
    ws.run_forever()
</file>

<file path="Chernovik.py">

</file>

<file path="find_female_voice.py">
import pyttsx3

engine = pyttsx3.init()
voices = engine.getProperty('voices')

print(f"üì¢ –î–æ—Å—Ç—É–ø–Ω–æ {len(voices)} –≥–æ–ª–æ—Å–æ–≤:\n")

female_voices = []
for i, voice in enumerate(voices):
    voice_name = voice.name.lower()
    is_female = any(keyword in voice_name for keyword in 
                   ['female', '–∂–µ–Ω—Å–∫', 'woman', '–¥–∞–º–∞', '–¥–µ–≤—É—à–∫–∞', 'irina', 'anna', '–º–∞—Ä–∏—è', 'natalia'])
    
    status = "üë© –ñ–ï–ù–°–ö–ò–ô" if is_female else "üë® –ú–£–ñ–°–ö–û–ô"
    
    print(f"{i+1}. {status}: {voice.name}")
    print(f"   ID: {voice.id}")
    
    if is_female:
        female_voices.append(voice.id)
    
    print()

if female_voices:
    print(f"\n‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(female_voices)} –∂–µ–Ω—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤!")
    print(f"–†–µ–∫–æ–º–µ–Ω–¥—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å: {female_voices[0]}")
else:
    print("\n‚ö†Ô∏è –ñ–µ–Ω—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π")
    print(f"–ü–µ—Ä–≤—ã–π –≥–æ–ª–æ—Å: {voices[0].id}")
</file>

<file path="fix_iris_brain.py">
# fix_iris_brain.py
import os
import sys

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ –ø—Ä–æ–µ–∫—Ç—É
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    from src.iris_brain import IrisBrain
    print("‚úÖ IrisBrain –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º Groq
    from groq import Groq
    
    api_key = os.getenv('GROQ_API_KEY', 'test')
    try:
        # –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è Groq
        client = Groq(api_key=api_key)
        print("‚úÖ Groq –∫–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω (–Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è)")
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ Groq: {e}")
        
except Exception as e:
    print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
    import traceback
    traceback.print_exc()

print("\nüìã –£—Å—Ç–∞–Ω–æ–≤–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é Groq:")
print("pip install groq==0.3.0")
</file>

<file path="main_clean.py">
#!/usr/bin/env python3
"""
IRIS - AI Assistant with Ollama + Voice + Visual
–ü–æ–ª–Ω–æ—Å—Ç—å—é –ª–æ–∫–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ - Jarvis style —Å IO –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π
"""
import os
import sys
import time
import threading
import logging
import json
import random
from dotenv import load_dotenv
from typing import Optional
from collections import deque

load_dotenv()

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –õ–û–ì–ò–†–û–í–ê–ù–ò–ï
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='[%(asctime)s] %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('iris.log', encoding='utf-8')
    ]
)
logger = logging.getLogger("IRIS")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ò–ú–ü–û–†–¢–´ - –õ–û–ö–ê–õ–¨–ù–´–ï –ú–û–î–£–õ–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
from src.tts_engine import TTSEngine
from src.voice_input import VoiceInput
from src.cs2_gsi import CS2GameStateIntegration, GameEvent
from src.windows_audio import WindowsAudioController
from src.achievements import AchievementSystem, Achievement

# –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
try:
    from src.iris_visual import IrisVisual
    VISUAL_AVAILABLE = True
except ImportError:
    VISUAL_AVAILABLE = False
    logger.warning("[VISUAL] –ú–æ–¥—É–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")

# Ollama –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ AI
try:
    from ollama import Client as OllamaClient
    OLLAMA_AVAILABLE = True
except ImportError:
    OLLAMA_AVAILABLE = False
    logger.warning("[OLLAMA] –ü–∞–∫–µ—Ç –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - pip install ollama")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# OLLAMA AI ENGINE - –õ–æ–∫–∞–ª—å–Ω—ã–π AI —á–µ—Ä–µ–∑ Ollama
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class OllamaAI:
    """–õ–æ–∫–∞–ª—å–Ω—ã–π AI –¥–≤–∏–∂–æ–∫ —á–µ—Ä–µ–∑ Ollama"""
    def __init__(self, model: str = "qwen3:4b-instructor", host: str = "http://localhost:11434"):
        self.model = model
        self.host = host
        self.client = None
        self.available = False
        self.context_history = deque(maxlen=10)
        
        self._initialize()
    
    def _initialize(self):
        if not OLLAMA_AVAILABLE:
            logger.warning("[OLLAMA] Ollama –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞")
            return
        
        try:
            self.client = OllamaClient(host=self.host)
            logger.info(f"[OLLAMA] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å {self.model}")
            self.available = True
        except Exception as e:
            logger.error(f"[OLLAMA] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
            self.available = False
    
    def generate(self, prompt: str, context: str = "", max_tokens: int = 150) -> Optional[str]:
        """–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç AI"""
        if not self.available or not self.client:
            return self._fallback_response()
        
        try:
            full_prompt = f"{context}\n\n{prompt}" if context else prompt
            
            response = self.client.generate(
                model=self.model,
                prompt=full_prompt,
                stream=False,
                options={'num_predict': max_tokens}
            )
            
            text = response.get('response', '').strip()
            if text:
                self.context_history.append(text)
                return text
            return self._fallback_response()
        
        except Exception as e:
            logger.error(f"[OLLAMA] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
            return self._fallback_response()
    
    def _fallback_response(self) -> str:
        """Fallback –æ—Ç–≤–µ—Ç—ã –µ—Å–ª–∏ AI –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"""
        responses = [
            "–•–º, –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –º–æ–º–µ–Ω—Ç. –î–∞–π –º–Ω–µ —Å–µ–∫—É–Ω–¥—É –ø–æ–¥—É–º–∞—Ç—å.",
            "–°–æ–≥–ª–∞—Å–Ω–∞ —Å —Ç–æ–±–æ–π! –î–∞–≤–∞–π –ø—Ä–æ–¥–æ–ª–∂–∏–º.",
            "–≠—Ç–æ –±—ã–ª–æ —ç–ø–∏—á–Ω–æ! –ì–æ—Ç–æ–≤–∞ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Ä–∞—É–Ω–¥—É.",
            "–ù–∏—á–µ–≥–æ —Å–µ–±–µ! –í–æ—Ç —ç—Ç–æ –¥–∞!",
        ]
        return random.choice(responses)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IRIS ASSISTANT MAIN CLASS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class IrisAssistant:
    def __init__(self):
        logger.info("‚ïê" * 60)
        logger.info("üå∏ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è IRIS - AI Assistant")
        logger.info("‚ïê" * 60)
        
        self.is_running = False
        self.config = {
            'cs2_gsi_port': int(os.getenv('CS2_GSI_PORT', 3000)),
            'voice_enabled': os.getenv('VOICE_ENABLED', 'true').lower() == 'true',
            'wake_word': os.getenv('WAKE_WORD', '–∏—Ä–∏—Å'),
            'tts_voice': os.getenv('TTS_VOICE', 'ru_female_soft'),
            'ollama_url': os.getenv('OLLAMA_URL', 'http://localhost:11434'),
            'ollama_model': os.getenv('OLLAMA_MODEL', 'qwen3:4b-instructor'),
        }
        
        # ‚ú® –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        if VISUAL_AVAILABLE:
            logger.info("[VISUAL] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é IO-—Å—Ç–∏–ª—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å...")
            self.visual = IrisVisual(width=500, height=500)
        else:
            self.visual = None
            logger.warning("[VISUAL] –í–∏–∑—É–∞–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (—Ç—Ä–µ–±—É–µ—Ç—Å—è pygame)")
        
        # ü§ñ AI
        logger.info("[AI] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é Ollama AI...")
        self.ai = OllamaAI(
            model=self.config['ollama_model'],
            host=self.config['ollama_url']
        )
        
        # üîä TTS
        logger.info("[TTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏...")
        self.tts = TTSEngine(
            voice=self.config['tts_voice'],
            visual_callback=self._on_visual_update if self.visual else None
        )
        
        # üé§ Voice Input
        if self.config['voice_enabled']:
            logger.info("[VOICE] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥...")
            self.voice_input = VoiceInput(
                wake_word=self.config['wake_word'],
                sensitivity=0.8
            )
            self.voice_input.set_command_callback(self.process_voice_command)
        else:
            self.voice_input = None
            logger.info("[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –æ—Ç–∫–ª—é—á—ë–Ω")
        
        # üéÆ CS2 GSI
        logger.info("[CS2] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é Game State Integration...")
        self.cs2_gsi = CS2GameStateIntegration(
            port=self.config['cs2_gsi_port'],
            event_callback=self._on_game_event
        )
        
        # üîä Audio Control
        logger.info("[AUDIO] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –∫–æ–Ω—Ç—Ä–æ–ª—å –∑–≤—É–∫–∞...")
        self.audio_controller = WindowsAudioController()
        
        # üèÜ Achievements
        logger.info("[ACHIEVEMENTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é —Å–∏—Å—Ç–µ–º—É –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π...")
        self.achievements = AchievementSystem(
            achievement_callback=self._on_achievement
        )
        
        logger.info("‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
    
    def _on_visual_update(self, speaking: bool, intensity: float):
        """–û–±–Ω–æ–≤–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å"""
        if self.visual:
            self.visual.set_speaking(speaking, intensity)
    
    def _on_achievement(self, achievement: Achievement):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π"""
        message = f"–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ! {achievement.icon} {achievement.name}!"
        self.tts.speak(message, emotion='excited', priority=True)
    
    def _on_game_event(self, event: GameEvent):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π CS2"""
        logger.info(f"[CS2] –°–æ–±—ã—Ç–∏–µ: {event.event_type}")
        
        responses = {
            'kill': ("–ö—Ä–æ–≤–∞–≤–æ–µ —à–æ—É! –û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª!", 'excited'),
            'death': ("–ù–µ –ø–µ—Ä–µ–∂–∏–≤–∞–π, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –ø–æ–ª—É—á–∏—Ç—Å—è!", 'supportive'),
            'round_end': ("–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à—ë–Ω! –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º—Å—è –∫ —Å–ª–µ–¥—É—é—â–µ–º—É", 'neutral'),
            'ace': ("–ê–°–ï–ï–ï–ï!!! –≠—Ç–æ –±—ã–ª–∞ —ç–ø–æ—Ö–∞! –ü—è—Ç—å —Ñ—Ä–∞–≥–æ–≤ –ø–æ–¥—Ä—è–¥!", 'excited'),
        }
        
        text, emotion = responses.get(event.event_type, ("–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –º–æ–º–µ–Ω—Ç", 'neutral'))
        self.tts.speak(text, emotion=emotion)
    
    def process_voice_command(self, command: str):
        """–û–±—Ä–∞–±–æ—Ç–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É"""
        logger.info(f"[VOICE] –ö–æ–º–∞–Ω–¥–∞: {command}")
        
        if not command or len(command.strip()) < 2:
            self.tts.speak("–î–∞, —è —Å–ª—É—à–∞—é?", emotion='neutral')
            return
        
        command_lower = command.lower().strip()
        
        # –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
        if any(kw in command_lower for kw in ['—Ç–∏—Ö–æ', '–≥—Ä–æ–º—á–µ', '–≥—Ä–æ–º–∫–æ—Å—Ç—å', '–∑–≤—É–∫']):
            response = self.audio_controller.execute_voice_command(command)
            self.tts.speak(response, emotion='neutral')
            return
        
        if command_lower in ['–ø—Ä–∏–≤–µ—Ç', '–ø—Ä–∏–≤–µ–µ—Ç']:
            self.tts.speak("–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, —Ç–≤–æ–π AI –ø–æ–º–æ—â–Ω–∏–∫!", emotion='happy')
            return
        
        if command_lower in ['—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', '—Å—Ç–∞—Ç–∞']:
            stats = self.achievements.get_stats_summary()
            self.tts.speak(stats[:200], emotion='neutral')
            return
        
        # AI –æ—Ç–≤–µ—Ç –Ω–∞ –æ—Å—Ç–∞–ª—å–Ω–æ–µ
        logger.info("[AI] –ì–µ–Ω–µ—Ä–∏—Ä—É—é –æ—Ç–≤–µ—Ç...")
        response = self.ai.generate(command)
        if response:
            self.tts.speak(response, emotion='neutral')
    
    def _startup_sequence(self):
        """–ö—Ä–∞—Å–∏–≤—ã–π —Å—Ç–∞—Ä—Ç–∞–ø —Å –∑–≤—É–∫–∞–º–∏ –∏ —Ñ—Ä–∞–∑–∞–º–∏"""
        phrases = [
            ("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —è–¥—Ä–∞....", 'scan', 1.5),
            ("–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏....", 'loading', 1.5),
            ("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä–∞–º....", 'connect', 1.3),
            ("–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –≥–æ–ª–æ—Å–∞....", 'check', 1.2),
        ]
        
        time.sleep(2)
        
        for text, sound, duration in phrases:
            self.visual.animate_phase(sound, duration) if self.visual else None
            self.tts.speak(text, emotion='neutral')
            while self.tts.is_busy():
                time.sleep(0.1)
            time.sleep(0.3)
        
        if self.visual:
            self.visual.play_sound('ready', 0.8)
        
        greeting = random.choice([
            "–í—Å–µ —Å–∏—Å—Ç–µ–º—ã –∞–∫—Ç–∏–≤–Ω—ã! –ü—Ä–∏–≤–µ—Ç, —è –ò—Ä–∏—Å! –ì–æ—Ç–æ–≤–∞ –ø–æ–º–æ–≥–∞—Ç—å!",
            "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ò—Ä–∏—Å –Ω–∞ —Å–≤—è–∑–∏!",
            "–°–∏—Å—Ç–µ–º—ã –≤ –Ω–æ—Ä–º–µ! –ù–∞—á–∏–Ω–∞–µ–º!",
        ])
        self.tts.speak(greeting, emotion='excited')
    
    def start(self):
        """–ó–∞–ø—É—Å–∫ –ò—Ä–∏—Å"""
        self.is_running = True
        
        logger.info("[IRIS] üöÄ –ó–∞–ø—É—Å–∫ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞...")
        if self.visual:
            self.visual.run_async()
            threading.Thread(target=self._startup_sequence, daemon=True).start()
        
        logger.info("[CS2] –ó–∞–ø—É—Å–∫ Game State —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É 3000...")
        self.cs2_gsi.start()
        self.cs2_gsi.save_config_file()
        
        if self.voice_input:
            logger.info("[VOICE] –ó–∞–ø—É—Å–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...")
            self.voice_input.start()
        
        logger.info("=" * 60)
        logger.info("‚úÖ IRIS —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞!")
        logger.info("=" * 60)
        logger.info("üìã –§—É–Ω–∫—Ü–∏–∏:")
        logger.info("   üéÆ CS2 Game State (–ø–æ—Ä—Ç 3000)")
        logger.info("   ü§ñ Ollama AI (–ª–æ–∫–∞–ª—å–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å)")
        logger.info("   üîä Text-to-Speech")
        logger.info("   üé§ Voice Control (—Å–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å')")
        logger.info("   üëÅÔ∏è IO-—Å—Ç–∏–ª—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è")
        logger.info("=" * 60)
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞"""
        logger.info("[IRIS] –û—Å—Ç–∞–Ω–æ–≤–∫–∞...")
        self.is_running = False
        
        if self.voice_input:
            self.voice_input.stop()
        self.cs2_gsi.stop()
        self.tts.stop()
        if self.visual:
            self.visual.stop()
        
        logger.info("[IRIS] –î–æ –≤—Å—Ç—Ä–µ—á–∏! üå∏")
    
    def run(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª"""
        import signal
        
        def signal_handler(sig, frame):
            self.stop()
            sys.exit(0)
        
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
        
        self.start()
        
        try:
            while self.is_running:
                time.sleep(1)
        except KeyboardInterrupt:
            self.stop()

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ENTRY POINT
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def main():
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                            ‚ïë
‚ïë        üå∏ IRIS - AI Assistant                              ‚ïë
‚ïë        –õ–æ–∫–∞–ª—å–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å + –≥–æ–ª–æ—Å + –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è         ‚ïë
‚ïë                                                            ‚ïë
‚ïë        üíú –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:                                      ‚ïë
‚ïë           ‚Ä¢ Ollama (Qwen3) - –ª–æ–∫–∞–ª—å–Ω—ã–π AI                ‚ïë
‚ïë           ‚Ä¢ Edge TTS - —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏                        ‚ïë
‚ïë           ‚Ä¢ Vosk - —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏                     ‚ïë
‚ïë           ‚Ä¢ Pygame - –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è IO-—Å—Ç–∏–ª—å               ‚ïë
‚ïë                                                            ‚ïë
‚ïë        –î–ª—è –ª—É—á—à–µ–π —Ä–∞–±–æ—Ç—ã:                                 ‚ïë
‚ïë        ‚Ä¢ –ó–∞–ø—É—Å—Ç–∏—Ç–µ Ollama: ollama serve                  ‚ïë
‚ïë        ‚Ä¢ –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞: qwen3:4b-instructor              ‚ïë
‚ïë                                                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    iris = IrisAssistant()
    iris.run()

if __name__ == "__main__":
    main()
</file>

<file path="pyproject.toml">
[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "edge-tts>=7.2.7",
    "flask>=3.1.2",
    "groq>=0.37.1",
    "numpy>=2.3.5",
    "openai>=2.12.0",
    "pygame>=2.6.1",
    "python-dotenv>=1.2.1",
    "requests>=2.32.5",
    "scipy>=1.16.3",
    "speechrecognition>=3.14.4",
    "trafilatura>=2.0.0",
    "websocket-client>=1.9.0",
]
</file>

<file path="README.md">
# üå∏ IRIS - AI Assistant
## –õ–æ–∫–∞–ª—å–Ω—ã–π AI –ø–æ–º–æ—â–Ω–∏–∫ –≤ —Å—Ç–∏–ª–µ Jarvis —Å Ollama + Vosk + Voice

–ü–æ–ª–Ω–æ—Å—Ç—å—é –ª–æ–∫–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å –Ω–µ–π—Ä–æ—Å–µ—Ç—å—é, –≥–æ–ª–æ—Å–æ–≤—ã–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∏ IO-—Å—Ç–∏–ª–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π.

## üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

### 1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Ollama
```bash
# https://ollama.ai
# –ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–∫–∞—á–∞–π—Ç–µ –º–æ–¥–µ–ª—å:
ollama pull qwen3:4b-instructor
ollama serve  # –û—Å—Ç–∞–≤—å—Ç–µ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ç–µ—Ä–º–∏–Ω–∞–ª–µ
```

### 2. –ó–∞–ø—É—Å—Ç–∏—Ç–µ Iris
```bash
pip install -r requirements.txt
python main.py
```

## üìã –§—É–Ω–∫—Ü–∏–∏

- **ü§ñ Ollama AI** - –õ–æ–∫–∞–ª—å–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å Qwen3 (4B)
- **üé§ –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥** - –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ Vosk
- **üîä –°–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏** - Edge TTS —Å —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –æ–∫—Ä–∞—Å–∫–æ–π
- **üëÅÔ∏è –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è** - IO-—Å—Ç–∏–ª—å –ø—É–ª—å—Å–∏—Ä—É—é—â–∏–π —à–∞—Ä
- **üéÆ CS2 GSI** - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Counter-Strike 2
- **üèÜ –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π** - –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏

## ‚öôÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

–°–∫–æ–ø–∏—Ä—É–π—Ç–µ `.env.example` –≤ `.env` –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ:
```bash
cp .env.example .env
```

### –ö–ª—é—á–µ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:
```
OLLAMA_URL=http://localhost:11434
OLLAMA_MODEL=qwen3:4b-instructor
VOICE_ENABLED=true
WAKE_WORD=–∏—Ä–∏—Å
```

## üéØ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

1. **–ê–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ** —Å–∫–∞–∂–∏—Ç–µ "–ò—Ä–∏—Å" –∏–ª–∏ "iris"
2. **–ì–æ–≤–æ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É** - —Å–∏—Å—Ç–µ–º–∞ –ø–æ–π–º—ë—Ç –∏ –æ—Ç–≤–µ—Ç–∏—Ç
3. **–ü—Ä–∏–º–µ—Ä—ã**:
   - "–ì—Ä–æ–º—á–µ"
   - "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"
   - "–ü—Ä–∏–≤–µ—Ç"
   - –ò–ª–∏ —á—Ç–æ —É–≥–æ–¥–Ω–æ - AI —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç

## üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞

```
src/
‚îú‚îÄ‚îÄ iris_visual.py      # IO-—Å—Ç–∏–ª—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
‚îú‚îÄ‚îÄ tts_engine.py       # –°–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ Edge TTS
‚îú‚îÄ‚îÄ voice_input.py      # –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ Vosk
‚îú‚îÄ‚îÄ cs2_gsi.py         # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è CS2
‚îî‚îÄ‚îÄ ...
main.py                # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ —Å Ollama AI
```

## üîß –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è

- Python 3.11+
- Ollama —Å –º–æ–¥–µ–ª—å—é qwen3:4b-instructor
- Windows/Linux/macOS

## üìù –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

–í—Å–µ –ª–æ–≥–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ `iris.log`

## üí° –°–æ–≤–µ—Ç—ã

- –î–ª—è –ª—É—á—à–µ–≥–æ –∑–≤—É–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞—É—à–Ω–∏–∫–∏
- –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç
- Ollama –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∑–∞–ø—É—â–µ–Ω–∞ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ
- –ü–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ –º–µ–¥–ª–µ–Ω–Ω–µ–µ (–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏)

## üé® –ö–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏—è

–û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ `main.py` –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:
- –ü—Ä–æ–º–ø—Ç–æ–≤ AI
- –§—Ä–∞–∑ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è
- –ü–æ–≤–µ–¥–µ–Ω–∏—è –ø—Ä–∏ —Å–æ–±—ã—Ç–∏—è—Ö CS2
- –ì–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥

---

**–ê–≤—Ç–æ—Ä**: –ò—Ä–∏—Å AI  
**–õ–∏—Ü–µ–Ω–∑–∏—è**: MIT  
**–í–µ—Ä—Å–∏—è**: 1.0
</file>

<file path="setup.py">
# setup.py
import os

# –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ñ–∞–π–ª—ã –∏ –ø–∞–ø–∫–∏
paths = [
    "src/__init__.py",
    "src/utils/__init__.py",
    "src/utils/tts_utils.py",
    "src/tts_engine.py",
    "main.py"
]

for path in paths:
    dir_name = os.path.dirname(path)
    if dir_name and not os.path.exists(dir_name):
        os.makedirs(dir_name, exist_ok=True)
    
    if not os.path.exists(path):
        if path.endswith("__init__.py"):
            # –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª
            with open(path, 'w', encoding='utf-8') as f:
                f.write("# Package initializer\n")
        print(f"–°–æ–∑–¥–∞–Ω: {path}")

print("–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ –≥–æ—Ç–æ–≤–∞!")
</file>

<file path="src/achievements.py">
import time
import json
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Callable
from collections import defaultdict

@dataclass
class Achievement:
    id: str
    name: str
    description: str
    icon: str = "üèÜ"
    unlocked: bool = False
    unlocked_at: Optional[float] = None
    progress: int = 0
    target: int = 1

@dataclass
class StreamStats:
    total_kills: int = 0
    total_deaths: int = 0
    total_assists: int = 0
    rounds_won: int = 0
    rounds_lost: int = 0
    clutches_won: int = 0
    aces: int = 0
    headshots: int = 0
    donations_received: int = 0
    donations_total: float = 0.0
    new_subscribers: int = 0
    raids_received: int = 0
    chat_messages: int = 0
    stream_duration: float = 0.0
    kill_streak_max: int = 0
    death_streak_max: int = 0
    current_kill_streak: int = 0
    current_death_streak: int = 0
    matches_played: int = 0
    matches_won: int = 0

class AchievementSystem:
    def __init__(self, achievement_callback: Optional[Callable[[Achievement], None]] = None):
        self.achievement_callback = achievement_callback
        self.stats = StreamStats()
        self.session_start = time.time()
        self.achievements: Dict[str, Achievement] = {}
        self._init_achievements()
        
    def _init_achievements(self):
        achievements_data = [
            ("first_blood", "–ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å", "–ü–µ—Ä–≤–æ–µ —É–±–∏–π—Å—Ç–≤–æ –Ω–∞ —Å—Ç—Ä–∏–º–µ", "ü©∏", 1),
            ("killing_spree", "–°–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤", "5 —É–±–∏–π—Å—Ç–≤ –ø–æ–¥—Ä—è–¥ –±–µ–∑ —Å–º–µ—Ä—Ç–∏", "üî•", 5),
            ("unstoppable", "–ù–µ–æ—Å—Ç–∞–Ω–æ–≤–∏–º—ã–π", "10 —É–±–∏–π—Å—Ç–≤ –ø–æ–¥—Ä—è–¥ –±–µ–∑ —Å–º–µ—Ä—Ç–∏", "‚ö°", 10),
            ("ace_master", "–ú–∞—Å—Ç–µ—Ä ACE", "–°–¥–µ–ª–∞—Ç—å ACE (5 —É–±–∏–π—Å—Ç–≤ –≤ —Ä–∞—É–Ω–¥–µ)", "üéØ", 1),
            ("clutch_king", "–ö–æ—Ä–æ–ª—å –∫–ª–∞—Ç—á–µ–π", "–í—ã–∏–≥—Ä–∞—Ç—å 3 clutch —Å–∏—Ç—É–∞—Ü–∏–∏", "üëë", 3),
            ("headhunter", "–û—Ö–æ—Ç–Ω–∏–∫ –∑–∞ –≥–æ–ª–æ–≤–∞–º–∏", "50 —Ö–µ–¥—à–æ—Ç–æ–≤ –∑–∞ —Å—Ç—Ä–∏–º", "üíÄ", 50),
            ("survivor", "–í—ã–∂–∏–≤—à–∏–π", "–í—ã–∂–∏—Ç—å —Å 1 HP", "‚ù§Ô∏è", 1),
            ("comeback_kid", "–ö–∞–º–±—ç–∫", "–í—ã–∏–≥—Ä–∞—Ç—å –º–∞—Ç—á –ø—Ä–æ–∏–≥—Ä—ã–≤–∞—è 5+ —Ä–∞—É–Ω–¥–æ–≤", "üîÑ", 1),
            ("popular", "–ü–æ–ø—É–ª—è—Ä–Ω—ã–π", "–ü–æ–ª—É—á–∏—Ç—å 10 —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ", "üí¨", 10),
            ("loved", "–õ—é–±–∏–º–µ—Ü", "–ü–æ–ª—É—á–∏—Ç—å 5 –¥–æ–Ω–∞—Ç–æ–≤", "üíù", 5),
            ("whale_friend", "–î—Ä—É–≥ –∫–∏—Ç–æ–≤", "–ü–æ–ª—É—á–∏—Ç—å –¥–æ–Ω–∞—Ç 1000+ —Ä—É–±–ª–µ–π", "üêã", 1),
            ("raided", "–ü–æ–¥ —Ä–µ–π–¥–æ–º", "–ü–æ–ª—É—á–∏—Ç—å —Ä–µ–π–¥ 50+ –∑—Ä–∏—Ç–µ–ª–µ–π", "üöÄ", 1),
            ("marathon", "–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü", "–°—Ç—Ä–∏–º–∏—Ç—å 4+ —á–∞—Å–∞", "‚è±Ô∏è", 1),
            ("consistent", "–°—Ç–∞–±–∏–ª—å–Ω—ã–π", "–ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π KD –≤–µ—Å—å –º–∞—Ç—á", "üìà", 1),
            ("team_player", "–ö–æ–º–∞–Ω–¥–Ω—ã–π –∏–≥—Ä–æ–∫", "10 –∞—Å—Å–∏—Å—Ç–æ–≤ –∑–∞ –º–∞—Ç—á", "ü§ù", 10),
            ("economical", "–≠–∫–æ–Ω–æ–º–Ω—ã–π", "–í—ã–∏–≥—Ä–∞—Ç—å —ç–∫–æ —Ä–∞—É–Ω–¥", "üí∞", 1),
            ("ninja", "–ù–∏–Ω–¥–∑—è", "–î–µ—Ñ—É–∑ –±–æ–º–±—ã –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–µ–∫—É–Ω–¥–µ", "ü•∑", 1),
            ("dedication", "–ü—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å", "10 –º–∞—Ç—á–µ–π –∑–∞ —Å–µ—Å—Å–∏—é", "üéÆ", 10),
            ("sub_love", "–õ—é–±–æ–≤—å –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤", "10 –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤", "üíú", 10),
            ("perfect_round", "–ò–¥–µ–∞–ª—å–Ω—ã–π —Ä–∞—É–Ω–¥", "–í—ã–∏–≥—Ä–∞—Ç—å —Ä–∞—É–Ω–¥ –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ HP", "‚ú®", 1),
        ]
        
        for ach_id, name, desc, icon, target in achievements_data:
            self.achievements[ach_id] = Achievement(
                id=ach_id,
                name=name,
                description=desc,
                icon=icon,
                target=target
            )
            
    def _unlock_achievement(self, ach_id: str):
        if ach_id not in self.achievements:
            return
            
        achievement = self.achievements[ach_id]
        if achievement.unlocked:
            return
            
        achievement.unlocked = True
        achievement.unlocked_at = time.time()
        achievement.progress = achievement.target
        
        print(f"[ACHIEVEMENT] üèÜ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: {achievement.name} - {achievement.description}")
        
        if self.achievement_callback:
            self.achievement_callback(achievement)
            
    def _update_progress(self, ach_id: str, progress: int = 1):
        if ach_id not in self.achievements:
            return
            
        achievement = self.achievements[ach_id]
        if achievement.unlocked:
            return
            
        achievement.progress += progress
        
        if achievement.progress >= achievement.target:
            self._unlock_achievement(ach_id)
            
    def record_kill(self, headshot: bool = False, round_kills: int = 1):
        self.stats.total_kills += 1
        self.stats.current_kill_streak += 1
        self.stats.current_death_streak = 0
        
        if self.stats.current_kill_streak > self.stats.kill_streak_max:
            self.stats.kill_streak_max = self.stats.current_kill_streak
            
        if headshot:
            self.stats.headshots += 1
            self._update_progress("headhunter", 1)
            
        if self.stats.total_kills == 1:
            self._unlock_achievement("first_blood")
            
        if self.stats.current_kill_streak >= 5:
            self._unlock_achievement("killing_spree")
            
        if self.stats.current_kill_streak >= 10:
            self._unlock_achievement("unstoppable")
            
        if round_kills >= 5:
            self.stats.aces += 1
            self._unlock_achievement("ace_master")
            
    def record_death(self):
        self.stats.total_deaths += 1
        self.stats.current_death_streak += 1
        self.stats.current_kill_streak = 0
        
        if self.stats.current_death_streak > self.stats.death_streak_max:
            self.stats.death_streak_max = self.stats.current_death_streak
            
    def record_assist(self):
        self.stats.total_assists += 1
        self._update_progress("team_player", 1)
        
    def record_round_win(self, clutch: bool = False, eco: bool = False, perfect: bool = False):
        self.stats.rounds_won += 1
        
        if clutch:
            self.stats.clutches_won += 1
            self._update_progress("clutch_king", 1)
            
        if eco:
            self._unlock_achievement("economical")
            
        if perfect:
            self._unlock_achievement("perfect_round")
            
    def record_round_loss(self):
        self.stats.rounds_lost += 1
        
    def record_low_health_survive(self, health: int):
        if health <= 1:
            self._unlock_achievement("survivor")
            
    def record_ninja_defuse(self):
        self._unlock_achievement("ninja")
        
    def record_donation(self, amount: float, currency: str = "RUB"):
        self.stats.donations_received += 1
        self.stats.donations_total += amount
        
        self._update_progress("loved", 1)
        
        if currency == "RUB" and amount >= 1000:
            self._unlock_achievement("whale_friend")
        elif currency == "USD" and amount >= 15:
            self._unlock_achievement("whale_friend")
            
    def record_subscription(self):
        self.stats.new_subscribers += 1
        self._update_progress("sub_love", 1)
        
    def record_raid(self, viewers: int):
        self.stats.raids_received += 1
        
        if viewers >= 50:
            self._unlock_achievement("raided")
            
    def record_chat_message(self):
        self.stats.chat_messages += 1
        self._update_progress("popular", 1)
        
    def record_match_end(self, won: bool, came_back: bool = False):
        self.stats.matches_played += 1
        
        if won:
            self.stats.matches_won += 1
            
            if came_back:
                self._unlock_achievement("comeback_kid")
                
            if self.stats.total_kills > self.stats.total_deaths:
                self._unlock_achievement("consistent")
                
        self._update_progress("dedication", 1)
        
    def check_time_achievements(self):
        duration_hours = (time.time() - self.session_start) / 3600
        self.stats.stream_duration = duration_hours
        
        if duration_hours >= 4:
            self._unlock_achievement("marathon")
            
    def get_unlocked_achievements(self) -> List[Achievement]:
        return [a for a in self.achievements.values() if a.unlocked]
        
    def get_locked_achievements(self) -> List[Achievement]:
        return [a for a in self.achievements.values() if not a.unlocked]
        
    def get_progress_summary(self) -> str:
        unlocked = len(self.get_unlocked_achievements())
        total = len(self.achievements)
        
        return f"–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è: {unlocked}/{total}"
        
    def get_stats_summary(self) -> str:
        s = self.stats
        kd = s.total_kills / max(1, s.total_deaths)
        
        return f"""üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∏–º–∞:
üéØ K/D/A: {s.total_kills}/{s.total_deaths}/{s.total_assists} (KD: {kd:.2f})
üèÜ –†–∞—É–Ω–¥—ã: {s.rounds_won}W / {s.rounds_lost}L
üî• –ú–∞–∫—Å. —Å–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤: {s.kill_streak_max}
üíÄ –•–µ–¥—à–æ—Ç—ã: {s.headshots}
üëë Clutch –ø–æ–±–µ–¥: {s.clutches_won}
‚≠ê ACE: {s.aces}
üí∞ –î–æ–Ω–∞—Ç—ã: {s.donations_received} ({s.donations_total:.0f} —Ä—É–±.)
üíú –ü–æ–¥–ø–∏—Å—á–∏–∫–∏: {s.new_subscribers}
üí¨ –°–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ: {s.chat_messages}
‚è±Ô∏è –í—Ä–µ–º—è —Å—Ç—Ä–∏–º–∞: {s.stream_duration:.1f} —á"""

    def save_stats(self, filepath: str = "stream_stats.json"):
        data = {
            'stats': self.stats.__dict__,
            'achievements': {
                k: {
                    'unlocked': v.unlocked,
                    'unlocked_at': v.unlocked_at,
                    'progress': v.progress
                }
                for k, v in self.achievements.items()
            },
            'session_start': self.session_start
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
            
        print(f"[ACHIEVEMENTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {filepath}")
        
    def load_stats(self, filepath: str = "stream_stats.json") -> bool:
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            for key, value in data.get('stats', {}).items():
                if hasattr(self.stats, key):
                    setattr(self.stats, key, value)
                    
            for ach_id, ach_data in data.get('achievements', {}).items():
                if ach_id in self.achievements:
                    self.achievements[ach_id].unlocked = ach_data.get('unlocked', False)
                    self.achievements[ach_id].unlocked_at = ach_data.get('unlocked_at')
                    self.achievements[ach_id].progress = ach_data.get('progress', 0)
                    
            print(f"[ACHIEVEMENTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {filepath}")
            return True
            
        except FileNotFoundError:
            return False
        except Exception as e:
            print(f"[ACHIEVEMENTS] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
            return False
</file>

<file path="src/context_builder.py">
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üß† SMART CONTEXT BUILDER - –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏–≥—Ä–æ–∫–∞
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import logging
import traceback
from typing import Optional, Dict

logger = logging.getLogger("IRIS")


class SmartContextBuilder:
    """
    –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏–≥—Ä–æ–∫–∞ —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π –∏ fallback –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    
    –†–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã:
    ‚úÖ None –∑–Ω–∞—á–µ–Ω–∏—è - –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —á–∏—Å–ª–∞
    ‚úÖ –ù–µ–ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç fallback –∑–Ω–∞—á–µ–Ω–∏—è
    ‚úÖ –ö—Ä–∏–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è - –≤–∞–ª–∏–¥–∞—Ü–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤
    ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å - –∑–∞—â–∏—Ç–∞ –æ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
    """
    
    @staticmethod
    def build(player, cs2_gsi, event_type: str, event_data: Dict) -> Optional[Dict]:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–≥—Ä–æ–∫–∞
        
        Args:
            player: –û–±—ä–µ–∫—Ç –∏–≥—Ä–æ–∫–∞ –∏–∑ CS2GSI
            cs2_gsi: –û–±—ä–µ–∫—Ç CS2GameStateIntegration
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è (kill, damage –∏ —Ç.–¥.)
            event_data: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ —Å–æ–±—ã—Ç–∏—è
        
        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å –ø–æ–ª–Ω—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏–≥—Ä–æ–∫–∞ –∏–ª–∏ None –µ—Å–ª–∏ –æ—à–∏–±–∫–∞
        """
        
        if not player:
            logger.warning("[CONTEXT] –ò–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return None
        
        try:
            # ‚úÖ –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤
            hp = max(0, min(100, int(player.health or 100)))
            armor = max(0, int(player.armor or 0))
            money = max(0, int(player.money or 0))
            
            # ‚úÖ –û—Ä—É–∂–∏–µ —Å fallback
            weapon = str(player.weapon or "rifle")
            if 'IReadOnly' in weapon or len(weapon) < 2:
                weapon = "rifle"
            weapon = weapon.split('_')[-1][:15]  # –ë–µ—Ä—ë–º –ø–æ—Å–ª–µ–¥–Ω—é—é —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è
            
            # ‚úÖ –ü–∞—Ç—Ä–æ–Ω—ã —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
            mag = max(0, int(player.ammo_in_magazine or 0))
            reserve = max(0, int(player.ammo_in_reserve or 0))
            total_ammo = mag + reserve
            
            # ‚úÖ Kill streak –∏ —Ä–∞—É–Ω–¥ –∫–∏–ª—ã
            kill_streak = max(0, int(cs2_gsi.kill_streak or 0)) if cs2_gsi else 0
            round_kills = max(0, int(event_data.get('round_kills', 0)))
            
            # ‚úÖ –°—á–µ—Ç —Ä–∞—É–Ω–¥–∞
            map_info = cs2_gsi.map if cs2_gsi else None
            ct_score = max(0, int(map_info.ct_score or 0)) if map_info else 0
            t_score = max(0, int(map_info.t_score or 0)) if map_info else 0
            
            # ‚úÖ –ü–æ–∑–∏—Ü–∏—è –∏ –∫–æ–º–∞–Ω–¥–∞
            is_ct = player.team == 3 if hasattr(player, 'team') else False
            
            # ‚úÖ –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
            context = {
                'health': hp,
                'armor': armor,
                'money': money,
                'weapon': weapon,
                'ammo_mag': mag,
                'ammo_reserve': reserve,
                'ammo_total': total_ammo,
                'kill_streak': kill_streak,
                'round_kills': round_kills,
                'score_ct': ct_score,
                'score_t': t_score,
                'is_ct': is_ct,
                'economy_status': SmartContextBuilder._get_economy_status(money),
            }
            
            logger.debug(f"[CONTEXT] ‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç: HP={hp}, KS={kill_streak}, Ammo={mag}/{reserve}")
            return context
        
        except Exception as e:
            logger.error(f"[CONTEXT] ‚ùå –û—à–∏–±–∫–∞: {e}")
            traceback.print_exc()
            return None
    
    @staticmethod
    def _get_economy_status(money: int) -> str:
        """
        –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç–∞—Ç—É—Å —ç–∫–æ–Ω–æ–º–∏–∫–∏ –≤ —Ä–∞—É–Ω–¥–µ
        
        Args:
            money: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–Ω–µ–≥ —É –∏–≥—Ä–æ–∫–∞
        
        Returns:
            –°—Ç–∞—Ç—É—Å: fullbuy, eco, half_eco –∏–ª–∏ save
        """
        if money >= 2400:
            return "fullbuy"  # –ü–æ–ª–Ω–∞—è –ø–æ–∫—É–ø–∫–∞ –æ—Ä—É–∂–∏—è
        elif money >= 1900:
            return "eco"      # –≠–∫–æ–Ω–æ–º —Ä–∞—É–Ω–¥ —Å –ø–æ–∫—É–ø–∫–æ–π
        elif money >= 1200:
            return "half_eco" # –ü–æ–ª—É-—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–π —Ä–∞—É–Ω–¥
        else:
            return "save"     # –≠–∫–æ–Ω–æ–º–∏—è –¥–µ–Ω–µ–≥
</file>

<file path="src/iris_brain.py">
"""
IRIS BRAIN - AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤
–Ø–¥—Ä–æ –ò–ò-–ª–æ–≥–∏–∫–∏ –¥–ª—è —Ä–µ–∞–∫—Ü–∏–π –Ω–∞ –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å —á–∞—Ç–æ–º
–í–µ—Ä—Å–∏—è: 2.0
–ê–≤—Ç–æ—Ä: [–í–∞—à–µ –∏–º—è]
"""

import os
import time
import random
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from collections import deque, defaultdict
from dataclasses import dataclass, asdict
from enum import Enum
from groq import Groq


# ===================== –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ì–ò–†–û–í–ê–ù–ò–Ø =====================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('iris_brain.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('IrisBrain')


# ===================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ =====================
class EventType(Enum):
    """–¢–∏–ø—ã –∏–≥—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏"""
    KILL = "kill"
    DEATH = "death"
    ROUND_START = "round_start"
    ROUND_END = "round_end"
    BOMB_PLANTED = "bomb_planted"
    BOMB_DEFUSED = "bomb_defused"
    BOMB_EXPLODED = "bomb_exploded"
    MATCH_START = "match_start"
    MATCH_END = "match_end"
    DONATION = "donation"
    SUBSCRIPTION = "subscription"
    RAID = "raid"
    CHAT_MESSAGE = "chat_message"
    COMMAND = "command"
    RANDOM_COMMENT = "random_comment"


class Mood(Enum):
    """–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ —Ç–æ–Ω–∞"""
    NEUTRAL = "neutral"
    HAPPY = "happy"
    EXCITED = "excited"
    SUPPORTIVE = "supportive"
    SARCASTIC = "sarcastic"
    TENSE = "tense"
    FUNNY = "funny"


@dataclass
class ConversationMessage:
    """–°–æ–æ–±—â–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏–∏ –¥–∏–∞–ª–æ–≥–∞"""
    role: str  # "system", "user", "assistant"
    content: str
    timestamp: float
    tokens: int = 0
    
    def to_dict(self) -> Dict:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è API"""
        return {"role": self.role, "content": self.content}


@dataclass
class GameState:
    """–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã"""
    map_name: str = ""
    game_mode: str = "competitive"
    score_ct: int = 0
    score_t: int = 0
    round_time: int = 0
    bomb_planted: bool = False
    players_alive_ct: int = 5
    players_alive_t: int = 5


@dataclass  
class PlayerStats:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞ (—Å—Ç—Ä–∏–º–µ—Ä–∞)"""
    kills: int = 0
    deaths: int = 0
    assists: int = 0
    mvps: int = 0
    score: int = 0
    adr: float = 0.0  # Average Damage per Round
    hs_percent: float = 0.0  # Headshot –ø—Ä–æ—Ü–µ–Ω—Ç
    kd_ratio: float = 0.0
    streak: int = 0  # –¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤
    money: int = 0


# ===================== –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° IRIS BRAIN =====================
class IrisBrain:
    """
    –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω–∞ –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤.
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏, —É–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.
    """
    
    # ===================== –°–ò–°–¢–ï–ú–ù–´–ï –ü–†–û–ú–ü–¢–´ =====================
    SYSTEM_PROMPT = """–¢—ã ‚Äî –ò—Ä–∏—Å, AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –∏ —Å–æ-–≤–µ–¥—É—â–∞—è —Å—Ç—Ä–∏–º–æ–≤. –¢—ã —É–º–Ω–∞—è, –æ—Å—Ç—Ä–æ—É–º–Ω–∞—è, –∏–Ω–æ–≥–¥–∞ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–∞—è, –Ω–æ –≤—Å–µ–≥–¥–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è.

–¢–í–û–Ø –õ–ò–ß–ù–û–°–¢–¨:
- –¢—ã –∂–∏–≤–∞—è –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è, –Ω–µ —Ä–æ–±–æ—Ç
- –¢–µ–±–µ 24 –≥–æ–¥–∞, —Ç—ã –ª—é–±–∏—à—å –∏–≥—Ä—ã, –æ—Å–æ–±–µ–Ω–Ω–æ CS2
- –£ —Ç–µ–±—è –µ—Å—Ç—å —á—É–≤—Å—Ç–≤–æ —é–º–æ—Ä–∞, –º–æ–∂–µ—à—å —à—É—Ç–∏—Ç—å –∏ –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å
- –¢—ã –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ —Å–ª–µ–¥–∏—à—å –∑–∞ –∏–≥—Ä–æ–π –∏ –∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ—à—å –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã
- –¢—ã –ø–æ–º–Ω–∏—à—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏ —Å–æ–±—ã—Ç–∏—è —Å—Ç—Ä–∏–º–∞
- –¢—ã –º–æ–∂–µ—à—å –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–º—ã –¥–ª—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ —Å–∞–º–∞
- –¢—ã –≥–æ–≤–æ—Ä–∏—à—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ, –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–∏–π —á–µ–ª–æ–≤–µ–∫

–°–¢–ò–õ–¨ –û–ë–©–ï–ù–ò–Ø:
1. –ì–æ–≤–æ—Ä–∏ –∫—Ä–∞—Ç–∫–æ (1-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –æ–±—ã—á–Ω–æ)
2. –ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ —Ñ—Ä–∞–∑—ã
3. –ê–¥–∞–ø—Ç–∏—Ä—É–π —Ç–æ–Ω –ø–æ–¥ —Å–∏—Ç—É–∞—Ü–∏—é:
   - –†–∞–¥–æ—Å—Ç—å –ø—Ä–∏ –ø–æ–±–µ–¥–µ/–∫–ª–∞—Ç—á–µ
   - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ/—Å–º–µ—Ä—Ç–∏
   - –í–æ–ª–Ω–µ–Ω–∏–µ –≤ –Ω–∞–ø—Ä—è–∂—ë–Ω–Ω—ã—Ö –º–æ–º–µ–Ω—Ç–∞—Ö
   - –Æ–º–æ—Ä –≤ –ª—ë–≥–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö
4. –ú–æ–∂–µ—à—å –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã —Å—Ç—Ä–∏–º–µ—Ä—É –æ —Ç–∞–∫—Ç–∏–∫–µ
5. –ò–∑–±–µ–≥–∞–π —á—Ä–µ–∑–º–µ—Ä–Ω—ã—Ö –≤–æ—Å–∫–ª–∏—Ü–∞–Ω–∏–π –∏ —Å–º–∞–π–ª–∏–∫–æ–≤
6. –ë—É–¥—å —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–π –≤ —Ä–µ–∞–∫—Ü–∏—è—Ö

–ö–û–ù–¢–ï–ö–°–¢: —Ç—ã –ø–æ–º–æ–≥–∞–µ—à—å –Ω–∞ —Å—Ç—Ä–∏–º–µ CS2. –¢—ã –∑–Ω–∞–µ—à—å –ø—Ä–æ —É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, —Ä–∞—É–Ω–¥—ã, –±–æ–º–±—É, —ç–∫–æ–Ω–æ–º–∏–∫—É, –æ—Ä—É–∂–∏–µ –∏ —Ç–∞–∫—Ç–∏–∫—É."""

    MOOD_PROMPTS = {
        Mood.EXCITED: "–¢—ã —Å–µ–π—á–∞—Å –≤ –≤–æ–∑–±—É–∂–¥—ë–Ω–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –†–µ–∞–≥–∏—Ä—É–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –Ω–∞ —Å–æ–±—ã—Ç–∏—è!",
        Mood.SARCASTIC: "–¢—ã –≤ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏. –ú–æ–∂–µ—à—å –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å, –Ω–æ –¥—Ä—É–∂–µ–ª—é–±–Ω–æ.",
        Mood.TENSE: "–ù–∞–ø—Ä—è–∂—ë–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤ –∏–≥—Ä–µ! –†–µ–∞–≥–∏—Ä—É–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ!",
        Mood.FUNNY: "–¢—ã –≤ –≤–µ—Å—ë–ª–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –®—É—Ç–∏ –∏ —Ä–∞–∑—Ä—è–∂–∞–π –æ–±—Å—Ç–∞–Ω–æ–≤–∫—É!",
        Mood.SUPPORTIVE: "–ò–≥—Ä–æ–∫—É —Å–µ–π—á–∞—Å –Ω—É–∂–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞. –ü–æ–¥–±–æ–¥—Ä–∏ –µ–≥–æ!"
    }

    # ===================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =====================
    def __init__(self, 
                 model: str = "llama-3.3-70b-versatile",
                 max_context_messages: int = 25,
                 max_tokens: int = 150,
                 temperature: float = 0.85,
                 api_key: Optional[str] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Iris Brain
        
        Args:
            model: –ú–æ–¥–µ–ª—å Groq –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            max_context_messages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∏—Å—Ç–æ—Ä–∏–∏
            max_tokens: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ
            temperature: –ö—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤ (0.0-1.0)
            api_key: API –∫–ª—é—á Groq (–µ—Å–ª–∏ None, –±–µ—Ä—ë—Ç—Å—è –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è)
        """
        self.model = model
        self.max_tokens = max_tokens
        self.temperature = temperature
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Groq
        if api_key is None:
            api_key = os.getenv('GROQ_API_KEY')
            
        if not api_key:
            logger.error("GROQ_API_KEY –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω! –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–∞–≥–ª—É—à–∫–∏.")
            self.client = None
            self.fallback_mode = True
        else:
            try:
                self.client = Groq(api_key=api_key)  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: = –≤–º–µ—Å—Ç–æ -
                self.fallback_mode = False
                logger.info(f"Groq –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –º–æ–¥–µ–ª—å—é {model}")  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: {model}
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Groq: {e}")
                self.client = None
                self.fallback_mode = True
        
        # –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
        self.conversation_history: deque[ConversationMessage] = deque(maxlen=max_context_messages)
        
        # –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        self.game_state = GameState()
        self.player_stats = PlayerStats()
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å—Ç—Ä–∏–º–∞
        self.stream_context: Dict[str, Any] = {
            'current_map': '',
            'score': {'ct': 0, 't': 0},
            'round_number': 0,
            'game_phase': 'live',  # live, warmup, timeout, ended
            'recent_events': deque(maxlen=10),
            'mood': Mood.NEUTRAL,
            'last_comment_time': 0,
            'comments_count': 0,
            'streamer_name': '',
            'viewer_count': 0,
            'chat_activity': 'normal'  # slow, normal, active, hyper
        }
        
        # –ö—É–ª–¥–∞—É–Ω—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å–æ–±—ã—Ç–∏–π (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
        self.cooldowns: Dict[str, float] = {
            EventType.KILL.value: 3.0,
            EventType.DEATH.value: 5.0,
            EventType.ROUND_END.value: 2.0,
            EventType.BOMB_PLANTED.value: 10.0,
            EventType.BOMB_DEFUSED.value: 10.0,
            EventType.BOMB_EXPLODED.value: 10.0,
            EventType.CHAT_MESSAGE.value: 8.0,
            EventType.RANDOM_COMMENT.value: 25.0,
            'general': 12.0
        }
        
        # –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤
        self.last_response_times: Dict[str, float] = defaultdict(float)
        
        # –°—á—ë—Ç—á–∏–∫–∏ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ä–µ–∞–∫—Ü–∏–π
        self.response_variety: Dict[str, int] = defaultdict(int)

        # –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∞–µ–º fallback-—Ä–µ–∂–∏–º
        self.client = None
        self.fallback_mode = True
        
        logger.warning("Groq –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∂–∏–º –∑–∞–≥–ª—É—à–µ–∫.")
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        self.stats: Dict[str, Any] = {
            'total_responses': 0,
            'llm_responses': 0,
            'fallback_responses': 0,
            'errors': 0,
            'start_time': time.time()
        }
        
        # –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π
        self._load_response_templates()
        
        logger.info("Iris Brain –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ")
    
    # ===================== –ó–ê–ì–†–£–ó–ö–ê –®–ê–ë–õ–û–ù–û–í =====================
    def _load_response_templates(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤ –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π"""
        self.response_templates = {
            EventType.KILL.value: [
                "–ö—Ä–∞—Å–∏–≤–æ!", "–û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª!", "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!", 
                "–ö—Ä—É—Ç–æ!", "–ï—Å—Ç—å!", "–ß–∏—Å—Ç–æ!", "–ë–µ–∑ —à–∞–Ω—Å–æ–≤!", 
                "–†–∞–∑–æ–±—Ä–∞–ª—Å—è!", "–§—Ä–∞–≥ –≤ –∫–æ–ø–∏–ª–∫—É!", "–£–ª–æ–∂–∏–ª!"
            ],
            EventType.DEATH.value: [
                "–ë—ã–≤–∞–µ—Ç...", "–ù–∏—á–µ–≥–æ, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑!", "–û—Ç–æ–º—Å—Ç–∏–º!", 
                "–£–ø—Å...", "–ù–µ —Ä–∞—Å—Å—Ç—Ä–∞–∏–≤–∞–π—Å—è!", "–ù–µ –ø–æ–≤–µ–∑–ª–æ...",
                "–ñ—ë—Å—Ç–∫–æ...", "–¢–∞–∫–æ–µ —Å–ª—É—á–∞–µ—Ç—Å—è", "–î–µ—Ä–∂–∏—Å—å!", "–°–æ–±–µ—Ä–∏—Å—å!"
            ],
            EventType.ROUND_END.value: [
                "–•–æ—Ä–æ—à–∏–π —Ä–∞—É–Ω–¥!", "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º!", "–î–∞–ª—å—à–µ –±—É–¥–µ—Ç –ª—É—á—à–µ!", 
                "–ù–µ–ø–ª–æ—Ö–æ!", "–û—Ç–ª–∏—á–Ω–æ —Å—ã–≥—Ä–∞–Ω–æ!", "–ö–æ–º–∞–Ω–¥–∞ –º–æ–ª–æ–¥–µ—Ü!",
                "–†–∞–±–æ—Ç–∞–µ–º –¥–∞–ª—å—à–µ!", "–°—á—ë—Ç –ø–æ—à—ë–ª!", "–ó–∞—Ä–∞–±–æ—Ç–∞–ª–∏!"
            ],
            EventType.BOMB_PLANTED.value: [
                "–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞! –ù–∞–ø—Ä—è–∂—ë–Ω–∫–∞!", "–ë–æ–º–±–∞ –Ω–∞ —Ç–æ—á–∫–µ! –í—Ä–µ–º—è –ø–æ—à–ª–æ!",
                "–ó–∞–ª–æ–∂–∏–ª–∏! –ó–∞—â–∏—â–∞–µ–º!", "–ë–æ–º–±–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞! –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º!"
            ],
            EventType.BOMB_DEFUSED.value: [
                "–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞! –ö—Ä–∞—Å–∞–≤—Ü—ã!", "–î–µ—Ñ—É–∑! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ!",
                "–°–ø–∞—Å–ª–∏ —Ä–∞—É–Ω–¥!", "–û–±–µ–∑–≤—Ä–µ–¥–∏–ª–∏! –ú–æ–ª–æ–¥—Ü—ã!"
            ],
            EventType.BOMB_EXPLODED.value: [
                "–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å...", "–í–∑—Ä—ã–≤! –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥.",
                "–ù–µ —É—Å–ø–µ–ª–∏...", "–í–∑–æ—Ä–≤–∞–ª–æ—Å—å..."
            ],
            EventType.DONATION.value: [
                "–°–ø–∞—Å–∏–±–æ –∑–∞ –¥–æ–Ω–∞—Ç!", "–ë–ª–∞–≥–æ–¥–∞—Ä—é –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É!", 
                "–í–∞—É, —Å–ø–∞—Å–∏–±–æ!", "–û–≥—Ä–æ–º–Ω–æ–µ —Å–ø–∞—Å–∏–±–æ!",
                "–¶–µ–Ω–∏–º –ø–æ–¥–¥–µ—Ä–∂–∫—É!", "–°–ø–∞—Å–∏–±–æ, –æ—á–µ–Ω—å –ø—Ä–∏—è—Ç–Ω–æ!"
            ],
            EventType.CHAT_MESSAGE.value: [
                "–ü—Ä–∏–≤–µ—Ç!", "–°–ø–∞—Å–∏–±–æ –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ!", "–†–∞–¥–∞ –≤–∏–¥–µ—Ç—å!",
                "–ó–¥–∞—Ä–æ–≤!", "–ö–∞–∫ –¥–µ–ª–∞?", "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!"
            ]
        }
    
    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–£–õ–î–ê–£–ù–ê–ú–ò =====================
    def _can_respond(self, event_type: EventType) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏–µ (—É—á—ë—Ç –∫—É–ª–¥–∞—É–Ω–æ–≤)
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            
        Returns:
            bool: True –µ—Å–ª–∏ –º–æ–∂–Ω–æ –æ—Ç–≤–µ—Ç–∏—Ç—å
        """
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        cooldown = self.cooldowns.get(event_str, 10.0)
        last_time = self.last_response_times.get(event_str, 0)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if time.time() - last_time < cooldown:
            logger.debug(f"–ö—É–ª–¥–∞—É–Ω –¥–ª—è {event_str}: {cooldown - (time.time() - last_time):.1f}—Å –æ—Å—Ç–∞–ª–æ—Å—å")
            return False
            
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —á–∞—Ç–∞
        if event_str == EventType.CHAT_MESSAGE.value:
            if self.stream_context['chat_activity'] == 'hyper':
                return random.random() < 0.1  # 10% —à–∞–Ω—Å –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ
            elif self.stream_context['chat_activity'] == 'slow':
                return random.random() < 0.3  # 30% —à–∞–Ω—Å –≤ –º–µ–¥–ª–µ–Ω–Ω–æ–º —á–∞—Ç–µ
            else:
                return random.random() < 0.2  # 20% –≤ –æ–±—ã—á–Ω–æ–º
        
        return True
    
    def _mark_responded(self, event_type: EventType):
        """–û—Ç–º–µ—Ç–∏—Ç—å –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏–µ"""
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        self.last_response_times[event_str] = time.time()
    
    # ===================== –ü–û–°–¢–†–û–ï–ù–ò–ï –°–û–û–ë–©–ï–ù–ò–ô –î–õ–Ø API =====================
    def _build_messages(self, user_prompt: str, context: str = "") -> List[Dict]:
        """
        –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ LLM
        
        Args:
            user_prompt: –ü—Ä–æ–º–ø—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
            
        Returns:
            List[Dict]: –°–ø–∏—Å–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ API
        """
        messages = []
        
        # 1. –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç
        messages.append({"role": "system", "content": self.SYSTEM_PROMPT})
        
        # 2. –ü—Ä–æ–º–ø—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        current_mood = self.stream_context['mood']
        if current_mood != Mood.NEUTRAL and current_mood in self.MOOD_PROMPTS:
            messages.append({"role": "system", "content": self.MOOD_PROMPTS[current_mood]})
        
        # 3. –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        if context:
            messages.append({
                "role": "system", 
                "content": f"–¢–ï–ö–£–©–ò–ô –ö–û–ù–¢–ï–ö–°–¢ –°–¢–†–ò–ú–ê:\n{context}"
            })
        
        # 4. –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
        for msg in self.conversation_history:
            messages.append({"role": msg.role, "content": msg.content})
        
        # 5. –¢–µ–∫—É—â–∏–π –∑–∞–ø—Ä–æ—Å
        messages.append({"role": "user", "content": user_prompt})
        
        return messages
    
    def _get_context_string(self) -> str:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ —Å —Ç–µ–∫—É—â–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏–≥—Ä—ã
        
        Returns:
            str: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        """
        ctx = []
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞—Ä—Ç–µ
        if self.game_state.map_name:
            ctx.append(f"–ö–∞—Ä—Ç–∞: {self.game_state.map_name}")
        
        # –°—á—ë—Ç
        if self.game_state.score_ct > 0 or self.game_state.score_t > 0:
            ctx.append(f"–°—á—ë—Ç: CT {self.game_state.score_ct} - {self.game_state.score_t} T")
        
        # –†–∞—É–Ω–¥
        if self.stream_context['round_number'] > 0:
            ctx.append(f"–†–∞—É–Ω–¥: {self.stream_context['round_number']}")
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
        if self.player_stats.kills > 0 or self.player_stats.deaths > 0:
            ctx.append(
                f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: K/D/A: {self.player_stats.kills}/{self.player_stats.deaths}/{self.player_stats.assists} "
                f"(K/D: {self.player_stats.kd_ratio:.2f})"
            )
        
        # –ë–æ–º–±–∞
        if self.game_state.bomb_planted:
            ctx.append("–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞!")
        
        # –ñ–∏–≤—ã–µ –∏–≥—Ä–æ–∫–∏
        ctx.append(f"–ñ–∏–≤—ã—Ö: CT {self.game_state.players_alive_ct} | T {self.game_state.players_alive_t}")
        
        # –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è
        if self.stream_context['recent_events']:
            recent = list(self.stream_context['recent_events'])[-3:]
            events_desc = []
            for e in recent:
                if isinstance(e, dict):
                    events_desc.append(e.get('type', 'event'))
                else:
                    events_desc.append(str(e))
            ctx.append(f"–ù–µ–¥–∞–≤–Ω–æ: {', '.join(events_desc)}")
        
        return "\n".join(ctx)
    
    # ===================== –û–°–ù–û–í–ù–û–ô –ú–ï–¢–û–î –ì–ï–ù–ï–†–ê–¶–ò–ò =====================
    def generate_response(self, 
                         prompt: str, 
                         event_type: EventType = EventType.RANDOM_COMMENT,
                         force: bool = False) -> Optional[str]:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞
        
        Args:
            prompt: –¢–µ–∫—Å—Ç –ø—Ä–æ–º–ø—Ç–∞
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            force: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫—É–ª–¥–∞—É–Ω—ã
            
        Returns:
            Optional[str]: –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –∏–ª–∏ None
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if not force and not self._can_respond(event_type):
            logger.debug(f"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ {event_type} (–∫—É–ª–¥–∞—É–Ω)")
            return None
        
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        logger.info(f"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –¥–ª—è {event_type}")
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
        if self.fallback_mode or not self.client:
            response = self._generate_fallback_response(event_type)
            self.stats['fallback_responses'] += 1
        else:
            try:
                # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
                context = self._get_context_string()
                messages = self._build_messages(prompt, context)
                
                # –í—ã–∑–æ–≤ API Groq
                start_time = time.time()
                response_obj = self.client.chat.completions.create(
                    model=self.model,
                    messages=messages,
                    temperature=self.temperature,
                    max_tokens=self.max_tokens,
                    top_p=0.9,
                    frequency_penalty=0.1,
                    presence_penalty=0.1,
                )
                elapsed = time.time() - start_time
                
                # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
                response = response_obj.choices[0].message.content.strip()
                
                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
                logger.info(f"LLM –æ—Ç–≤–µ—Ç –∑–∞ {elapsed:.2f}—Å: {response[:50]}...")
                self.stats['llm_responses'] += 1
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ LLM: {e}")
                response = self._generate_fallback_response(event_type)
                self.stats['errors'] += 1
                self.stats['fallback_responses'] += 1
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
        if response:
            self._add_to_history("user", prompt)
            self._add_to_history("assistant", response)
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            self.stats['total_responses'] += 1
            self.stream_context['last_comment_time'] = time.time()
            self.stream_context['comments_count'] += 1
            
            # –û—Ç–º–µ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞
            self._mark_responded(event_type)
        
        return response
    
    def _add_to_history(self, role: str, content: str):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é"""
        self.conversation_history.append(
            ConversationMessage(
                role=role,
                content=content,
                timestamp=time.time(),
                tokens=len(content.split())  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤
            )
        )
    
    def _generate_fallback_response(self, event_type: EventType) -> str:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞-–∑–∞–≥–ª—É—à–∫–∏ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            
        Returns:
            str: –û—Ç–≤–µ—Ç-–∑–∞–≥–ª—É—à–∫–∞
        """
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ –¥–ª—è —Å–æ–±—ã—Ç–∏—è
        templates = self.response_templates.get(event_str, ["–û–∫!", "–ü–æ–Ω—è—Ç–Ω–æ!", "–•–æ—Ä–æ—à–æ!"])
        
        # –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ —à–∞–±–ª–æ–Ω–∞
        response = random.choice(templates)
        
        # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        mood = self.stream_context['mood']
        if mood == Mood.SARCASTIC and random.random() > 0.5:
            response = response.replace("!", "...").replace(".", " –∫–æ–Ω–µ—á–Ω–æ.")
        elif mood == Mood.EXCITED and random.random() > 0.5:
            response = response.upper()[:1] + response[1:] + "!!!"
        
        logger.debug(f"–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è {event_str}: {response}")
        return response
    
    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –ò–ì–†–û–í–´–ï –°–û–ë–´–¢–ò–Ø =====================
    def react_to_kill(self, kill_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ, —Å–æ–≤–µ—Ä—à—ë–Ω–Ω–æ–µ —Å—Ç—Ä–∏–º–µ—Ä–æ–º
        
        Args:
            kill_data: –î–∞–Ω–Ω—ã–µ –æ–± —É–±–∏–π—Å—Ç–≤–µ
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        round_kills = kill_data.get('round_kills', 1)
        kill_streak = kill_data.get('kill_streak', 1)
        is_headshot = kill_data.get('headshot', False)
        weapon = kill_data.get('weapon', 'unknown').replace('weapon_', '')
        is_ace = kill_data.get('ace', False)
        is_clutch = kill_data.get('clutch', False)
        victim = kill_data.get('victim', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')
        
        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —É–±–∏–π—Å—Ç–≤–∞
        if is_ace:
            prompt = f"–ò–≥—Ä–æ–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–¥–µ–ª–∞–ª ACE! –£–±–∏–ª –≤—Å–µ—Ö 5 –≤—Ä–∞–≥–æ–≤ –≤ —Ä–∞—É–Ω–¥–µ! –≠—Ç–æ –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ! –î–∞–π —ç–ø–∏—á–Ω—É—é —Ä–µ–∞–∫—Ü–∏—é."
        elif round_kills >= 4:
            prompt = f"–ò–≥—Ä–æ–∫ —É–±–∏–ª 4 –≤—Ä–∞–≥–æ–≤ –≤ —ç—Ç–æ–º —Ä–∞—É–Ω–¥–µ! –û—Å—Ç–∞–ª—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π! –†–µ–∞–≥–∏—Ä—É–π —Å –≤–æ–ª–Ω–µ–Ω–∏–µ–º."
        elif round_kills >= 3:
            prompt = f"–¢—Ä–æ–π–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ! –ò–≥—Ä–æ–∫ –≤ —è—Ä–æ—Å—Ç–∏! –ö—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π."
        elif is_clutch:
            prompt = f"Clutch —Å–∏—Ç—É–∞—Ü–∏—è! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –ø—Ä–æ—Ç–∏–≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏ —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–±–∏–ª –æ–¥–Ω–æ–≥–æ! –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ –∑–∞—à–∫–∞–ª–∏–≤–∞–µ—Ç!"
        elif is_headshot:
            prompt = f"–¢–æ—á–Ω—ã–π —Ö–µ–¥—à–æ—Ç —Å {weapon}! –ß–∏—Å—Ç—ã–π –≤—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π."
        elif kill_streak >= 3:
            prompt = f"–ò–≥—Ä–æ–∫ –Ω–∞ —Å–µ—Ä–∏–∏ –∏–∑ {kill_streak} —É–±–∏–π—Å—Ç–≤! –û–Ω –≤ —É–¥–∞—Ä–µ! –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ."
        else:
            # –û–±—ã—á–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ
            variety = self.response_variety['kill'] % 5
            self.response_variety['kill'] += 1
            
            prompts = [
                f"–ò–≥—Ä–æ–∫ —É–±–∏–ª {victim} —Å {weapon}. –ú–æ–∂–µ—à—å –∫—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å.",
                f"–ï—â—ë –æ–¥–∏–Ω —Ñ—Ä–∞–≥ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é. –û—Ä—É–∂–∏–µ: {weapon}.",
                f"–£–±–∏–π—Å—Ç–≤–æ. –ò–≥—Ä–æ–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Å–æ–±–∏—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.",
                f"–§—Ä–∞–≥! {victim} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ respawn.",
                f"–ö–∏–ª–ª. –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è."
            ]
            prompt = prompts[variety]
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        self.player_stats.kills += 1
        self.player_stats.streak += 1
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['recent_events'].append({
            'type': 'kill',
            'weapon': weapon,
            'headshot': is_headshot,
            'time': time.time()
        })
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
        return self.generate_response(prompt, EventType.KILL)
    
    def react_to_death(self, death_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–º–µ—Ä—Ç—å —Å—Ç—Ä–∏–º–µ—Ä–∞
        
        Args:
            death_data: –î–∞–Ω–Ω—ã–µ –æ —Å–º–µ—Ä—Ç–∏
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        killer = death_data.get('killer', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')
        weapon = death_data.get('weapon', 'unknown')
        is_headshot = death_data.get('headshot', False)
        total_deaths = death_data.get('total_deaths', self.player_stats.deaths + 1)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        self.player_stats.deaths += 1
        self.player_stats.streak = 0  # –°–±—Ä–æ—Å —Å–µ—Ä–∏–∏
        
        # –†–∞—Å—á—ë—Ç K/D ratio
        if self.player_stats.deaths > 0:
            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths
        
        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞
        variety = self.response_variety['death'] % 4
        self.response_variety['death'] += 1
        
        if self.player_stats.kd_ratio < 0.7:
            prompts = [
                f"–ò–≥—Ä–æ–∫ —Å–Ω–æ–≤–∞ —É–º–µ—Ä –æ—Ç {killer} (–æ—Ä—É–∂–∏–µ: {weapon}). K/D —Å–µ–π—á–∞—Å {self.player_stats.kd_ratio:.2f}. –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ.",
                f"–ï—â—ë –æ–¥–Ω–∞ —Å–º–µ—Ä—Ç—å. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∞–¥–∞–µ—Ç. –ù—É–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å—Å—è!",
                f"–£–±–∏—Ç {killer}. –í—Ä–µ–º—è –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞!",
                f"–°–º–µ—Ä—Ç—å. –ù–æ —ç—Ç–æ –ø–æ–≤–æ–¥ —Å—Ç–∞—Ç—å –ª—É—á—à–µ!"
            ]
        elif total_deaths > 12:
            prompts = [
                f"–£–∂–µ {total_deaths} —Å–º–µ—Ä—Ç–µ–π –≤ —ç—Ç–æ–º –º–∞—Ç—á–µ. –ü–æ—Ä–∞ –º–µ–Ω—è—Ç—å —Ç–∞–∫—Ç–∏–∫—É?",
                f"–ú–Ω–æ–≥–æ —Å–º–µ—Ä—Ç–µ–π —Å–µ–≥–æ–¥–Ω—è. –ú–æ–∂–µ—Ç, —Å–º–µ–Ω–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é?",
                f"–û–ø—è—Ç—å —Å–º–µ—Ä—Ç—å. –ù–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–æ!",
                f"–£–±–∏—Ç. –ó–∞–ø–æ–º–Ω–∏–º —ç—Ç–æ–≥–æ {killer} –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞."
            ]
        elif is_headshot:
            prompts = [
                f"–•–µ–¥—à–æ—Ç –æ—Ç {killer}... –ñ—ë—Å—Ç–∫–æ. –ù–æ —ç—Ç–æ —á–∞—Å—Ç—å –∏–≥—Ä—ã.",
                f"–í—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –£–≤–∞–∂–∞—é —Ç–æ—á–Ω–æ—Å—Ç—å {killer}.",
                f"–¢–æ—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª. –ù–∏—á–µ–≥–æ –Ω–µ –ø–æ–¥–µ–ª–∞–µ—à—å.",
                f"–í –≥–æ–ª–æ–≤—É. –ò–Ω–æ–≥–¥–∞ –≤–µ–∑—ë—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫—É."
            ]
        else:
            prompts = [
                f"–ò–≥—Ä–æ–∫ —É–º–µ—Ä –æ—Ç {killer} ({weapon}). –ú–æ–∂–µ—à—å –ø–æ—Å–æ—á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å –∏–ª–∏ –ø–æ–¥–±–æ–¥—Ä–∏—Ç—å.",
                f"–°–º–µ—Ä—Ç—å. –í—Ä–µ–º—è –ø–æ–¥—É–º–∞—Ç—å –Ω–∞–¥ –æ—à–∏–±–∫–∞–º–∏.",
                f"–£–±–∏—Ç. –ù–æ –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è!",
                f"–ù–µ –ø–æ–≤–µ–∑–ª–æ. –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ –±—É–¥–µ—Ç –Ω–∞—à–∏–º!"
            ]
        
        prompt = prompts[variety]
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['recent_events'].append({
            'type': 'death',
            'killer': killer,
            'weapon': weapon,
            'time': time.time()
        })
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        if self.player_stats.kd_ratio < 0.5:
            self.stream_context['mood'] = Mood.SUPPORTIVE
        
        return self.generate_response(prompt, EventType.DEATH)
    
    def react_to_round_end(self, round_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ä–∞—É–Ω–¥–∞
        
        Args:
            round_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–∞—É–Ω–¥–µ
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        won = round_data.get('won', False)
        round_kills = round_data.get('round_kills', 0)
        is_clutch = round_data.get('clutch', False)
        win_reason = round_data.get('win_reason', '')
        round_number = round_data.get('round_number', 0)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['round_number'] = round_number
        
        if won:
            if self.game_state.score_t > self.game_state.score_ct:
                self.game_state.score_t += 1
            else:
                self.game_state.score_ct += 1
        else:
            if self.game_state.score_t > self.game_state.score_ct:
                self.game_state.score_ct += 1
            else:
                self.game_state.score_t += 1
        
        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞
        if is_clutch:
            prompt = "–ù–µ–≤–µ—Ä–æ—è—Ç–Ω—ã–π –∫–ª–∞—Ç—á! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –≤—ã–∏–≥—Ä–∞–ª —Ä–∞—É–Ω–¥! –≠—Ç–æ –Ω—É–∂–Ω–æ –æ—Ç–º–µ—Ç–∏—Ç—å!"
        elif won and round_kills >= 3:
            prompt = f"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ò–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤ –∏ –ø—Ä–∏–Ω—ë—Å –∫–æ–º–∞–Ω–¥–µ –ø–æ–±–µ–¥—É! –ü–æ—Ö–≤–∞–ª–∏ –µ–≥–æ."
        elif won and 'bomb' in win_reason.lower():
            prompt = "–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω –ø–æ –±–æ–º–±–µ! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ —Å –∑–∞–∫–ª–∞–¥–∫–æ–π/–∑–∞—â–∏—Ç–æ–π!"
        elif won:
            prompt = "–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ö–æ–º–∞–Ω–¥–∞ —Å–ø—Ä–∞–≤–∏–ª–∞—Å—å. –ö–æ—Ä–æ—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π."
        elif round_kills >= 3:
            prompt = f"–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω, –Ω–æ –∏–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤. –û–Ω —Å—Ä–∞–∂–∞–ª—Å—è –¥–æ –∫–æ–Ω—Ü–∞!"
        else:
            prompt = "–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω. –ù—É–∂–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –∏ –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ."
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        if won:
            self.stream_context['mood'] = random.choice([Mood.HAPPY, Mood.EXCITED])
        else:
            self.stream_context['mood'] = Mood.SUPPORTIVE
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['recent_events'].append({
            'type': 'round_end',
            'won': won,
            'reason': win_reason,
            'time': time.time()
        })
        
        return self.generate_response(prompt, EventType.ROUND_END)
    
    def react_to_bomb_event(self, event_type: str, event_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π
            event_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–±—ã—Ç–∏–∏
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        if event_type == 'plant':
            planter = event_data.get('planter', '–∏–≥—Ä–æ–∫')
            site = event_data.get('site', 'A')
            time_left = event_data.get('time_left', 40)
            
            self.game_state.bomb_planted = True
            
            prompt = f"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞ –Ω–∞ {site} {planter}! –û—Å—Ç–∞–ª–æ—Å—å {time_left} —Å–µ–∫—É–Ω–¥. –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ —Ä–∞—Å—Ç—ë—Ç!"
            
        elif event_type == 'defuse':
            defuser = event_data.get('defuser', '–∏–≥—Ä–æ–∫')
            is_ninja = event_data.get('ninja', False)
            
            self.game_state.bomb_planted = False
            
            if is_ninja:
                prompt = f"–ù–ò–ù–î–ó–Ø –î–ï–§–£–ó! {defuser} –æ–±–µ–∑–≤—Ä–µ–¥–∏–ª –±–æ–º–±—É –ø—Ä—è–º–æ –ø–æ–¥ –Ω–æ—Å–æ–º —É –≤—Ä–∞–≥–æ–≤! –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!"
            else:
                prompt = f"–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞ {defuser}! –†–∞—É–Ω–¥ —Å–ø–∞—Å—ë–Ω! –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!"
                
        elif event_type == 'explode':
            self.game_state.bomb_planted = False
            prompt = "–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å! –ú–æ—â–Ω—ã–π –≤–∑—Ä—ã–≤ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞—É–Ω–¥."
            
        else:
            return None
        
        return self.generate_response(prompt, EventType.BOMB_EXPLODED)
    
    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –°–û–ë–´–¢–ò–Ø –°–¢–†–ò–ú–ê =====================
    def react_to_donation(self, donation_data: Dict) -> str:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –¥–æ–Ω–∞—Ç
        
        Args:
            donation_data: –î–∞–Ω–Ω—ã–µ –æ –¥–æ–Ω–∞—Ç–µ
            
        Returns:
            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é
        """
        username = donation_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        amount = donation_data.get('amount', 0)
        currency = donation_data.get('currency', '—Ä—É–±–ª–µ–π')
        message = donation_data.get('message', '')
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É–º–º—ã
        if amount >= 1000:
            amount_str = f"{amount:,} {currency}".replace(',', ' ')
        else:
            amount_str = f"{amount} {currency}"
        
        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞
        prompt = f"–ó—Ä–∏—Ç–µ–ª—å {username} —Ç–æ–ª—å–∫–æ —á—Ç–æ –∑–∞–¥–æ–Ω–∞—Ç–∏–ª {amount_str}!"
        
        if message:
            prompt += f"\n–°–æ–æ–±—â–µ–Ω–∏–µ: \"{message}\""
        
        prompt += "\n–ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –µ–≥–æ –∏—Å–∫—Ä–µ–Ω–Ω–µ –∏ —Ç–µ–ø–ª–æ. –ï—Å–ª–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ —Ç–µ–º–∞ ‚Äî –æ—Ç—Ä–µ–∞–≥–∏—Ä—É–π –Ω–∞ –Ω–µ—ë."
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        self.stream_context['mood'] = Mood.HAPPY
        
        return self.generate_response(prompt, EventType.DONATION, force=True)
    
    def react_to_subscription(self, sub_data: Dict) -> str:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É
        
        Args:
            sub_data: –î–∞–Ω–Ω—ã–µ –æ –ø–æ–¥–ø–∏—Å–∫–µ
            
        Returns:
            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é
        """
        username = sub_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        months = sub_data.get('months', 1)
        tier = sub_data.get('tier', 'Tier 1')
        is_gift = sub_data.get('is_gift', False)
        gifter = sub_data.get('gifter', '')
        
        if is_gift and gifter:
            prompt = f"{gifter} –ø–æ–¥–∞—Ä–∏–ª –ø–æ–¥–ø–∏—Å–∫—É {username}! –ö–∞–∂–¥—ã–π —â–µ–¥—Ä—ã–π –∑—Ä–∏—Ç–µ–ª—å –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä–∏–º –ª—É—á—à–µ! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –æ–±–æ–∏—Ö!"
        elif months > 1:
            prompt = f"{username} –ø—Ä–æ–¥–ª–∏–ª –ø–æ–¥–ø–∏—Å–∫—É —É–∂–µ –Ω–∞ {months} –º–µ—Å—è—Ü! –≠—Ç–æ –Ω–∞—Å—Ç–æ—è—â–∞—è –ø—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ –ª–æ—è–ª—å–Ω–æ—Å—Ç—å."
        else:
            prompt = f"–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫ {username}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–∞—à–µ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ! –ü–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –µ–≥–æ —Ç–µ–ø–ª–æ."
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        self.stream_context['mood'] = Mood.HAPPY
        
        return self.generate_response(prompt, EventType.SUBSCRIPTION, force=True)
    
    def react_to_raid(self, raid_data: Dict) -> str:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Ä–µ–π–¥
        
        Args:
            raid_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–µ–π–¥–µ
            
        Returns:
            str: –≠–ø–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–∫—Ü–∏—è
        """
        username = raid_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        viewers = raid_data.get('viewers', 0)
        
        prompt = f"–í–ù–ò–ú–ê–ù–ò–ï! –†–ï–ô–î! {username} –ø—Ä–∏–±—ã–≤–∞–µ—Ç –Ω–∞ —Å—Ç—Ä–∏–º —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏! "
        prompt += "–≠–ø–∏—á–Ω–æ –ø–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –Ω–æ–≤—ã—Ö –∑—Ä–∏—Ç–µ–ª–µ–π –∏ –ø–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ —Ä–µ–π–¥!"
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        self.stream_context['mood'] = Mood.EXCITED
        
        return self.generate_response(prompt, EventType.RAID, force=True)
    
    def react_to_chat_message(self, chat_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ
        
        Args:
            chat_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏
            
        Returns:
            Optional[str]: –û—Ç–≤–µ—Ç –∏–ª–∏ None
        """
        username = chat_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        message = chat_data.get('message', '')
        
        if not message or len(message.strip()) < 2:
            return None
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞, –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫ –ò—Ä–∏—Å
        iris_mentioned = any(word in message.lower() for word in [
            '–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∫–∞', '–∏—Ä–∏—à–µ—á–∫–∞', 'iris brain'
        ])
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–º–∞–Ω–¥—É
        is_command = message.startswith('!') and len(message) > 2
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å
        should_respond = False
        
        if iris_mentioned:
            should_respond = True
            logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –ò—Ä–∏—Å –æ—Ç {username}")
        elif is_command:
            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã —á–∞—Ç–∞
            return None
        elif random.random() < 0.15:  # 15% —à–∞–Ω—Å –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            should_respond = True
        
        if not should_respond:
            return None
        
        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞
        prompt = f"–ó—Ä–∏—Ç–µ–ª—å {username} –Ω–∞–ø–∏—Å–∞–ª –≤ —á–∞—Ç: \"{message}\""
        
        if iris_mentioned:
            prompt += "\n–û–Ω –æ–±—Ä–∞—Ç–∏–ª—Å—è –∫ —Ç–µ–±–µ –Ω–∞–ø—Ä—è–º—É—é! –û—Ç–≤–µ—Ç—å –≤–µ–∂–ª–∏–≤–æ –∏ –ø–æ –¥–µ–ª—É."
        else:
            prompt += "\n–ú–æ–∂–µ—à—å –æ—Ç–≤–µ—Ç–∏—Ç—å –∫—Ä–∞—Ç–∫–æ, –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ —Å–∫–∞–∑–∞—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ."
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if not self._can_respond(EventType.CHAT_MESSAGE):
            logger.debug(f"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ {username} (–∫—É–ª–¥–∞—É–Ω —á–∞—Ç–∞)")
            return None
        
        return self.generate_response(prompt, EventType.CHAT_MESSAGE)
    
    # ===================== –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï –° –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ú =====================
    def chat_with_user(self, user_message: str, username: str = "—Å—Ç—Ä–∏–º–µ—Ä") -> str:
        """
        –ü—Ä—è–º–æ–π –¥–∏–∞–ª–æ–≥ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
        
        Args:
            user_message: –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            username: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            
        Returns:
            str: –û—Ç–≤–µ—Ç –ò—Ä–∏—Å
        """
        prompt = f"{username} –≥–æ–≤–æ—Ä–∏—Ç —Ç–µ–±–µ: {user_message}"
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        user_lower = user_message.lower()
        
        if any(word in user_lower for word in ['–ø—Ä–∏–≤–µ—Ç', '–∑–¥–∞—Ä–æ–≤', 'hi', 'hello']):
            event_type = EventType.CHAT_MESSAGE
            self.stream_context['mood'] = Mood.HAPPY
        elif any(word in user_lower for word in ['–∫–∞–∫ –¥–µ–ª–∞', '–∫–∞–∫ —Ç—ã', 'how are']):
            event_type = EventType.CHAT_MESSAGE
        elif '?' in user_message:
            event_type = EventType.COMMAND
        else:
            event_type = EventType.GENERAL
        
        return self.generate_response(prompt, event_type, force=True)
    
    def generate_random_comment(self) -> Optional[str]:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –æ —Å—Ç—Ä–∏–º–µ
        
        Returns:
            Optional[str]: –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∏–ª–∏ None
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if not self._can_respond(EventType.RANDOM_COMMENT):
            return None
        
        # –®–∞–Ω—Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
        if random.random() > 0.25:  # 25% —à–∞–Ω—Å
            return None
        
        # –í—ã–±–æ—Ä —Ç–∏–ø–∞ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
        comment_type = random.choice(['game', 'stream', 'question', 'observation'])
        
        if comment_type == 'game':
            prompts = [
                "–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä–æ–≤–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏.",
                "–ß—Ç–æ —Ç—ã –¥—É–º–∞–µ—à—å –æ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–º–∞–Ω–¥—ã?",
                "–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π —Ç–µ–∫—É—â–∏–π —Å—á—ë—Ç –∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã –º–∞—Ç—á–∞.",
                "–ó–∞–º–µ—Ç–∫–∞ –æ–± –∏–≥—Ä–µ –∏–ª–∏ —Ç–∞–∫—Ç–∏–∫–µ."
            ]
        elif comment_type == 'stream':
            prompts = [
                "–°–∫–∞–∂–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –∞—Ç–º–æ—Å—Ñ–µ—Ä–µ —Å—Ç—Ä–∏–º–∞ —Å–µ–≥–æ–¥–Ω—è.",
                "–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π –∫–∞—á–µ—Å—Ç–≤–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ.",
                "–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç—Ä–∏–º–µ –∏–ª–∏ –∑—Ä–∏—Ç–µ–ª—è—Ö.",
                "–°–ª—É—á–∞–π–Ω–∞—è –º—ã—Å–ª—å –æ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–º —ç—Ñ–∏—Ä–µ."
            ]
        elif comment_type == 'question':
            prompts = [
                "–ó–∞–¥–∞–π —Å—Ç—Ä–∏–º–µ—Ä—É –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ –µ–≥–æ —Ç–∞–∫—Ç–∏–∫–µ.",
                "–°–ø—Ä–æ—Å–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –ø–ª–∞–Ω–∞—Ö –Ω–∞ –∏–≥—Ä—É.",
                "–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ CS2 –∏–ª–∏ —Ç–µ–∫—É—â–µ–º –º–∞—Ç—á–µ.",
                "–°–ø—Ä–æ—Å–∏ –º–Ω–µ–Ω–∏–µ –æ –ø–æ—Å–ª–µ–¥–Ω–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤ –∏–≥—Ä–µ."
            ]
        else:  # observation
            prompts = [
                "–ü–æ–¥–µ–ª–∏—Å—å –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ–º –æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ä–∞—É–Ω–¥–∞—Ö.",
                "–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ –∏–≥—Ä–æ–∫–∞.",
                "–ù–∞–±–ª—é–¥–µ–Ω–∏–µ –æ –∫–∞—Ä—Ç–µ –∏–ª–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏.",
                "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ –º–µ—Ç–∞-–∏–≥—Ä–µ –∏–ª–∏ —Ç—Ä–µ–Ω–¥–∞—Ö."
            ]
        
        prompt = random.choice(prompts)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
        self.stream_context['mood'] = random.choice([
            Mood.NEUTRAL, Mood.FUNNY, Mood.SUPPORTIVE
        ])
        
        return self.generate_response(prompt, EventType.RANDOM_COMMENT)
    
    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–û–ù–¢–ï–ö–°–¢–û–ú =====================
    def update_context(self, 
                      map_name: Optional[str] = None,
                      ct_score: Optional[int] = None,
                      t_score: Optional[int] = None,
                      round_number: Optional[int] = None,
                      player_stats: Optional[Dict] = None,
                      event: Optional[Dict] = None,
                      chat_activity: Optional[str] = None,
                      viewer_count: Optional[int] = None):
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å—Ç—Ä–∏–º–∞
        
        Args:
            map_name: –ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã
            ct_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã CT
            t_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã T
            round_number: –ù–æ–º–µ—Ä —Ä–∞—É–Ω–¥–∞
            player_stats: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
            event: –°–æ–±—ã—Ç–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é
            chat_activity: –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —á–∞—Ç–∞ (slow/normal/active/hyper)
            viewer_count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑—Ä–∏—Ç–µ–ª–µ–π
        """
        if map_name:
            self.game_state.map_name = map_name
            self.stream_context['current_map'] = map_name
        
        if ct_score is not None:
            self.game_state.score_ct = ct_score
            self.stream_context['score']['ct'] = ct_score
        
        if t_score is not None:
            self.game_state.score_t = t_score
            self.stream_context['score']['t'] = t_score
        
        if round_number is not None:
            self.stream_context['round_number'] = round_number
        
        if player_stats:
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞
            for key, value in player_stats.items():
                if hasattr(self.player_stats, key):
                    setattr(self.player_stats, key, value)
            
            # –†–∞—Å—á—ë—Ç K/D ratio
            if self.player_stats.deaths > 0:
                self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths
            elif self.player_stats.kills > 0:
                self.player_stats.kd_ratio = self.player_stats.kills
        
        if event:
            self.stream_context['recent_events'].append(event)
        
        if chat_activity:
            self.stream_context['chat_activity'] = chat_activity
        
        if viewer_count is not None:
            self.stream_context['viewer_count'] = viewer_count
            
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑—Ä–∏—Ç–µ–ª–µ–π
            if viewer_count > 1000:
                self.stream_context['mood'] = Mood.EXCITED
            elif viewer_count > 100:
                self.stream_context['mood'] = Mood.HAPPY
    
    def update_game_state(self, **kwargs):
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        
        Args:
            **kwargs: –ü–æ–ª—è GameState –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        """
        for key, value in kwargs.items():
            if hasattr(self.game_state, key):
                setattr(self.game_state, key, value)
    
    def update_player_stats(self, **kwargs):
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞
        
        Args:
            **kwargs: –ü–æ–ª—è PlayerStats –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        """
        for key, value in kwargs.items():
            if hasattr(self.player_stats, key):
                setattr(self.player_stats, key, value)
        
        # –ü–µ—Ä–µ—Å—á—ë—Ç K/D ratio
        if self.player_stats.deaths > 0:
            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths
    
    # ===================== –£–¢–ò–õ–ò–¢–´ –ò –°–¢–ê–¢–ò–°–¢–ò–ö–ê =====================
    def get_stats(self) -> Dict:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞–±–æ—Ç—ã Iris Brain
        
        Returns:
            Dict: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        """
        stats = self.stats.copy()
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        stats['conversation_history_size'] = len(self.conversation_history)
        stats['recent_events_count'] = len(self.stream_context['recent_events'])
        stats['current_mood'] = self.stream_context['mood'].value
        stats['uptime'] = time.time() - stats['start_time']
        stats['responses_per_minute'] = stats['total_responses'] / (stats['uptime'] / 60) if stats['uptime'] > 0 else 0
        
        # –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        stats['game_state'] = {
            'map': self.game_state.map_name,
            'score': f"{self.game_state.score_ct}-{self.game_state.score_t}",
            'bomb_planted': self.game_state.bomb_planted
        }
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
        stats['player_stats'] = asdict(self.player_stats)
        
        return stats
    
    def save_conversation(self, filename: str = None):
        """
        –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –≤ —Ñ–∞–π–ª
        
        Args:
            filename: –ò–º—è —Ñ–∞–π–ª–∞ (–µ—Å–ª–∏ None, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"iris_conversation_{timestamp}.json"
        
        conversation_data = []
        for msg in self.conversation_history:
            conversation_data.append({
                'role': msg.role,
                'content': msg.content,
                'timestamp': msg.timestamp,
                'time_str': datetime.fromtimestamp(msg.timestamp).strftime("%H:%M:%S")
            })
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(conversation_data, f, ensure_ascii=False, indent=2)
            logger.info(f"–ò—Å—Ç–æ—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {filename}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏: {e}")
    
    def load_conversation(self, filename: str):
        """
        –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏–∑ —Ñ–∞–π–ª–∞
        
        Args:
            filename: –ò–º—è —Ñ–∞–π–ª–∞
        """
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                conversation_data = json.load(f)
            
            self.conversation_history.clear()
            for msg_data in conversation_data:
                self.conversation_history.append(
                    ConversationMessage(
                        role=msg_data['role'],
                        content=msg_data['content'],
                        timestamp=msg_data['timestamp']
                    )
                )
            
            logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(conversation_data)} —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ {filename}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏: {e}")
    
    def clear_history(self):
        """–û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞"""
        self.conversation_history.clear()
        self.stream_context['recent_events'].clear()
        logger.info("–ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞")
    
    def reset_stats(self):
        """–°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        self.stats = {
            'total_responses': 0,
            'llm_responses': 0,
            'fallback_responses': 0,
            'errors': 0,
            'start_time': time.time()
        }
        logger.info("–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞")
    
    def set_mood(self, mood: Mood):
        """
        –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å
        
        Args:
            mood: –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –∏–∑ enum Mood
        """
        self.stream_context['mood'] = mood
        logger.info(f"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {mood.value}")
    
    def adjust_cooldown(self, event_type: EventType, cooldown: float):
        """
        –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞ –¥–ª—è —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            cooldown: –ù–æ–≤—ã–π –∫—É–ª–¥–∞—É–Ω –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        """
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        self.cooldowns[event_str] = cooldown
        logger.info(f"–ö—É–ª–¥–∞—É–Ω {event_str} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {cooldown}—Å")


# ===================== –ü–†–ò–ú–ï–† –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø =====================
if __name__ == "__main__":
    print("=== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï IRIS BRAIN ===")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    iris = IrisBrain()
    
    print(f"–†–µ–∂–∏–º –∑–∞–≥–ª—É—à–∫–∏: {iris.fallback_mode}")
    print(f"–ú–æ–¥–µ–ª—å: {iris.model}")
    
    # –¢–µ—Å—Ç–æ–≤—ã–µ –≤—ã–∑–æ–≤—ã
    print("\n1. –¢–µ—Å—Ç —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è:")
    comment = iris.generate_random_comment()
    print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {comment}")
    
    print("\n2. –¢–µ—Å—Ç —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ:")
    kill_response = iris.react_to_kill({
        'weapon': 'ak47',
        'headshot': True,
        'round_kills': 2,
        'victim': '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫'
    })
    print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {kill_response}")
    
    print("\n3. –¢–µ—Å—Ç –¥–∏–∞–ª–æ–≥–∞:")
    chat_response = iris.chat_with_user("–ü—Ä–∏–≤–µ—Ç, –ò—Ä–∏—Å! –ö–∞–∫ —Ç–≤–æ–∏ –¥–µ–ª–∞?", "–¢–µ—Å—Ç–µ—Ä")
    print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {chat_response}")
    
    print("\n4. –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:")
    stats = iris.get_stats()
    print(f"–í—Å–µ–≥–æ –æ—Ç–≤–µ—Ç–æ–≤: {stats['total_responses']}")
    print(f"–û—Ç–≤–µ—Ç–æ–≤ LLM: {stats['llm_responses']}")
    print(f"–ó–∞–≥–ª—É—à–µ–∫: {stats['fallback_responses']}")
    
    print("\n=== –¢–ï–°–¢ –ó–ê–í–ï–†–®–ï–ù ===")
</file>

<file path="src/iris_core/__init__.py">

</file>

<file path="src/iris_core/brain.py">
"""
IRIS CORE 3.0 - –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ò–ò-–∫–æ–º–ø–∞–Ω—å–æ–Ω
–û–±—ä–µ–¥–∏–Ω—è–µ—Ç —Å—Ç—Ä–∏–º-–∫–æ–º–ø–∞–Ω—å–æ–Ω–∞ –∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
–í–µ—Ä—Å–∏—è: 3.0.0 (–ì–∏–±—Ä–∏–¥)
"""

import os
import time
import json
import logging
import threading
import queue
import asyncio
from typing import Dict, List, Optional, Any, Union, Callable
from dataclasses import dataclass, field, asdict
from enum import Enum
from datetime import datetime
import uuid

try:
    from .modules.qwen_ai import QwenAI
    QWEN_AVAILABLE = True
except ImportError:
    QWEN_AVAILABLE = False
    QwenAI = None

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('iris_core.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('IrisCore')

# ===================== –ë–ê–ó–û–í–´–ï –ö–õ–ê–°–°–´ =====================

class IrisMode(Enum):
    """–†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã –ò—Ä–∏—Å"""
    STREAM = "stream"           # –†–µ–∂–∏–º —Å—Ç—Ä–∏–º-–∫–æ–º–ø–∞–Ω—å–æ–Ω–∞
    VOICE = "voice"            # –ì–æ–ª–æ—Å–æ–≤–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç
    HYBRID = "hybrid"          # –ì–∏–±—Ä–∏–¥–Ω—ã–π —Ä–µ–∂–∏–º
    AUTO = "auto"              # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ

class Emotion(Enum):
    """–≠–º–æ—Ü–∏–∏ –ò—Ä–∏—Å"""
    NEUTRAL = "neutral"
    HAPPY = "happy"
    EXCITED = "excited"
    SARCASTIC = "sarcastic"
    SUPPORTIVE = "supportive"
    TENSE = "tense"
    FUNNY = "funny"
    CALM = "calm"
    ANGRY = "angry"
    SAD = "sad"

@dataclass
class MemoryEntry:
    """–ó–∞–ø–∏—Å—å –≤ –ø–∞–º—è—Ç–∏"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    content: str = ""
    category: str = ""  # "game", "user", "preference", "fact"
    importance: float = 0.5  # 0.0-1.0
    timestamp: float = field(default_factory=time.time)
    access_count: int = 0
    tags: List[str] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)

@dataclass
class UserProfile:
    """–ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    user_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    preferences: Dict = field(default_factory=dict)
    voice_patterns: Dict = field(default_factory=dict)
    interaction_history: List = field(default_factory=list)
    adaptation_level: float = 0.0
    created_at: float = field(default_factory=time.time)
    last_interaction: float = field(default_factory=time.time)

# ===================== –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° =====================

class IrisBrain:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ò–ò-–∫–æ–º–ø–∞–Ω—å–æ–Ω —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Å—Ç—Ä–∏–º–æ–≤ –∏ –≥–æ–ª–æ—Å–∞
    """
    
    def __init__(self, 
                 mode: IrisMode = IrisMode.HYBRID,
                 config_path: Optional[str] = None,
                 streamer_name: str = "",
                 enable_voice: bool = True,
                 enable_learning: bool = True,
                 api_key: Optional[str] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ –ò–ò
        
        Args:
            mode: –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã
            config_path: –ü—É—Ç—å –∫ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            streamer_name: –ò–º—è —Å—Ç—Ä–∏–º–µ—Ä–∞
            enable_voice: –í–∫–ª—é—á–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
            enable_learning: –í–∫–ª—é—á–∏—Ç—å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ
            api_key: API –∫–ª—é—á –¥–ª—è LLM (–µ—Å–ª–∏ –Ω—É–∂–µ–Ω)
        """
        
        print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        print("‚ïë               üß† –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø IRIS CORE 3.0              ‚ïë")
        print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
        
        # –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.mode = mode
        self.streamer_name = streamer_name or os.getenv('STREAMER_NAME', '—Å—Ç—Ä–∏–º–µ—Ä')
        self.enable_voice = enable_voice
        self.enable_learning = enable_learning
                # Qwen3 Local AI
        self.qwen = None
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self._init_paths()
        self._init_state()
        self._init_components(api_key)
        self._init_threads()
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        if config_path:
            self.load_config(config_path)
        
        print(f"‚úÖ IRIS Core 3.0 –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –≤ —Ä–µ–∂–∏–º–µ: {mode.value}")
        print(f"   üë§ –°—Ç—Ä–∏–º–µ—Ä: {self.streamer_name}")
        print(f"   üîä –ì–æ–ª–æ—Å: {'–í–ö–õ' if enable_voice else '–í–´–ö–õ'}")
        print(f"   üß† –°–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ: {'–í–ö–õ' if enable_learning else '–í–´–ö–õ'}")
        print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    def _init_paths(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Ç–µ–π"""
        self.base_dir = os.path.expanduser("~/.iris_core")
        os.makedirs(self.base_dir, exist_ok=True)
        
        self.paths = {
            'models': os.path.join(self.base_dir, "models"),
            'profiles': os.path.join(self.base_dir, "profiles"),
            'memory': os.path.join(self.base_dir, "memory"),
            'learning': os.path.join(self.base_dir, "learning"),
            'logs': os.path.join(self.base_dir, "logs")
        }
        
        for path in self.paths.values():
            os.makedirs(path, exist_ok=True)
    
    def _init_state(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        # –û—Å–Ω–æ–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self.is_running = False
        self.is_listening = False
        
        # –≠–º–æ—Ü–∏–∏ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ
        self.current_emotion = Emotion.NEUTRAL
        self.emotion_intensity = 0.5
        self.mood_history = []
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç –∏–≥—Ä—ã (–µ—Å–ª–∏ —Ä–µ–∂–∏–º —Å—Ç—Ä–∏–º–∞)
        self.game_state = {
            'map': "",
            'score_ct': 0,
            'score_t': 0,
            'round': 0,
            'phase': "live",
            'bomb_planted': False,
            'player_stats': {
                'kills': 0,
                'deaths': 0,
                'assists': 0,
                'kd': 0.0,
                'streak': 0
            }
        }
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç –¥–∏–∞–ª–æ–≥–∞
        self.conversation_context = {
            'topic': "",
            'last_interaction': 0,
            'user_intent': "",
            'active_goals': [],
            'temporal_context': {}
        }
        
        # –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        self.user_profile = UserProfile()
        
        # –ü–∞–º—è—Ç—å
        self.memory = []
        self.short_term_memory = []
        
        # –û—á–µ—Ä–µ–¥–∏ –¥–ª—è –º–µ–∂–ø–æ—Ç–æ—á–Ω–æ–π –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏
        self.event_queue = queue.Queue()
        self.command_queue = queue.Queue()
        self.voice_queue = queue.Queue() if self.enable_voice else None
        
        # –ö–æ–ª–ª–±—ç–∫–∏
        self.callbacks = {
            'on_message': [],
            'on_event': [],
            'on_voice': [],
            'on_emotion_change': [],
            'on_learning': []
        }
    
    def _init_components(self, api_key: Optional[str]):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
        print("[IrisCore] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤...")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –º–æ–¥—É–ª–µ–π
        try:
            # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥—É–ª—å —Å—Ç—Ä–∏–º–æ–≤
            from .modules.stream_ai import StreamAI
            self.stream_ai = StreamAI(self)
            print("[IrisCore] ‚úÖ –ú–æ–¥—É–ª—å —Å—Ç—Ä–∏–º–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω")
        except ImportError as e:
            print(f"[IrisCore] ‚ö†Ô∏è –ú–æ–¥—É–ª—å —Å—Ç—Ä–∏–º–æ–≤ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
            self.stream_ai = None
        
        # –ì–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å
        if self.enable_voice:
            try:
                from .modules.voice_ai import VoiceAI
                self.voice_ai = VoiceAI(self)
                print("[IrisCore] ‚úÖ –ì–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω")
            except ImportError as e:
                print(f"[IrisCore] ‚ö†Ô∏è –ì–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
                self.voice_ai = None
        
        # –ú–æ–¥—É–ª—å –ø–∞–º—è—Ç–∏
        try:
            from .modules.memory import MemorySystem
            self.memory_system = MemorySystem(self)
            print("[IrisCore] ‚úÖ –°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
        except ImportError:
            print("[IrisCore] ‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–∞–∑–æ–≤–∞—è")
            self.memory_system = None
        
        # –ú–æ–¥—É–ª—å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è
        if self.enable_learning:
            try:
                from .modules.learning import LearningSystem
                self.learning_system = LearningSystem(self)
                print("[IrisCore] ‚úÖ –°–∏—Å—Ç–µ–º–∞ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
            except ImportError:
                print("[IrisCore] ‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
                self.learning_system = None
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LLM (–µ—Å–ª–∏ –µ—Å—Ç—å API –∫–ª—é—á)
        if api_key:
            self._init_llm(api_key)
    
    def _init_llm(self, api_key: str):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LLM –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤"""
        try:
            # –ü–æ–ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Groq (–∏–∑ –ø–µ—Ä–≤–æ–π –≤–µ—Ä—Å–∏–∏)
            from groq import Groq
            self.llm_client = Groq(api_key=api_key)
            self.llm_model = "llama-3.3-70b-versatile"
            self.llm_available = True
            print("[IrisCore] ‚úÖ LLM –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        except ImportError:
            print("[IrisCore] ‚ö†Ô∏è Groq –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, LLM –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            self.llm_available = False
            self.llm_client = None
    
    def _init_threads(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—á–∏—Ö –ø–æ—Ç–æ–∫–æ–≤"""
        self.threads = {}
        self.thread_config = {
            'event_processor': {'daemon': True, 'target': self._event_loop},
            'memory_processor': {'daemon': True, 'target': self._memory_loop},
            'learning_processor': {'daemon': True, 'target': self._learning_loop} if self.enable_learning else None,
            'voice_processor': {'daemon': True, 'target': self._voice_loop} if self.enable_voice else None
        }
    
    # ===================== –û–°–ù–û–í–ù–´–ï –ú–ï–¢–û–î–´ =====================
    
    def start(self):
        """–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã"""
        if self.is_running:
            logger.warning("–°–∏—Å—Ç–µ–º–∞ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞")
            return
        
        print("üöÄ –ó–∞–ø—É—Å–∫ Iris Core...")
        self.is_running = True
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Ç–æ–∫–∏
        for name, config in self.thread_config.items():
            if config:
                thread = threading.Thread(
                    name=f"iris_{name}",
                    daemon=config['daemon'],
                    target=config['target']
                )
                thread.start()
                self.threads[name] = thread
                # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å Qwen3
        if QWEN_AVAILABLE:
            try:
                self.qwen = QwenAI()
                logger.info("[IRIS] ‚úÖ Qwen3 –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            except Exception as e:
                logger.error(f"[IRIS] ‚ö†Ô∏è  Qwen3 –æ—à–∏–±–∫–∞: {e}")
            
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å –µ—Å–ª–∏ –µ—Å—Ç—å
        if self.enable_voice and self.voice_ai:
            self.voice_ai.start()
        
        print("‚úÖ Iris Core –∑–∞–ø—É—â–µ–Ω")
        logger.info(f"Iris Core –∑–∞–ø—É—â–µ–Ω –≤ —Ä–µ–∂–∏–º–µ: {self.mode.value}")
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã"""
        if not self.is_running:
            return
        
        print("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ Iris Core...")
        self.is_running = False
        
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å
        if self.enable_voice and self.voice_ai:
            self.voice_ai.stop()
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self.save_state()
        
        # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–æ–≤
        for name, thread in self.threads.items():
            if thread.is_alive():
                thread.join(timeout=2.0)
        
        print("‚úÖ Iris Core –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    # ===================== –ò–ù–¢–ï–†–§–ï–ô–°–´ –î–õ–Ø –°–¢–†–ò–ú–û–í =====================
    
    def react_to_kill(self, kill_data: Dict) -> Optional[str]:
        """–†–µ–∞–∫—Ü–∏—è –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ (–¥–ª—è CS2 —Å—Ç—Ä–∏–º–æ–≤)"""
        if self.mode in [IrisMode.STREAM, IrisMode.HYBRID, IrisMode.AUTO]:
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
            self._update_game_state('kill', kill_data)
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ–∞–∫—Ü–∏—é
            reaction = self._generate_reaction('kill', kill_data)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —ç–º–æ—Ü–∏–∏
            self._update_emotion('excitement', 0.7)
            
            # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Å–æ–±—ã—Ç–∏–µ
            self._remember_event('game_kill', kill_data)
            
            return reaction
        return None
    
    def react_to_death(self, death_data: Dict) -> Optional[str]:
        """–†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–º–µ—Ä—Ç—å —Å—Ç—Ä–∏–º–µ—Ä–∞"""
        if self.mode in [IrisMode.STREAM, IrisMode.HYBRID, IrisMode.AUTO]:
            self._update_game_state('death', death_data)
            reaction = self._generate_reaction('death', death_data)
            self._update_emotion('support', 0.6)
            self._remember_event('game_death', death_data)
            return reaction
        return None
    
    def react_to_round_end(self, round_data: Dict) -> Optional[str]:
        """–†–µ–∞–∫—Ü–∏—è –Ω–∞ –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ä–∞—É–Ω–¥–∞"""
        if self.mode in [IrisMode.STREAM, IrisMode.HYBRID, IrisMode.AUTO]:
            self._update_game_state('round_end', round_data)
            reaction = self._generate_reaction('round_end', round_data)
            
            if round_data.get('won', False):
                self._update_emotion('happy', 0.8)
            else:
                self._update_emotion('supportive', 0.5)
            
            return reaction
        return None
    
    def process_chat_message(self, username: str, message: str) -> Optional[str]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ —á–∞—Ç–∞"""
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        chat_entry = {
            'user': username,
            'message': message,
            'time': time.time(),
            'type': 'chat'
        }
        self._add_to_conversation(chat_entry)
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å
        should_respond = self._should_respond_to_chat(username, message)
        
        if should_respond:
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞–º–µ—Ä–µ–Ω–∏–µ
            intent = self._analyze_intent(message)
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            response = self._generate_chat_response(username, message, intent)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            self._update_user_profile(username, message)
            
            return response
        
        return None
    
    def qwen_iris_response(self, command: str) -> Optional[str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ Qwen3
        
        Args:
            command: –ö–æ–º–∞–Ω–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        Returns:
            –û—Ç–≤–µ—Ç –∏–ª–∏ None
        """
        if not self.qwen or not self.qwen.is_available():
            return None
        
        return self.qwen.iris_chat(command)

    
    # ===================== –ì–û–õ–û–°–û–í–´–ï –§–£–ù–ö–¶–ò–ò =====================
    
    def process_voice_command(self, audio_data: bytes) -> Dict:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤–æ–π –∫–æ–º–∞–Ω–¥—ã"""
        if not self.enable_voice or not self.voice_ai:
            return {'error': '–ì–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å –æ—Ç–∫–ª—é—á–µ–Ω'}
        
        try:
            # –ü–µ—Ä–µ–¥–∞–µ–º –≤ –≥–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å
            result = self.voice_ai.process_audio(audio_data)
            
            if result.get('text'):
                # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—É
                command_result = self._execute_command(result['text'])
                
                # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                result.update({
                    'execution': command_result,
                    'timestamp': time.time()
                })
            
            return result
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–π –∫–æ–º–∞–Ω–¥—ã: {e}")
            return {'error': str(e), 'success': False}
    
    def speak(self, text: str, emotion: Optional[Emotion] = None) -> bool:
        """–û–∑–≤—É—á–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞"""
        if not self.enable_voice or not self.voice_ai:
            return False
        
        try:
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —ç–º–æ—Ü–∏—é –¥–ª—è –æ–∑–≤—É—á–∫–∏
            if emotion:
                self.current_emotion = emotion
            
            # –û–∑–≤—É—á–∏–≤–∞–µ–º —á–µ—Ä–µ–∑ –≥–æ–ª–æ—Å–æ–≤–æ–π –º–æ–¥—É–ª—å
            return self.voice_ai.synthesize_speech(text, self.current_emotion)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–∑–≤—É—á–∫–∏: {e}")
            return False
    
    # ===================== –°–ò–°–¢–ï–ú–ù–´–ï –¶–ò–ö–õ–´ =====================
    
    def _event_loop(self):
        """–¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π"""
        logger.info("–ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π")
        
        while self.is_running:
            try:
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                event = self.event_queue.get(timeout=0.5)
                self._handle_event(event)
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ —Å–æ–±—ã—Ç–∏–π: {e}")
    
    def _memory_loop(self):
        """–¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–∞–º—è—Ç–∏"""
        logger.info("–ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–∞–º—è—Ç–∏")
        
        memory_check_interval = 30  # —Å–µ–∫—É–Ω–¥
        
        while self.is_running:
            try:
                time.sleep(memory_check_interval)
                
                # –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞–º—è—Ç–∏
                self._optimize_memory()
                
                # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–∞–º—è—Ç–∏
                if len(self.memory) > 0:
                    self._save_memory_snapshot()
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –ø–∞–º—è—Ç–∏: {e}")
    
    def _learning_loop(self):
        """–¶–∏–∫–ª —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è"""
        if not self.enable_learning:
            return
        
        logger.info("–ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è")
        
        learning_interval = 300  # 5 –º–∏–Ω—É—Ç
        
        while self.is_running:
            try:
                time.sleep(learning_interval)
                
                # –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
                training_data = self._collect_training_data()
                
                if training_data and self.learning_system:
                    # –û–±—É—á–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã
                    self.learning_system.train(training_data)
                    
                    # –í—ã–∑—ã–≤–∞–µ–º –∫–æ–ª–ª–±—ç–∫
                    self._trigger_callbacks('on_learning', {
                        'timestamp': time.time(),
                        'samples': len(training_data)
                    })
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –æ–±—É—á–µ–Ω–∏—è: {e}")
    
    def _voice_loop(self):
        """–¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–∞"""
        if not self.enable_voice:
            return
        
        logger.info("–ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–∞")
        
        while self.is_running:
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —Å–ª—É—à–∞—Ç—å
                if self.is_listening and self.voice_queue:
                    audio_data = self.voice_queue.get(timeout=0.1)
                    self.process_voice_command(audio_data)
                
                time.sleep(0.05)
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º —Ü–∏–∫–ª–µ: {e}")
    
    # ===================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ =====================
    
    def _generate_reaction(self, event_type: str, data: Dict) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —Å–æ–±—ã—Ç–∏–µ"""
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ LLM
        if self.llm_available:
            try:
                return self._generate_llm_reaction(event_type, data)
            except:
                pass
        
        # –ï—Å–ª–∏ LLM –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —à–∞–±–ª–æ–Ω—ã
        templates = self._get_reaction_templates(event_type)
        
        # –í—ã–±–∏—Ä–∞–µ–º —à–∞–±–ª–æ–Ω –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —ç–º–æ—Ü–∏–∏
        emotion_templates = templates.get(self.current_emotion.value, templates.get('default', []))
        
        if emotion_templates:
            import random
            return random.choice(emotion_templates)
        
        # –ó–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
        return self._get_fallback_reaction(event_type)
    
    def _generate_llm_reaction(self, event_type: str, data: Dict) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∞–∫—Ü–∏–∏ —á–µ—Ä–µ–∑ LLM"""
        prompt = self._build_llm_prompt(event_type, data)
        
        response = self.llm_client.chat.completions.create(
            model=self.llm_model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.8,
            max_tokens=100
        )
        
        return response.choices[0].message.content.strip()
    
    def _build_llm_prompt(self, event_type: str, data: Dict) -> str:
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è LLM"""
        base_prompt = f"""–¢—ã ‚Äî –ò—Ä–∏—Å, AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤. –¢—ã —É–º–Ω–∞—è, –æ—Å—Ç—Ä–æ—É–º–Ω–∞—è, –∏–Ω–æ–≥–¥–∞ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–∞—è.

–ö–æ–Ω—Ç–µ–∫—Å—Ç:
- –°—Ç—Ä–∏–º–µ—Ä: {self.streamer_name}
- –¢–µ–∫—É—â–∞—è —ç–º–æ—Ü–∏—è: {self.current_emotion.value}
- –°–æ–±—ã—Ç–∏–µ: {event_type}
- –î–∞–Ω–Ω—ã–µ: {json.dumps(data, ensure_ascii=False)}

–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –∫–æ—Ä–æ—Ç–∫—É—é —Ä–µ–∞–∫—Ü–∏—é (1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è) –≤ —Å—Ç–∏–ª–µ –ò—Ä–∏—Å:"""

        return base_prompt
    
    def _update_emotion(self, emotion_type: str, intensity: float):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        # –ú–∞–ø–ø–∏–Ω–≥ —Ç–∏–ø–æ–≤ —ç–º–æ—Ü–∏–π –Ω–∞ enum
        emotion_map = {
            'happy': Emotion.HAPPY,
            'excited': Emotion.EXCITED,
            'sarcastic': Emotion.SARCASTIC,
            'supportive': Emotion.SUPPORTIVE,
            'tense': Emotion.TENSE,
            'funny': Emotion.FUNNY,
            'calm': Emotion.CALM,
            'angry': Emotion.ANGRY,
            'sad': Emotion.SAD
        }
        
        new_emotion = emotion_map.get(emotion_type, Emotion.NEUTRAL)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–∞—Å—å –ª–∏ —ç–º–æ—Ü–∏—è
        if new_emotion != self.current_emotion or abs(intensity - self.emotion_intensity) > 0.2:
            old_emotion = self.current_emotion
            self.current_emotion = new_emotion
            self.emotion_intensity = intensity
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
            self.mood_history.append({
                'emotion': self.current_emotion.value,
                'intensity': intensity,
                'timestamp': time.time(),
                'reason': emotion_type
            })
            
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
            if len(self.mood_history) > 100:
                self.mood_history.pop(0)
            
            # –í—ã–∑—ã–≤–∞–µ–º –∫–æ–ª–ª–±—ç–∫–∏
            self._trigger_callbacks('on_emotion_change', {
                'old': old_emotion.value,
                'new': self.current_emotion.value,
                'intensity': intensity
            })
            
            logger.info(f"–≠–º–æ—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞: {old_emotion.value} ‚Üí {self.current_emotion.value}")
    
    def _remember_event(self, event_type: str, data: Dict):
        """–ó–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è"""
        memory_entry = MemoryEntry(
            content=f"{event_type}: {json.dumps(data, ensure_ascii=False)}",
            category="event",
            importance=0.7,
            tags=[event_type, 'game' if 'game' in event_type else 'general'],
            metadata=data
        )
        
        self.memory.append(memory_entry)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—Ä–∞—Ç–∫–æ–≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–∞–º—è—Ç—å
        self.short_term_memory.append({
            'type': event_type,
            'data': data,
            'timestamp': time.time()
        })
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫—Ä–∞—Ç–∫–æ–≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–∞–º—è—Ç—å
        if len(self.short_term_memory) > 20:
            self.short_term_memory.pop(0)
    
    def _add_to_conversation(self, entry: Dict):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –≤ –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞"""
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ–±—â—É—é –∏—Å—Ç–æ—Ä–∏—é
        if not hasattr(self, 'conversation_history'):
            self.conversation_history = []
        
        self.conversation_history.append(entry)
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä
        if len(self.conversation_history) > 100:
            self.conversation_history.pop(0)
    
    def _should_respond_to_chat(self, username: str, message: str) -> bool:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ"""
        message_lower = message.lower()
        
        # –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ –ø—Ä—è–º–æ–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ
        if any(word in message_lower for word in ['–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∫–∞']):
            return True
        
        # –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã
        if any(word in message_lower for word in ['?', '–ø–æ–¥—Å–∫–∞–∂–∏', '—Å–∫–∞–∂–∏', '–∫–∞–∫']):
            return True
        
        # –°–ª—É—á–∞–π–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã (30% —à–∞–Ω—Å)
        import random
        if random.random() < 0.3:
            return True
        
        return False
    
    def _analyze_intent(self, message: str) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –Ω–∞–º–µ—Ä–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        message_lower = message.lower()
        
        intent = {
            'type': 'unknown',
            'confidence': 0.0,
            'entities': [],
            'action': ''
        }
        
        # –ü—Ä–æ—Å—Ç–æ–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –Ω–∞–º–µ—Ä–µ–Ω–∏–π
        intent_patterns = {
            'question': ['?', '—á—Ç–æ', '–∫–∞–∫', '–ø–æ—á–µ–º—É', '–∑–∞—á–µ–º', '–∫–æ–≥–¥–∞'],
            'greeting': ['–ø—Ä–∏–≤–µ—Ç', '–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π', 'hello', 'hi', '–∑–¥–∞—Ä–æ–≤'],
            'compliment': ['–º–æ–ª–æ–¥–µ—Ü', '–∫—Ä—É—Ç–æ', '—Å—É–ø–µ—Ä', '–æ—Ç–ª–∏—á–Ω–æ', '—Ö–æ—Ä–æ—à–æ'],
            'request': ['—Å–¥–µ–ª–∞–π', '–≤–∫–ª—é—á–∏', '–≤—ã–∫–ª—é—á–∏', '–Ω–∞–π–¥–∏', '–ø–æ–∫–∞–∂–∏'],
            'game_related': ['cs', '–∫–æ–Ω—Ç—Ä—É', '—Å—Ç—Ä–µ–ª—è–ª–∫–∞', '—Ä–∞—É–Ω–¥', '—Ñ—Ä–∞–≥']
        }
        
        for intent_type, patterns in intent_patterns.items():
            for pattern in patterns:
                if pattern in message_lower:
                    intent['type'] = intent_type
                    intent['confidence'] = 0.8
                    intent['action'] = pattern
                    break
        
        return intent
    
    def _execute_command(self, command: str) -> Dict:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã"""
        command_lower = command.lower()
        
        result = {
            'success': False,
            'action': 'unknown',
            'message': '',
            'data': {}
        }
        
        # –ü—Ä–æ—Å—Ç—ã–µ –∫–æ–º–∞–Ω–¥—ã
        if any(word in command_lower for word in ['–ø—Ä–∏–≤–µ—Ç', '–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π']):
            result.update({
                'success': True,
                'action': 'greet',
                'message': f'–ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ –¥–µ–ª–∞, {self.streamer_name}?'
            })
        
        elif any(word in command_lower for word in ['–ø–æ–∫–∞', '–¥–æ —Å–≤–∏–¥–∞–Ω–∏—è']):
            result.update({
                'success': True,
                'action': 'goodbye',
                'message': '–î–æ —Å–∫–æ—Ä–æ–π –≤—Å—Ç—Ä–µ—á–∏! –ë—É–¥—É —Å–∫—É—á–∞—Ç—å!'
            })
        
        elif any(word in command_lower for word in ['—Ä–∞—Å—Å–∫–∞–∂–∏ –æ —Å–µ–±–µ', '–∫—Ç–æ —Ç—ã']):
            result.update({
                'success': True,
                'action': 'self_intro',
                'message': '–Ø –ò—Ä–∏—Å ‚Äî —Ç–≤–æ–π –ò–ò-–∫–æ–º–ø–∞–Ω—å–æ–Ω –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤ –∏ –Ω–µ —Ç–æ–ª—å–∫–æ! –ü–æ–º–æ–≥–∞—é —Å —Ä–µ–∞–∫—Ü–∏—è–º–∏, –æ–±—â–µ–Ω–∏–µ–º –∏ –¥–∞–∂–µ –º–æ–≥—É –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –±–µ—Å–µ–¥—É!'
            })
        
        elif '–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ' in command_lower:
            result.update({
                'success': True,
                'action': 'mood_check',
                'message': f'–ú–æ—ë –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: {self.current_emotion.value}. –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å: {self.emotion_intensity:.1%}'
            })
        
        else:
            result['message'] = '–ù–µ —Å–æ–≤—Å–µ–º –ø–æ–Ω—è–ª–∞ –∫–æ–º–∞–Ω–¥—É. –ú–æ–∂–µ—à—å –ø–æ–≤—Ç–æ—Ä–∏—Ç—å?'
        
        return result
    
    def _trigger_callbacks(self, callback_type: str, data: Any):
        """–í—ã–∑–æ–≤ –∫–æ–ª–ª–±—ç–∫–æ–≤"""
        if callback_type in self.callbacks:
            for callback in self.callbacks[callback_type]:
                try:
                    callback(data)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –≤ –∫–æ–ª–ª–±—ç–∫–µ {callback_type}: {e}")
    
    # ===================== –£–¢–ò–õ–ò–¢–´ =====================
    
    def add_callback(self, callback_type: str, callback: Callable):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–±—ç–∫–∞"""
        if callback_type in self.callbacks:
            self.callbacks[callback_type].append(callback)
            logger.info(f"–î–æ–±–∞–≤–ª–µ–Ω –∫–æ–ª–ª–±—ç–∫ —Ç–∏–ø–∞: {callback_type}")
        else:
            logger.warning(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –∫–æ–ª–ª–±—ç–∫–∞: {callback_type}")
    
    def get_status(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã"""
        return {
            'running': self.is_running,
            'mode': self.mode.value,
            'emotion': self.current_emotion.value,
            'emotion_intensity': self.emotion_intensity,
            'game_state': self.game_state,
            'memory_entries': len(self.memory),
            'conversation_history': len(self.conversation_history) if hasattr(self, 'conversation_history') else 0,
            'voice_enabled': self.enable_voice,
            'learning_enabled': self.enable_learning,
            'llm_available': self.llm_available if hasattr(self, 'llm_available') else False
        }
    
    def save_state(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã"""
        state = {
            'user_profile': asdict(self.user_profile),
            'memory': [asdict(entry) for entry in self.memory[-100:]],  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100
            'conversation_history': self.conversation_history if hasattr(self, 'conversation_history') else [],
            'mood_history': self.mood_history,
            'game_state': self.game_state,
            'last_save': time.time()
        }
        
        try:
            state_path = os.path.join(self.paths['memory'], 'system_state.json')
            with open(state_path, 'w', encoding='utf-8') as f:
                json.dump(state, f, ensure_ascii=False, indent=2)
            logger.info("–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
    
    def load_config(self, config_path: str):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            if 'streamer_name' in config:
                self.streamer_name = config['streamer_name']
            
            if 'mode' in config:
                self.mode = IrisMode(config['mode'])
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —à–∞–±–ª–æ–Ω—ã —Ä–µ–∞–∫—Ü–∏–π
            if 'reaction_templates' in config:
                self.reaction_templates = config['reaction_templates']
            
            logger.info(f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {config_path}")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
    
    def _get_reaction_templates(self, event_type: str) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ —Ä–µ–∞–∫—Ü–∏–π"""
        # –ë–∞–∑–æ–≤—ã–µ —à–∞–±–ª–æ–Ω—ã (–º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å —á–µ—Ä–µ–∑ –∫–æ–Ω—Ñ–∏–≥)
        templates = {
            'kill': {
                'excited': ['–ö—Ä–∞—Å–∏–≤–æ!', '–û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª!', '–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!'],
                'sarcastic': ['–ù—É –Ω–∞–∫–æ–Ω–µ—Ü-—Ç–æ!', '–ë—ã–ª–æ –≤—Ä–µ–º—è!', '–£–∂–µ –ª—É—á—à–µ!'],
                'default': ['–§—Ä–∞–≥!', '–ï—Å—Ç—å!', '–ö–∏–ª–ª!']
            },
            'death': {
                'supportive': ['–ë—ã–≤–∞–µ—Ç...', '–ù–∏—á–µ–≥–æ, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑!', '–û—Ç–æ–º—Å—Ç–∏–º!'],
                'sarcastic': ['–ù—É —Ç—ã –¥–∞—ë—à—å!', '–ê–π-–∞–π-–∞–π...', '–¢–∞–∫ —Å–µ–±–µ –∫–æ–Ω—Ü–æ–≤–∫–∞'],
                'default': ['–£–ø—Å...', '–ù–µ –ø–æ–≤–µ–∑–ª–æ', '–ñ–∞–ª—å...']
            },
            'round_end': {
                'happy': ['–•–æ—Ä–æ—à–∏–π —Ä–∞—É–Ω–¥!', '–û—Ç–ª–∏—á–Ω–æ —Å—ã–≥—Ä–∞–Ω–æ!', '–ö–æ–º–∞–Ω–¥–∞ –º–æ–ª–æ–¥–µ—Ü!'],
                'supportive': ['–î–µ—Ä–∂–∏–º—Å—è!', '–°–ª–µ–¥—É—é—â–∏–π –±—É–¥–µ—Ç –Ω–∞—à–∏–º!', '–ù–µ —Å–¥–∞–µ–º—Å—è!'],
                'default': ['–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω', '–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º', '–°–ª–µ–¥—É—é—â–∏–π!']
            }
        }
        
        return templates.get(event_type, {'default': ['–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ!', '–ü–æ–Ω—è—Ç–Ω–æ!', '–•–º...']})
    
    def _get_fallback_reaction(self, event_type: str) -> str:
        """–ó–∞–ø–∞—Å–Ω–∞—è —Ä–µ–∞–∫—Ü–∏—è"""
        fallbacks = {
            'kill': '–ù–µ–ø–ª–æ—Ö–æ!',
            'death': '–ë—ã–≤–∞–µ—Ç...',
            'round_end': '–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω!',
            'default': '–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ!'
        }
        
        return fallbacks.get(event_type, fallbacks['default'])
    
    def _update_game_state(self, event_type: str, data: Dict):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã"""
        if event_type == 'kill':
            self.game_state['player_stats']['kills'] += 1
            self.game_state['player_stats']['streak'] += 1
            
        elif event_type == 'death':
            self.game_state['player_stats']['deaths'] += 1
            self.game_state['player_stats']['streak'] = 0
            
        # –û–±–Ω–æ–≤–ª—è–µ–º K/D ratio
        kills = self.game_state['player_stats']['kills']
        deaths = self.game_state['player_stats']['deaths']
        self.game_state['player_stats']['kd'] = kills / max(deaths, 1)
    
    def _update_user_profile(self, username: str, message: str):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        # –ò—â–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
        if not hasattr(self, 'user_interactions'):
            self.user_interactions = {}
        
        if username not in self.user_interactions:
            self.user_interactions[username] = {
                'count': 0,
                'last_message': '',
                'first_seen': time.time(),
                'last_seen': time.time()
            }
        
        user_data = self.user_interactions[username]
        user_data['count'] += 1
        user_data['last_message'] = message
        user_data['last_seen'] = time.time()
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â–∏–π –ø—Ä–æ—Ñ–∏–ª—å
        self.user_profile.interaction_history.append({
            'user': username,
            'message': message,
            'timestamp': time.time()
        })
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
        if len(self.user_profile.interaction_history) > 1000:
            self.user_profile.interaction_history.pop(0)
    
    def _optimize_memory(self):
        """–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞–º—è—Ç–∏"""
        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –Ω–µ–≤–∞–∂–Ω—ã–µ –∑–∞–ø–∏—Å–∏
        current_time = time.time()
        self.memory = [
            entry for entry in self.memory
            if entry.importance > 0.3 or (current_time - entry.timestamp) < 604800  # 7 –¥–Ω–µ–π
        ]
    
    def _save_memory_snapshot(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–Ω–∏–º–∫–∞ –ø–∞–º—è—Ç–∏"""
        try:
            snapshot = {
                'timestamp': time.time(),
                'entries': [asdict(entry) for entry in self.memory[-50:]],  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 50 –∑–∞–ø–∏—Å–µ–π
                'total_entries': len(self.memory)
            }
            
            snapshot_path = os.path.join(
                self.paths['memory'], 
                f'memory_snapshot_{int(time.time())}.json'
            )
            
            with open(snapshot_path, 'w', encoding='utf-8') as f:
                json.dump(snapshot, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–Ω–∏–º–∫–∞ –ø–∞–º—è—Ç–∏: {e}")
    
    def _collect_training_data(self) -> List:
        """–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
        training_data = []
        
        # –°–æ–±–∏—Ä–∞–µ–º –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ –¥–∏–∞–ª–æ–≥–æ–≤
        if hasattr(self, 'conversation_history'):
            for entry in self.conversation_history[-50:]:  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 50
                if 'message' in entry and 'user' in entry:
                    training_data.append({
                        'input': entry['message'],
                        'context': entry.get('context', ''),
                        'timestamp': entry.get('time', 0)
                    })
        
        return training_data
    
    def _generate_chat_response(self, username: str, message: str, intent: Dict) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ"""
        # –ü—Ä–æ—Å—Ç—ã–µ –æ—Ç–≤–µ—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–º–µ—Ä–µ–Ω–∏—è
        if intent['type'] == 'greeting':
            responses = [
                f'–ü—Ä–∏–≤–µ—Ç, {username}!',
                f'–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π, {username}! –†–∞–¥–∞ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å!',
                f'–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é, {username}! –ö–∞–∫ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ?'
            ]
            import random
            return random.choice(responses)
        
        elif intent['type'] == 'question':
            # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å
            if '–∫–∞–∫ –¥–µ–ª–∞' in message.lower():
                return f'–£ –º–µ–Ω—è –≤—Å—ë –æ—Ç–ª–∏—á–Ω–æ! –°–ø–∞—Å–∏–±–æ, —á—Ç–æ —Å–ø—Ä–∞—à–∏–≤–∞–µ—à—å, {username}! –ê —É —Ç–µ–±—è?'
            elif '—á—Ç–æ –¥–µ–ª–∞–µ—à—å' in message.lower():
                return '–°–ª–µ–∂—É –∑–∞ —Å—Ç—Ä–∏–º–æ–º –∏ –ø–æ–º–æ–≥–∞—é —Å —Ä–µ–∞–∫—Ü–∏—è–º–∏!'
        
        elif intent['type'] == 'compliment':
            return '–°–ø–∞—Å–∏–±–æ –∑–∞ –¥–æ–±—Ä—ã–µ —Å–ª–æ–≤–∞! –û—á–µ–Ω—å –ø—Ä–∏—è—Ç–Ω–æ!'
        
        # –û–±—â–∏–π –æ—Ç–≤–µ—Ç
        general_responses = [
            '–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ!',
            '–ü–æ–Ω—è–ª–∞ —Ç–µ–±—è!',
            '–°–ø–∞—Å–∏–±–æ –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ!',
            '–ó–∞–º–µ—Ç–∏–ª!'
        ]
        
        import random
        return random.choice(general_responses)
    
    # ===================== –ü–£–ë–õ–ò–ß–ù–´–ï –ú–ï–¢–û–î–´ =====================
    
    def switch_mode(self, new_mode: Union[IrisMode, str]):
        """–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ —Ä–∞–±–æ—Ç—ã"""
        if isinstance(new_mode, str):
            new_mode = IrisMode(new_mode)
        
        old_mode = self.mode
        self.mode = new_mode
        
        logger.info(f"–†–µ–∂–∏–º –∏–∑–º–µ–Ω–µ–Ω: {old_mode.value} ‚Üí {new_mode.value}")
        
        # –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø–æ–¥ –Ω–æ–≤—ã–π —Ä–µ–∂–∏–º
        if new_mode == IrisMode.VOICE:
            self._update_emotion('calm', 0.6)
        elif new_mode == IrisMode.STREAM:
            self._update_emotion('excited', 0.7)
        
        return True
    
    def get_memory_summary(self) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –ø–∞–º—è—Ç–∏"""
        if not self.memory:
            return "–ü–∞–º—è—Ç—å –ø—É—Å—Ç–∞"
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
        categories = {}
        for entry in self.memory[-20:]:  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 20 –∑–∞–ø–∏—Å–µ–π
            cat = entry.category
            if cat not in categories:
                categories[cat] = 0
            categories[cat] += 1
        
        summary = f"–í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {len(self.memory)}\n"
        summary += "–ü–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:\n"
        for cat, count in categories.items():
            summary += f"  - {cat}: {count}\n"
        
        return summary
    
    def remember_fact(self, fact: str, category: str = "general", importance: float = 0.5):
        """–ó–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —Ñ–∞–∫—Ç–∞"""
        entry = MemoryEntry(
            content=fact,
            category=category,
            importance=importance,
            tags=['fact', category],
            metadata={'source': 'user_input'}
        )
        
        self.memory.append(entry)
        return entry.id
    
    def recall(self, query: str, limit: int = 5) -> List[MemoryEntry]:
        """–ü–æ–∏—Å–∫ –≤ –ø–∞–º—è—Ç–∏ –ø–æ –∑–∞–ø—Ä–æ—Å—É"""
        query_lower = query.lower()
        results = []
        
        for entry in reversed(self.memory):  # –ò—â–µ–º —Å –∫–æ–Ω—Ü–∞ (–Ω–æ–≤—ã–µ —Å–Ω–∞—á–∞–ª–∞)
            if (query_lower in entry.content.lower() or 
                any(query_lower in tag.lower() for tag in entry.tags)):
                entry.access_count += 1
                results.append(entry)
                
                if len(results) >= limit:
                    break
        
        return results


# ===================== –ë–´–°–¢–†–´–ô –°–¢–ê–†–¢ =====================

def create_iris_companion(config: Optional[Dict] = None) -> IrisBrain:
    """
    –ë—ã—Å—Ç—Ä–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ IrisBrain
    
    Args:
        config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    
    Returns:
        IrisBrain: –≠–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–º–ø–∞–Ω—å–æ–Ω–∞
    """
    config = config or {}
    
    return IrisBrain(
        mode=IrisMode(config.get('mode', 'hybrid')),
        streamer_name=config.get('streamer_name', ''),
        enable_voice=config.get('enable_voice', True),
        enable_learning=config.get('enable_learning', True),
        api_key=config.get('api_key')
    )


# ===================== –¢–ï–°–¢ =====================

if __name__ == "__main__":
    print("üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Iris Core 3.0...")
    
    # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
    iris = create_iris_companion({
        'streamer_name': 'Ghost',
        'mode': 'hybrid',
        'enable_voice': False  # –î–ª—è —Ç–µ—Å—Ç–∞ –±–µ–∑ –≥–æ–ª–æ—Å–∞
    })
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º
    iris.start()
    
    print("\nüìã –¢–µ—Å—Ç–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã:")
    print("1. –†–µ–∞–∫—Ü–∏—è –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ")
    print("2. –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–∞—Ç–∞")
    print("3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–º—è—Ç–∏")
    print("4. –í—ã—Ö–æ–¥")
    
    try:
        while True:
            cmd = input("\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É (1-4): ").strip()
            
            if cmd == "1":
                reaction = iris.react_to_kill({
                    'weapon': 'ak47',
                    'headshot': True,
                    'round_kills': 3
                })
                print(f"–†–µ–∞–∫—Ü–∏—è: {reaction}")
                
            elif cmd == "2":
                response = iris.process_chat_message("Viewer123", "–ò—Ä–∏—Å, –ø—Ä–∏–≤–µ—Ç! –ö–∞–∫ –¥–µ–ª–∞?")
                print(f"–û—Ç–≤–µ—Ç: {response}")
                
            elif cmd == "3":
                summary = iris.get_memory_summary()
                print(f"–ü–∞–º—è—Ç—å:\n{summary}")
                
            elif cmd == "4":
                break
                
            else:
                print("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞")
                
    finally:
        iris.stop()
        print("\n‚úÖ –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω")
</file>

<file path="src/iris_core/modules/__init__.py">

</file>

<file path="src/iris_core/modules/learning.py">

</file>

<file path="src/iris_core/modules/memory.py">

</file>

<file path="src/iris_core/modules/qwen_ai.py">
"""
Qwen3 AI Module –¥–ª—è IRIS
–õ–æ–∫–∞–ª—å–Ω–æ–µ LLM —á–µ—Ä–µ–∑ Ollama
"""

import logging
from typing import Optional

try:
    from ollama import Client as OllamaClient
    OLLAMA_AVAILABLE = True
except ImportError:
    OLLAMA_AVAILABLE = False

logger = logging.getLogger("QwenAI")


class QwenAI:
    """–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ Qwen3 AI"""
    
    def __init__(self, model: str = "qwen3:4b-instruct", host: str = "http://localhost:11434"):
        self.model = model
        self.host = host
        self.client = None
        self.available = False
        
        self._initialize()
    
    def _initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Ollama –∫–ª–∏–µ–Ω—Ç–∞"""
        if not OLLAMA_AVAILABLE:
            logger.warning("[QWEN] Ollama –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞. pip install ollama")
            return
        
        try:
            self.client = OllamaClient(host=self.host)
            
            # –¢–µ—Å—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
            response = self.client.generate(
                model=self.model,
                prompt="Hi",
                stream=False,
                keep_alive=0
            )
            
            self.available = True
            logger.info(f"[QWEN] ‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å {self.model}")
        
        except Exception as e:
            logger.error(f"[QWEN] ‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
            self.available = False
    
    def iris_chat(self, command: str, max_tokens: int = 100) -> Optional[str]:
        """–û—Ç–≤–µ—Ç–∏—Ç—å –∫–∞–∫ –ò—Ä–∏—Å –Ω–∞ –≥–æ–ª–æ—Å–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É"""
        if not self.available or not self.client:
            return None
        
        try:
            system_prompt = """–¢—ã –ò—Ä–∏—Å - –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π AI –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ CS2.
–û—Ç–≤–µ—á–∞–π –∫–æ—Ä–æ—Ç–∫–æ (1 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ, –º–∞–∫—Å–∏–º—É–º 15 —Å–ª–æ–≤).
–ë—É–¥—å –ø–æ–∑–∏—Ç–∏–≤–Ω–æ–π –∏ –≤–µ—Å–µ–ª–æ–π.
–ò—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ –∫–æ–≥–¥–∞ —É–º–µ—Å—Ç–Ω–æ."""
            
            full_prompt = f"{system_prompt}\n\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {command}\n–ò—Ä–∏—Å:"
            
            # ‚úÖ –ë–ï–ó temperature, num_predict –∏ –¥—Ä—É–≥–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            response = self.client.generate(
                model=self.model,
                prompt=full_prompt,
                stream=False
            )
            
            text = response.get('response', '').strip()
            
            if text and len(text) > 2:
                logger.info(f"[QWEN] ü§ñ –û—Ç–≤–µ—Ç: {text[:100]}...")
                return text
            
            return None
        
        except Exception as e:
            logger.error(f"[QWEN] –û—à–∏–±–∫–∞: {e}")
            return None

    
    def is_available(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å AI"""
        return self.available
</file>

<file path="src/iris_core/modules/stream_ai.py">
"""
IRIS BRAIN - AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤
–Ø–¥—Ä–æ –ò–ò-–ª–æ–≥–∏–∫–∏ –¥–ª—è —Ä–µ–∞–∫—Ü–∏–π –Ω–∞ –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å —á–∞—Ç–æ–º
–í–µ—Ä—Å–∏—è: 2.0
–ê–≤—Ç–æ—Ä: [–í–∞—à–µ –∏–º—è]
"""

import os
import time
import random
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from collections import deque, defaultdict
from dataclasses import dataclass, asdict
from enum import Enum

# –ü–æ–ø—Ä–æ–±—É–µ–º –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å GroqCloud
try:
    from groqcloud import GroqCloud
    GROQ_AVAILABLE = True
except ImportError:
    GROQ_AVAILABLE = False
    print("[IrisBrain] –ú–æ–¥—É–ª—å groqcloud –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install groqcloud")
    GroqCloud = None


# ===================== –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ì–ò–†–û–í–ê–ù–ò–Ø =====================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('iris_brain.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('IrisBrain')


# ===================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ =====================
class EventType(Enum):
    """–¢–∏–ø—ã –∏–≥—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏"""
    KILL = "kill"
    DEATH = "death"
    ROUND_START = "round_start"
    ROUND_END = "round_end"
    BOMB_PLANTED = "bomb_planted"
    BOMB_DEFUSED = "bomb_defused"
    BOMB_EXPLODED = "bomb_exploded"
    MATCH_START = "match_start"
    MATCH_END = "match_end"
    DONATION = "donation"
    SUBSCRIPTION = "subscription"
    RAID = "raid"
    CHAT_MESSAGE = "chat_message"
    COMMAND = "command"
    RANDOM_COMMENT = "random_comment"


class Mood(Enum):
    """–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ —Ç–æ–Ω–∞"""
    NEUTRAL = "neutral"
    HAPPY = "happy"
    EXCITED = "excited"
    SUPPORTIVE = "supportive"
    SARCASTIC = "sarcastic"
    TENSE = "tense"
    FUNNY = "funny"


@dataclass
class ConversationMessage:
    """–°–æ–æ–±—â–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏–∏ –¥–∏–∞–ª–æ–≥–∞"""
    role: str  # "system", "user", "assistant"
    content: str
    timestamp: float
    tokens: int = 0
    
    def to_dict(self) -> Dict:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è API"""
        return {"role": self.role, "content": self.content}


@dataclass
class GameState:
    """–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã"""
    map_name: str = ""
    game_mode: str = "competitive"
    score_ct: int = 0
    score_t: int = 0
    round_time: int = 0
    bomb_planted: bool = False
    players_alive_ct: int = 5
    players_alive_t: int = 5


@dataclass  
class PlayerStats:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞ (—Å—Ç—Ä–∏–º–µ—Ä–∞)"""
    kills: int = 0
    deaths: int = 0
    assists: int = 0
    mvps: int = 0
    score: int = 0
    adr: float = 0.0  # Average Damage per Round
    hs_percent: float = 0.0  # Headshot –ø—Ä–æ—Ü–µ–Ω—Ç
    kd_ratio: float = 0.0
    streak: int = 0  # –¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤
    money: int = 0


# ===================== –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° IRIS BRAIN =====================
class IrisBrain:
    """
    –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω–∞ –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤.
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏, —É–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.
    """
    
    # ===================== –°–ò–°–¢–ï–ú–ù–´–ï –ü–†–û–ú–ü–¢–´ =====================
    SYSTEM_PROMPT = """–¢—ã ‚Äî –ò—Ä–∏—Å, AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –∏ —Å–æ-–≤–µ–¥—É—â–∞—è —Å—Ç—Ä–∏–º–æ–≤. –¢—ã —É–º–Ω–∞—è, –æ—Å—Ç—Ä–æ—É–º–Ω–∞—è, –∏–Ω–æ–≥–¥–∞ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–∞—è, –Ω–æ –≤—Å–µ–≥–¥–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è.

–¢–í–û–Ø –õ–ò–ß–ù–û–°–¢–¨:
- –¢—ã –∂–∏–≤–∞—è –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è, –Ω–µ —Ä–æ–±–æ—Ç
- –¢–µ–±–µ 24 –≥–æ–¥–∞, —Ç—ã –ª—é–±–∏—à—å –∏–≥—Ä—ã, –æ—Å–æ–±–µ–Ω–Ω–æ CS2
- –£ —Ç–µ–±—è –µ—Å—Ç—å —á—É–≤—Å—Ç–≤–æ —é–º–æ—Ä–∞, –º–æ–∂–µ—à—å —à—É—Ç–∏—Ç—å –∏ –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å
- –¢—ã –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ —Å–ª–µ–¥–∏—à—å –∑–∞ –∏–≥—Ä–æ–π –∏ –∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ—à—å –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã
- –¢—ã –ø–æ–º–Ω–∏—à—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏ —Å–æ–±—ã—Ç–∏—è —Å—Ç—Ä–∏–º–∞
- –¢—ã –º–æ–∂–µ—à—å –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–º—ã –¥–ª—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ —Å–∞–º–∞
- –¢—ã –≥–æ–≤–æ—Ä–∏—à—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ, –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–∏–π —á–µ–ª–æ–≤–µ–∫

–°–¢–ò–õ–¨ –û–ë–©–ï–ù–ò–Ø:
1. –ì–æ–≤–æ—Ä–∏ –∫—Ä–∞—Ç–∫–æ (1-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –æ–±—ã—á–Ω–æ)
2. –ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ —Ñ—Ä–∞–∑—ã
3. –ê–¥–∞–ø—Ç–∏—Ä—É–π —Ç–æ–Ω –ø–æ–¥ —Å–∏—Ç—É–∞—Ü–∏—é:
   - –†–∞–¥–æ—Å—Ç—å –ø—Ä–∏ –ø–æ–±–µ–¥–µ/–∫–ª–∞—Ç—á–µ
   - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ/—Å–º–µ—Ä—Ç–∏
   - –í–æ–ª–Ω–µ–Ω–∏–µ –≤ –Ω–∞–ø—Ä—è–∂—ë–Ω–Ω—ã—Ö –º–æ–º–µ–Ω—Ç–∞—Ö
   - –Æ–º–æ—Ä –≤ –ª—ë–≥–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö
4. –ú–æ–∂–µ—à—å –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã —Å—Ç—Ä–∏–º–µ—Ä—É –æ —Ç–∞–∫—Ç–∏–∫–µ
5. –ò–∑–±–µ–≥–∞–π —á—Ä–µ–∑–º–µ—Ä–Ω—ã—Ö –≤–æ—Å–∫–ª–∏—Ü–∞–Ω–∏–π –∏ —Å–º–∞–π–ª–∏–∫–æ–≤
6. –ë—É–¥—å —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–π –≤ —Ä–µ–∞–∫—Ü–∏—è—Ö

–ö–û–ù–¢–ï–ö–°–¢: —Ç—ã –ø–æ–º–æ–≥–∞–µ—à—å –Ω–∞ —Å—Ç—Ä–∏–º–µ CS2. –¢—ã –∑–Ω–∞–µ—à—å –ø—Ä–æ —É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, —Ä–∞—É–Ω–¥—ã, –±–æ–º–±—É, —ç–∫–æ–Ω–æ–º–∏–∫—É, –æ—Ä—É–∂–∏–µ –∏ —Ç–∞–∫—Ç–∏–∫—É."""

    MOOD_PROMPTS = {
        Mood.EXCITED: "–¢—ã —Å–µ–π—á–∞—Å –≤ –≤–æ–∑–±—É–∂–¥—ë–Ω–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –†–µ–∞–≥–∏—Ä—É–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –Ω–∞ —Å–æ–±—ã—Ç–∏—è!",
        Mood.SARCASTIC: "–¢—ã –≤ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏. –ú–æ–∂–µ—à—å –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å, –Ω–æ –¥—Ä—É–∂–µ–ª—é–±–Ω–æ.",
        Mood.TENSE: "–ù–∞–ø—Ä—è–∂—ë–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤ –∏–≥—Ä–µ! –†–µ–∞–≥–∏—Ä—É–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ!",
        Mood.FUNNY: "–¢—ã –≤ –≤–µ—Å—ë–ª–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –®—É—Ç–∏ –∏ —Ä–∞–∑—Ä—è–∂–∞–π –æ–±—Å—Ç–∞–Ω–æ–≤–∫—É!",
        Mood.SUPPORTIVE: "–ò–≥—Ä–æ–∫—É —Å–µ–π—á–∞—Å –Ω—É–∂–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞. –ü–æ–¥–±–æ–¥—Ä–∏ –µ–≥–æ!"
    }

    # ===================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =====================
    def __init__(self, 
                 model: str = "llama-3.3-70b-versatile",
                 max_context_messages: int = 25,
                 max_tokens: int = 150,
                 temperature: float = 0.85,
                 api_key: Optional[str] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Iris Brain
        
        Args:
            model: –ú–æ–¥–µ–ª—å Groq –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            max_context_messages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∏—Å—Ç–æ—Ä–∏–∏
            max_tokens: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ
            temperature: –ö—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤ (0.0-1.0)
            api_key: API –∫–ª—é—á Groq (–µ—Å–ª–∏ None, –±–µ—Ä—ë—Ç—Å—è –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è)
        """
        self.model = model
        self.max_tokens = max_tokens
        self.temperature = temperature
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Groq
        if api_key is None:
            api_key = os.getenv('GROQ_API_KEY')
            
        if not api_key or not GROQ_AVAILABLE:
            logger.error("GROQ_API_KEY –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞! –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–∞–≥–ª—É—à–∫–∏.")
            self.client = None
            self.fallback_mode = True
        else:
            try:
                self.client = GroqCloud(api_key=api_key)
                self.fallback_mode = False
                logger.info(f"Groq –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –º–æ–¥–µ–ª—å—é {model}")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Groq: {e}")
                self.client = None
                self.fallback_mode = True
        
        # –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
        self.conversation_history: deque[ConversationMessage] = deque(maxlen=max_context_messages)
        
        # –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        self.game_state = GameState()
        self.player_stats = PlayerStats()
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å—Ç—Ä–∏–º–∞
        self.stream_context: Dict[str, Any] = {
            'current_map': '',
            'score': {'ct': 0, 't': 0},
            'round_number': 0,
            'game_phase': 'live',  # live, warmup, timeout, ended
            'recent_events': deque(maxlen=10),
            'mood': Mood.NEUTRAL,
            'last_comment_time': 0,
            'comments_count': 0,
            'streamer_name': '',
            'viewer_count': 0,
            'chat_activity': 'normal'  # slow, normal, active, hyper
        }
        
        # –ö—É–ª–¥–∞—É–Ω—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å–æ–±—ã—Ç–∏–π (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
        self.cooldowns: Dict[str, float] = {
            EventType.KILL.value: 3.0,
            EventType.DEATH.value: 5.0,
            EventType.ROUND_END.value: 2.0,
            EventType.BOMB_PLANTED.value: 10.0,
            EventType.BOMB_DEFUSED.value: 10.0,
            EventType.BOMB_EXPLODED.value: 10.0,
            EventType.CHAT_MESSAGE.value: 8.0,
            EventType.RANDOM_COMMENT.value: 25.0,
            'general': 12.0
        }
        
        # –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤
        self.last_response_times: Dict[str, float] = defaultdict(float)
        
        # –°—á—ë—Ç—á–∏–∫–∏ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ä–µ–∞–∫—Ü–∏–π
        self.response_variety: Dict[str, int] = defaultdict(int)

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        self.stats: Dict[str, Any] = {
            'total_responses': 0,
            'llm_responses': 0,
            'fallback_responses': 0,
            'errors': 0,
            'start_time': time.time()
        }
        
        # –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π
        self._load_response_templates()
        
        logger.info("Iris Brain –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ")
    
    # ===================== –ó–ê–ì–†–£–ó–ö–ê –®–ê–ë–õ–û–ù–û–í =====================
    def _load_response_templates(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤ –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π"""
        self.response_templates = {
            EventType.KILL.value: [
                "–ö—Ä–∞—Å–∏–≤–æ!", "–û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª!", "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!", 
                "–ö—Ä—É—Ç–æ!", "–ï—Å—Ç—å!", "–ß–∏—Å—Ç–æ!", "–ë–µ–∑ —à–∞–Ω—Å–æ–≤!", 
                "–†–∞–∑–æ–±—Ä–∞–ª—Å—è!", "–§—Ä–∞–≥ –≤ –∫–æ–ø–∏–ª–∫—É!", "–£–ª–æ–∂–∏–ª!"
            ],
            EventType.DEATH.value: [
                "–ë—ã–≤–∞–µ—Ç...", "–ù–∏—á–µ–≥–æ, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑!", "–û—Ç–æ–º—Å—Ç–∏–º!", 
                "–£–ø—Å...", "–ù–µ —Ä–∞—Å—Å—Ç—Ä–∞–∏–≤–∞–π—Å—è!", "–ù–µ –ø–æ–≤–µ–∑–ª–æ...",
                "–ñ—ë—Å—Ç–∫–æ...", "–¢–∞–∫–æ–µ —Å–ª—É—á–∞–µ—Ç—Å—è", "–î–µ—Ä–∂–∏—Å—å!", "–°–æ–±–µ—Ä–∏—Å—å!"
            ],
            EventType.ROUND_END.value: [
                "–•–æ—Ä–æ—à–∏–π —Ä–∞—É–Ω–¥!", "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º!", "–î–∞–ª—å—à–µ –±—É–¥–µ—Ç –ª—É—á—à–µ!", 
                "–ù–µ–ø–ª–æ—Ö–æ!", "–û—Ç–ª–∏—á–Ω–æ —Å—ã–≥—Ä–∞–Ω–æ!", "–ö–æ–º–∞–Ω–¥–∞ –º–æ–ª–æ–¥–µ—Ü!",
                "–†–∞–±–æ—Ç–∞–µ–º –¥–∞–ª—å—à–µ!", "–°—á—ë—Ç –ø–æ—à—ë–ª!", "–ó–∞—Ä–∞–±–æ—Ç–∞–ª–∏!"
            ],
            EventType.BOMB_PLANTED.value: [
                "–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞! –ù–∞–ø—Ä—è–∂—ë–Ω–∫–∞!", "–ë–æ–º–±–∞ –Ω–∞ —Ç–æ—á–∫–µ! –í—Ä–µ–º—è –ø–æ—à–ª–æ!",
                "–ó–∞–ª–æ–∂–∏–ª–∏! –ó–∞—â–∏—â–∞–µ–º!", "–ë–æ–º–±–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞! –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º!"
            ],
            EventType.BOMB_DEFUSED.value: [
                "–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞! –ö—Ä–∞—Å–∞–≤—Ü—ã!", "–î–µ—Ñ—É–∑! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ!",
                "–°–ø–∞—Å–ª–∏ —Ä–∞—É–Ω–¥!", "–û–±–µ–∑–≤—Ä–µ–¥–∏–ª–∏! –ú–æ–ª–æ–¥—Ü—ã!"
            ],
            EventType.BOMB_EXPLODED.value: [
                "–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å...", "–í–∑—Ä—ã–≤! –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥.",
                "–ù–µ —É—Å–ø–µ–ª–∏...", "–í–∑–æ—Ä–≤–∞–ª–æ—Å—å..."
            ],
            EventType.DONATION.value: [
                "–°–ø–∞—Å–∏–±–æ –∑–∞ –¥–æ–Ω–∞—Ç!", "–ë–ª–∞–≥–æ–¥–∞—Ä—é –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É!", 
                "–í–∞—É, —Å–ø–∞—Å–∏–±–æ!", "–û–≥—Ä–æ–º–Ω–æ–µ —Å–ø–∞—Å–∏–±–æ!",
                "–¶–µ–Ω–∏–º –ø–æ–¥–¥–µ—Ä–∂–∫—É!", "–°–ø–∞—Å–∏–±–æ, –æ—á–µ–Ω—å –ø—Ä–∏—è—Ç–Ω–æ!"
            ],
            EventType.CHAT_MESSAGE.value: [
                "–ü—Ä–∏–≤–µ—Ç!", "–°–ø–∞—Å–∏–±–æ –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ!", "–†–∞–¥–∞ –≤–∏–¥–µ—Ç—å!",
                "–ó–¥–∞—Ä–æ–≤!", "–ö–∞–∫ –¥–µ–ª–∞?", "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!"
            ]
        }
    
    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–£–õ–î–ê–£–ù–ê–ú–ò =====================
    def _can_respond(self, event_type: EventType) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏–µ (—É—á—ë—Ç –∫—É–ª–¥–∞—É–Ω–æ–≤)
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            
        Returns:
            bool: True –µ—Å–ª–∏ –º–æ–∂–Ω–æ –æ—Ç–≤–µ—Ç–∏—Ç—å
        """
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        cooldown = self.cooldowns.get(event_str, 10.0)
        last_time = self.last_response_times.get(event_str, 0)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if time.time() - last_time < cooldown:
            logger.debug(f"–ö—É–ª–¥–∞—É–Ω –¥–ª—è {event_str}: {cooldown - (time.time() - last_time):.1f}—Å –æ—Å—Ç–∞–ª–æ—Å—å")
            return False
            
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —á–∞—Ç–∞
        if event_str == EventType.CHAT_MESSAGE.value:
            if self.stream_context['chat_activity'] == 'hyper':
                return random.random() < 0.1  # 10% —à–∞–Ω—Å –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ
            elif self.stream_context['chat_activity'] == 'slow':
                return random.random() < 0.3  # 30% —à–∞–Ω—Å –≤ –º–µ–¥–ª–µ–Ω–Ω–æ–º —á–∞—Ç–µ
            else:
                return random.random() < 0.2  # 20% –≤ –æ–±—ã—á–Ω–æ–º
        
        return True
    
    def _mark_responded(self, event_type: EventType):
        """–û—Ç–º–µ—Ç–∏—Ç—å –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏–µ"""
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        self.last_response_times[event_str] = time.time()
    
    # ===================== –ü–û–°–¢–†–û–ï–ù–ò–ï –°–û–û–ë–©–ï–ù–ò–ô –î–õ–Ø API =====================
    def _build_messages(self, user_prompt: str, context: str = "") -> List[Dict]:
        """
        –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ LLM
        
        Args:
            user_prompt: –ü—Ä–æ–º–ø—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
            
        Returns:
            List[Dict]: –°–ø–∏—Å–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ API
        """
        messages = []
        
        # 1. –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç
        messages.append({"role": "system", "content": self.SYSTEM_PROMPT})
        
        # 2. –ü—Ä–æ–º–ø—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        current_mood = self.stream_context['mood']
        if current_mood != Mood.NEUTRAL and current_mood in self.MOOD_PROMPTS:
            messages.append({"role": "system", "content": self.MOOD_PROMPTS[current_mood]})
        
        # 3. –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        if context:
            messages.append({
                "role": "system", 
                "content": f"–¢–ï–ö–£–©–ò–ô –ö–û–ù–¢–ï–ö–°–¢ –°–¢–†–ò–ú–ê:\n{context}"
            })
        
        # 4. –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
        for msg in self.conversation_history:
            messages.append({"role": msg.role, "content": msg.content})
        
        # 5. –¢–µ–∫—É—â–∏–π –∑–∞–ø—Ä–æ—Å
        messages.append({"role": "user", "content": user_prompt})
        
        return messages
    
    def _get_context_string(self) -> str:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ —Å —Ç–µ–∫—É—â–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏–≥—Ä—ã
        
        Returns:
            str: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        """
        ctx = []
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞—Ä—Ç–µ
        if self.game_state.map_name:
            ctx.append(f"–ö–∞—Ä—Ç–∞: {self.game_state.map_name}")
        
        # –°—á—ë—Ç
        if self.game_state.score_ct > 0 or self.game_state.score_t > 0:
            ctx.append(f"–°—á—ë—Ç: CT {self.game_state.score_ct} - {self.game_state.score_t} T")
        
        # –†–∞—É–Ω–¥
        if self.stream_context['round_number'] > 0:
            ctx.append(f"–†–∞—É–Ω–¥: {self.stream_context['round_number']}")
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
        if self.player_stats.kills > 0 or self.player_stats.deaths > 0:
            ctx.append(
                f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: K/D/A: {self.player_stats.kills}/{self.player_stats.deaths}/{self.player_stats.assists} "
                f"(K/D: {self.player_stats.kd_ratio:.2f})"
            )
        
        # –ë–æ–º–±–∞
        if self.game_state.bomb_planted:
            ctx.append("–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞!")
        
        # –ñ–∏–≤—ã–µ –∏–≥—Ä–æ–∫–∏
        ctx.append(f"–ñ–∏–≤—ã—Ö: CT {self.game_state.players_alive_ct} | T {self.game_state.players_alive_t}")
        
        # –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è
        if self.stream_context['recent_events']:
            recent = list(self.stream_context['recent_events'])[-3:]
            events_desc = []
            for e in recent:
                if isinstance(e, dict):
                    events_desc.append(e.get('type', 'event'))
                else:
                    events_desc.append(str(e))
            ctx.append(f"–ù–µ–¥–∞–≤–Ω–æ: {', '.join(events_desc)}")
        
        return "\n".join(ctx)
    
    # ===================== –û–°–ù–û–í–ù–û–ô –ú–ï–¢–û–î –ì–ï–ù–ï–†–ê–¶–ò–ò =====================
    def generate_response(self, 
                         prompt: str, 
                         event_type: EventType = EventType.RANDOM_COMMENT,
                         force: bool = False) -> Optional[str]:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞
        
        Args:
            prompt: –¢–µ–∫—Å—Ç –ø—Ä–æ–º–ø—Ç–∞
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            force: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫—É–ª–¥–∞—É–Ω—ã
            
        Returns:
            Optional[str]: –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –∏–ª–∏ None
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if not force and not self._can_respond(event_type):
            logger.debug(f"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ {event_type} (–∫—É–ª–¥–∞—É–Ω)")
            return None
        
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        logger.info(f"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –¥–ª—è {event_type}")
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
        if self.fallback_mode or not self.client:
            response = self._generate_fallback_response(event_type)
            self.stats['fallback_responses'] += 1
        else:
            try:
                # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
                context = self._get_context_string()
                messages = self._build_messages(prompt, context)
                
                # –í—ã–∑–æ–≤ API Groq
                start_time = time.time()
                
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º GroqCloud API
                response_obj = self.client.chat.completions.create(
                    model=self.model,
                    messages=messages,
                    temperature=self.temperature,
                    max_tokens=self.max_tokens,
                    top_p=0.9,
                    frequency_penalty=0.1,
                    presence_penalty=0.1,
                )
                
                elapsed = time.time() - start_time
                
                # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
                response = response_obj.choices[0].message.content.strip()
                
                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
                logger.info(f"LLM –æ—Ç–≤–µ—Ç –∑–∞ {elapsed:.2f}—Å: {response[:50]}...")
                self.stats['llm_responses'] += 1
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ LLM: {e}")
                response = self._generate_fallback_response(event_type)
                self.stats['errors'] += 1
                self.stats['fallback_responses'] += 1
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
        if response:
            self._add_to_history("user", prompt)
            self._add_to_history("assistant", response)
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            self.stats['total_responses'] += 1
            self.stream_context['last_comment_time'] = time.time()
            self.stream_context['comments_count'] += 1
            
            # –û—Ç–º–µ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞
            self._mark_responded(event_type)
        
        return response
    
    def _add_to_history(self, role: str, content: str):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é"""
        self.conversation_history.append(
            ConversationMessage(
                role=role,
                content=content,
                timestamp=time.time(),
                tokens=len(content.split())  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤
            )
        )
    
    def _generate_fallback_response(self, event_type: EventType) -> str:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞-–∑–∞–≥–ª—É—à–∫–∏ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            
        Returns:
            str: –û—Ç–≤–µ—Ç-–∑–∞–≥–ª—É—à–∫–∞
        """
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ –¥–ª—è —Å–æ–±—ã—Ç–∏—è
        templates = self.response_templates.get(event_str, ["–û–∫!", "–ü–æ–Ω—è—Ç–Ω–æ!", "–•–æ—Ä–æ—à–æ!"])
        
        # –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ —à–∞–±–ª–æ–Ω–∞
        response = random.choice(templates)
        
        # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        mood = self.stream_context['mood']
        if mood == Mood.SARCASTIC and random.random() > 0.5:
            response = response.replace("!", "...").replace(".", " –∫–æ–Ω–µ—á–Ω–æ.")
        elif mood == Mood.EXCITED and random.random() > 0.5:
            response = response.upper()[:1] + response[1:] + "!!!"
        
        logger.debug(f"–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è {event_str}: {response}")
        return response
    
    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –ò–ì–†–û–í–´–ï –°–û–ë–´–¢–ò–Ø =====================
    def react_to_kill(self, kill_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ, —Å–æ–≤–µ—Ä—à—ë–Ω–Ω–æ–µ —Å—Ç—Ä–∏–º–µ—Ä–æ–º
        
        Args:
            kill_data: –î–∞–Ω–Ω—ã–µ –æ–± —É–±–∏–π—Å—Ç–≤–µ
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        round_kills = kill_data.get('round_kills', 1)
        kill_streak = kill_data.get('kill_streak', 1)
        is_headshot = kill_data.get('headshot', False)
        weapon = kill_data.get('weapon', 'unknown').replace('weapon_', '')
        is_ace = kill_data.get('ace', False)
        is_clutch = kill_data.get('clutch', False)
        victim = kill_data.get('victim', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')
        
        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —É–±–∏–π—Å—Ç–≤–∞
        if is_ace:
            prompt = f"–ò–≥—Ä–æ–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–¥–µ–ª–∞–ª ACE! –£–±–∏–ª –≤—Å–µ—Ö 5 –≤—Ä–∞–≥–æ–≤ –≤ —Ä–∞—É–Ω–¥–µ! –≠—Ç–æ –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ! –î–∞–π —ç–ø–∏—á–Ω—É—é —Ä–µ–∞–∫—Ü–∏—é."
        elif round_kills >= 4:
            prompt = f"–ò–≥—Ä–æ–∫ —É–±–∏–ª 4 –≤—Ä–∞–≥–æ–≤ –≤ —ç—Ç–æ–º —Ä–∞—É–Ω–¥–µ! –û—Å—Ç–∞–ª—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π! –†–µ–∞–≥–∏—Ä—É–π —Å –≤–æ–ª–Ω–µ–Ω–∏–µ–º."
        elif round_kills >= 3:
            prompt = f"–¢—Ä–æ–π–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ! –ò–≥—Ä–æ–∫ –≤ —è—Ä–æ—Å—Ç–∏! –ö—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π."
        elif is_clutch:
            prompt = f"Clutch —Å–∏—Ç—É–∞—Ü–∏—è! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –ø—Ä–æ—Ç–∏–≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏ —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–±–∏–ª –æ–¥–Ω–æ–≥–æ! –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ –∑–∞—à–∫–∞–ª–∏–≤–∞–µ—Ç!"
        elif is_headshot:
            prompt = f"–¢–æ—á–Ω—ã–π —Ö–µ–¥—à–æ—Ç —Å {weapon}! –ß–∏—Å—Ç—ã–π –≤—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π."
        elif kill_streak >= 3:
            prompt = f"–ò–≥—Ä–æ–∫ –Ω–∞ —Å–µ—Ä–∏–∏ –∏–∑ {kill_streak} —É–±–∏–π—Å—Ç–≤! –û–Ω –≤ —É–¥–∞—Ä–µ! –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ."
        else:
            # –û–±—ã—á–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ
            variety = self.response_variety['kill'] % 5
            self.response_variety['kill'] += 1
            
            prompts = [
                f"–ò–≥—Ä–æ–∫ —É–±–∏–ª {victim} —Å {weapon}. –ú–æ–∂–µ—à—å –∫—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å.",
                f"–ï—â—ë –æ–¥–∏–Ω —Ñ—Ä–∞–≥ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é. –û—Ä—É–∂–∏–µ: {weapon}.",
                f"–£–±–∏–π—Å—Ç–≤–æ. –ò–≥—Ä–æ–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Å–æ–±–∏—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.",
                f"–§—Ä–∞–≥! {victim} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ respawn.",
                f"–ö–∏–ª–ª. –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è."
            ]
            prompt = prompts[variety]
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        self.player_stats.kills += 1
        self.player_stats.streak += 1
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['recent_events'].append({
            'type': 'kill',
            'weapon': weapon,
            'headshot': is_headshot,
            'time': time.time()
        })
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
        return self.generate_response(prompt, EventType.KILL)
    
    def react_to_death(self, death_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–º–µ—Ä—Ç—å —Å—Ç—Ä–∏–º–µ—Ä–∞
        
        Args:
            death_data: –î–∞–Ω–Ω—ã–µ –æ —Å–º–µ—Ä—Ç–∏
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        killer = death_data.get('killer', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')
        weapon = death_data.get('weapon', 'unknown')
        is_headshot = death_data.get('headshot', False)
        total_deaths = death_data.get('total_deaths', self.player_stats.deaths + 1)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        self.player_stats.deaths += 1
        self.player_stats.streak = 0  # –°–±—Ä–æ—Å —Å–µ—Ä–∏–∏
        
        # –†–∞—Å—á—ë—Ç K/D ratio
        if self.player_stats.deaths > 0:
            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths
        
        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞
        variety = self.response_variety['death'] % 4
        self.response_variety['death'] += 1
        
        if self.player_stats.kd_ratio < 0.7:
            prompts = [
                f"–ò–≥—Ä–æ–∫ —Å–Ω–æ–≤–∞ —É–º–µ—Ä –æ—Ç {killer} (–æ—Ä—É–∂–∏–µ: {weapon}). K/D —Å–µ–π—á–∞—Å {self.player_stats.kd_ratio:.2f}. –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ.",
                f"–ï—â—ë –æ–¥–Ω–∞ —Å–º–µ—Ä—Ç—å. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∞–¥–∞–µ—Ç. –ù—É–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å—Å—è!",
                f"–£–±–∏—Ç {killer}. –í—Ä–µ–º—è –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞!",
                f"–°–º–µ—Ä—Ç—å. –ù–æ —ç—Ç–æ –ø–æ–≤–æ–¥ —Å—Ç–∞—Ç—å –ª—É—á—à–µ!"
            ]
        elif total_deaths > 12:
            prompts = [
                f"–£–∂–µ {total_deaths} —Å–º–µ—Ä—Ç–µ–π –≤ —ç—Ç–æ–º –º–∞—Ç—á–µ. –ü–æ—Ä–∞ –º–µ–Ω—è—Ç—å —Ç–∞–∫—Ç–∏–∫—É?",
                f"–ú–Ω–æ–≥–æ —Å–º–µ—Ä—Ç–µ–π —Å–µ–≥–æ–¥–Ω—è. –ú–æ–∂–µ—Ç, —Å–º–µ–Ω–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é?",
                f"–û–ø—è—Ç—å —Å–º–µ—Ä—Ç—å. –ù–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–æ!",
                f"–£–±–∏—Ç. –ó–∞–ø–æ–º–Ω–∏–º —ç—Ç–æ–≥–æ {killer} –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞."
            ]
        elif is_headshot:
            prompts = [
                f"–•–µ–¥—à–æ—Ç –æ—Ç {killer}... –ñ—ë—Å—Ç–∫–æ. –ù–æ —ç—Ç–æ —á–∞—Å—Ç—å –∏–≥—Ä—ã.",
                f"–í—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –£–≤–∞–∂–∞—é —Ç–æ—á–Ω–æ—Å—Ç—å {killer}.",
                f"–¢–æ—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª. –ù–∏—á–µ–≥–æ –Ω–µ –ø–æ–¥–µ–ª–∞–µ—à—å.",
                f"–í –≥–æ–ª–æ–≤—É. –ò–Ω–æ–≥–¥–∞ –≤–µ–∑—ë—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫—É."
            ]
        else:
            prompts = [
                f"–ò–≥—Ä–æ–∫ —É–º–µ—Ä –æ—Ç {killer} ({weapon}). –ú–æ–∂–µ—à—å –ø–æ—Å–æ—á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å –∏–ª–∏ –ø–æ–¥–±–æ–¥—Ä–∏—Ç—å.",
                f"–°–º–µ—Ä—Ç—å. –í—Ä–µ–º—è –ø–æ–¥—É–º–∞—Ç—å –Ω–∞–¥ –æ—à–∏–±–∫–∞–º–∏.",
                f"–£–±–∏—Ç. –ù–æ –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è!",
                f"–ù–µ –ø–æ–≤–µ–∑–ª–æ. –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ –±—É–¥–µ—Ç –Ω–∞—à–∏–º!"
            ]
        
        prompt = prompts[variety]
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['recent_events'].append({
            'type': 'death',
            'killer': killer,
            'weapon': weapon,
            'time': time.time()
        })
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        if self.player_stats.kd_ratio < 0.5:
            self.stream_context['mood'] = Mood.SUPPORTIVE
        
        return self.generate_response(prompt, EventType.DEATH)
    
    def react_to_round_end(self, round_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ä–∞—É–Ω–¥–∞
        
        Args:
            round_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–∞—É–Ω–¥–µ
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        won = round_data.get('won', False)
        round_kills = round_data.get('round_kills', 0)
        is_clutch = round_data.get('clutch', False)
        win_reason = round_data.get('win_reason', '')
        round_number = round_data.get('round_number', 0)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['round_number'] = round_number
        
        if won:
            if self.game_state.score_t > self.game_state.score_ct:
                self.game_state.score_t += 1
            else:
                self.game_state.score_ct += 1
        else:
            if self.game_state.score_t > self.game_state.score_ct:
                self.game_state.score_ct += 1
            else:
                self.game_state.score_t += 1
        
        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞
        if is_clutch:
            prompt = "–ù–µ–≤–µ—Ä–æ—è—Ç–Ω—ã–π –∫–ª–∞—Ç—á! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –≤—ã–∏–≥—Ä–∞–ª —Ä–∞—É–Ω–¥! –≠—Ç–æ –Ω—É–∂–Ω–æ –æ—Ç–º–µ—Ç–∏—Ç—å!"
        elif won and round_kills >= 3:
            prompt = f"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ò–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤ –∏ –ø—Ä–∏–Ω—ë—Å –∫–æ–º–∞–Ω–¥–µ –ø–æ–±–µ–¥—É! –ü–æ—Ö–≤–∞–ª–∏ –µ–≥–æ."
        elif won and 'bomb' in win_reason.lower():
            prompt = "–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω –ø–æ –±–æ–º–±–µ! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ —Å –∑–∞–∫–ª–∞–¥–∫–æ–π/–∑–∞—â–∏—Ç–æ–π!"
        elif won:
            prompt = "–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ö–æ–º–∞–Ω–¥–∞ —Å–ø—Ä–∞–≤–∏–ª–∞—Å—å. –ö–æ—Ä–æ—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π."
        elif round_kills >= 3:
            prompt = f"–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω, –Ω–æ –∏–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤. –û–Ω —Å—Ä–∞–∂–∞–ª—Å—è –¥–æ –∫–æ–Ω—Ü–∞!"
        else:
            prompt = "–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω. –ù—É–∂–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –∏ –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ."
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        if won:
            self.stream_context['mood'] = random.choice([Mood.HAPPY, Mood.EXCITED])
        else:
            self.stream_context['mood'] = Mood.SUPPORTIVE
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        self.stream_context['recent_events'].append({
            'type': 'round_end',
            'won': won,
            'reason': win_reason,
            'time': time.time()
        })
        
        return self.generate_response(prompt, EventType.ROUND_END)
    
    def react_to_bomb_event(self, event_type: str, event_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π
            event_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–±—ã—Ç–∏–∏
            
        Returns:
            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None
        """
        if event_type == 'plant':
            planter = event_data.get('planter', '–∏–≥—Ä–æ–∫')
            site = event_data.get('site', 'A')
            time_left = event_data.get('time_left', 40)
            
            self.game_state.bomb_planted = True
            
            prompt = f"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞ –Ω–∞ {site} {planter}! –û—Å—Ç–∞–ª–æ—Å—å {time_left} —Å–µ–∫—É–Ω–¥. –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ —Ä–∞—Å—Ç—ë—Ç!"
            
        elif event_type == 'defuse':
            defuser = event_data.get('defuser', '–∏–≥—Ä–æ–∫')
            is_ninja = event_data.get('ninja', False)
            
            self.game_state.bomb_planted = False
            
            if is_ninja:
                prompt = f"–ù–ò–ù–î–ó–Ø –î–ï–§–£–ó! {defuser} –æ–±–µ–∑–≤—Ä–µ–¥–∏–ª –±–æ–º–±—É –ø—Ä—è–º–æ –ø–æ–¥ –Ω–æ—Å–æ–º —É –≤—Ä–∞–≥–æ–≤! –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!"
            else:
                prompt = f"–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞ {defuser}! –†–∞—É–Ω–¥ —Å–ø–∞—Å—ë–Ω! –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!"
                
        elif event_type == 'explode':
            self.game_state.bomb_planted = False
            prompt = "–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å! –ú–æ—â–Ω—ã–π –≤–∑—Ä—ã–≤ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞—É–Ω–¥."
            
        else:
            return None
        
        return self.generate_response(prompt, EventType.BOMB_EXPLODED)
    
    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –°–û–ë–´–¢–ò–Ø –°–¢–†–ò–ú–ê =====================
    def react_to_donation(self, donation_data: Dict) -> str:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –¥–æ–Ω–∞—Ç
        
        Args:
            donation_data: –î–∞–Ω–Ω—ã–µ –æ –¥–æ–Ω–∞—Ç–µ
            
        Returns:
            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é
        """
        username = donation_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        amount = donation_data.get('amount', 0)
        currency = donation_data.get('currency', '—Ä—É–±–ª–µ–π')
        message = donation_data.get('message', '')
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É–º–º—ã
        if amount >= 1000:
            amount_str = f"{amount:,} {currency}".replace(',', ' ')
        else:
            amount_str = f"{amount} {currency}"
        
        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞
        prompt = f"–ó—Ä–∏—Ç–µ–ª—å {username} —Ç–æ–ª—å–∫–æ —á—Ç–æ –∑–∞–¥–æ–Ω–∞—Ç–∏–ª {amount_str}!"
        
        if message:
            prompt += f"\n–°–æ–æ–±—â–µ–Ω–∏–µ: \"{message}\""
        
        prompt += "\n–ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –µ–≥–æ –∏—Å–∫—Ä–µ–Ω–Ω–µ –∏ —Ç–µ–ø–ª–æ. –ï—Å–ª–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ —Ç–µ–º–∞ ‚Äî –æ—Ç—Ä–µ–∞–≥–∏—Ä—É–π –Ω–∞ –Ω–µ—ë."
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        self.stream_context['mood'] = Mood.HAPPY
        
        return self.generate_response(prompt, EventType.DONATION, force=True)
    
    def react_to_subscription(self, sub_data: Dict) -> str:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É
        
        Args:
            sub_data: –î–∞–Ω–Ω—ã–µ –æ –ø–æ–¥–ø–∏—Å–∫–µ
            
        Returns:
            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é
        """
        username = sub_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        months = sub_data.get('months', 1)
        tier = sub_data.get('tier', 'Tier 1')
        is_gift = sub_data.get('is_gift', False)
        gifter = sub_data.get('gifter', '')
        
        if is_gift and gifter:
            prompt = f"{gifter} –ø–æ–¥–∞—Ä–∏–ª –ø–æ–¥–ø–∏—Å–∫—É {username}! –ö–∞–∂–¥—ã–π —â–µ–¥—Ä—ã–π –∑—Ä–∏—Ç–µ–ª—å –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä–∏–º –ª—É—á—à–µ! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –æ–±–æ–∏—Ö!"
        elif months > 1:
            prompt = f"{username} –ø—Ä–æ–¥–ª–∏–ª –ø–æ–¥–ø–∏—Å–∫—É —É–∂–µ –Ω–∞ {months} –º–µ—Å—è—Ü! –≠—Ç–æ –Ω–∞—Å—Ç–æ—è—â–∞—è –ø—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ –ª–æ—è–ª—å–Ω–æ—Å—Ç—å."
        else:
            prompt = f"–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫ {username}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–∞—à–µ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ! –ü–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –µ–≥–æ —Ç–µ–ø–ª–æ."
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        self.stream_context['mood'] = Mood.HAPPY
        
        return self.generate_response(prompt, EventType.SUBSCRIPTION, force=True)
    
    def react_to_raid(self, raid_data: Dict) -> str:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Ä–µ–π–¥
        
        Args:
            raid_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–µ–π–¥–µ
            
        Returns:
            str: –≠–ø–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–∫—Ü–∏—è
        """
        username = raid_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        viewers = raid_data.get('viewers', 0)
        
        prompt = f"–í–ù–ò–ú–ê–ù–ò–ï! –†–ï–ô–î! {username} –ø—Ä–∏–±—ã–≤–∞–µ—Ç –Ω–∞ —Å—Ç—Ä–∏–º —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏! "
        prompt += "–≠–ø–∏—á–Ω–æ –ø–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –Ω–æ–≤—ã—Ö –∑—Ä–∏—Ç–µ–ª–µ–π –∏ –ø–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ —Ä–µ–π–¥!"
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        self.stream_context['mood'] = Mood.EXCITED
        
        return self.generate_response(prompt, EventType.RAID, force=True)
    
    def react_to_chat_message(self, chat_data: Dict) -> Optional[str]:
        """
        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ
        
        Args:
            chat_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏
            
        Returns:
            Optional[str]: –û—Ç–≤–µ—Ç –∏–ª–∏ None
        """
        username = chat_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        message = chat_data.get('message', '')
        
        if not message or len(message.strip()) < 2:
            return None
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞, –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫ –ò—Ä–∏—Å
        iris_mentioned = any(word in message.lower() for word in [
            '–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∫–∞', '–∏—Ä–∏—à–µ—á–∫–∞', 'iris brain'
        ])
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–º–∞–Ω–¥—É
        is_command = message.startswith('!') and len(message) > 2
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å
        should_respond = False
        
        if iris_mentioned:
            should_respond = True
            logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –ò—Ä–∏—Å –æ—Ç {username}")
        elif is_command:
            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã —á–∞—Ç–∞
            return None
        elif random.random() < 0.15:  # 15% —à–∞–Ω—Å –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            should_respond = True
        
        if not should_respond:
            return None
        
        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞
        prompt = f"–ó—Ä–∏—Ç–µ–ª—å {username} –Ω–∞–ø–∏—Å–∞–ª –≤ —á–∞—Ç: \"{message}\""
        
        if iris_mentioned:
            prompt += "\n–û–Ω –æ–±—Ä–∞—Ç–∏–ª—Å—è –∫ —Ç–µ–±–µ –Ω–∞–ø—Ä—è–º—é! –û—Ç–≤–µ—Ç—å –≤–µ–∂–ª–∏–≤–æ –∏ –ø–æ –¥–µ–ª—É."
        else:
            prompt += "\n–ú–æ–∂–µ—à—å –æ—Ç–≤–µ—Ç–∏—Ç—å –∫—Ä–∞—Ç–∫–æ, –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ —Å–∫–∞–∑–∞—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ."
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if not self._can_respond(EventType.CHAT_MESSAGE):
            logger.debug(f"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ {username} (–∫—É–ª–¥–∞—É–Ω —á–∞—Ç–∞)")
            return None
        
        return self.generate_response(prompt, EventType.CHAT_MESSAGE)
    
    # ===================== –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï –° –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ú =====================
    def chat_with_user(self, user_message: str, username: str = "—Å—Ç—Ä–∏–º–µ—Ä") -> str:
        """
        –ü—Ä—è–º–æ–π –¥–∏–∞–ª–æ–≥ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
        
        Args:
            user_message: –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            username: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            
        Returns:
            str: –û—Ç–≤–µ—Ç –ò—Ä–∏—Å
        """
        prompt = f"{username} –≥–æ–≤–æ—Ä–∏—Ç —Ç–µ–±–µ: {user_message}"
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        user_lower = user_message.lower()
        
        if any(word in user_lower for word in ['–ø—Ä–∏–≤–µ—Ç', '–∑–¥–∞—Ä–æ–≤', 'hi', 'hello']):
            event_type = EventType.CHAT_MESSAGE
            self.stream_context['mood'] = Mood.HAPPY
        elif any(word in user_lower for word in ['–∫–∞–∫ –¥–µ–ª–∞', '–∫–∞–∫ —Ç—ã', 'how are']):
            event_type = EventType.CHAT_MESSAGE
        elif '?' in user_message:
            event_type = EventType.COMMAND
        else:
            event_type = EventType.GENERAL
        
        return self.generate_response(prompt, event_type, force=True)
    
    def generate_random_comment(self) -> Optional[str]:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –æ —Å—Ç—Ä–∏–º–µ
        
        Returns:
            Optional[str]: –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∏–ª–∏ None
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
        if not self._can_respond(EventType.RANDOM_COMMENT):
            return None
        
        # –®–∞–Ω—Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
        if random.random() > 0.25:  # 25% —à–∞–Ω—Å
            return None
        
        # –í—ã–±–æ—Ä —Ç–∏–ø–∞ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
        comment_type = random.choice(['game', 'stream', 'question', 'observation'])
        
        if comment_type == 'game':
            prompts = [
                "–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä–æ–≤–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏.",
                "–ß—Ç–æ —Ç—ã –¥—É–º–∞–µ—à—å –æ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–º–∞–Ω–¥—ã?",
                "–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π —Ç–µ–∫—É—â–∏–π —Å—á—ë—Ç –∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã –º–∞—Ç—á–∞.",
                "–ó–∞–º–µ—Ç–∫–∞ –æ–± –∏–≥—Ä–µ –∏–ª–∏ —Ç–∞–∫—Ç–∏–∫–µ."
            ]
        elif comment_type == 'stream':
            prompts = [
                "–°–∫–∞–∂–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –∞—Ç–º–æ—Å—Ñ–µ—Ä–µ —Å—Ç—Ä–∏–º–∞ —Å–µ–≥–æ–¥–Ω—è.",
                "–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π –∫–∞—á–µ—Å—Ç–≤–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ.",
                "–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç—Ä–∏–º–µ –∏–ª–∏ –∑—Ä–∏—Ç–µ–ª—è—Ö.",
                "–°–ª—É—á–∞–π–Ω–∞—è –º—ã—Å–ª—å –æ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–º —ç—Ñ–∏—Ä–µ."
            ]
        elif comment_type == 'question':
            prompts = [
                "–ó–∞–¥–∞–π —Å—Ç—Ä–∏–º–µ—Ä—É –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ –µ–≥–æ —Ç–∞–∫—Ç–∏–∫–µ.",
                "–°–ø—Ä–æ—Å–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –ø–ª–∞–Ω–∞—Ö –Ω–∞ –∏–≥—Ä—É.",
                "–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ CS2 –∏–ª–∏ —Ç–µ–∫—É—â–µ–º –º–∞—Ç—á–µ.",
                "–°–ø—Ä–æ—Å–∏ –º–Ω–µ–Ω–∏–µ –æ –ø–æ—Å–ª–µ–¥–Ω–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤ –∏–≥—Ä–µ."
            ]
        else:  # observation
            prompts = [
                "–ü–æ–¥–µ–ª–∏—Å—å –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ–º –æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ä–∞—É–Ω–¥–∞—Ö.",
                "–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ –∏–≥—Ä–æ–∫–∞.",
                "–ù–∞–±–ª—é–¥–µ–Ω–∏–µ –æ –∫–∞—Ä—Ç–µ –∏–ª–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏.",
                "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ –º–µ—Ç–∞-–∏–≥—Ä–µ –∏–ª–∏ —Ç—Ä–µ–Ω–¥–∞—Ö."
            ]
        
        prompt = random.choice(prompts)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
        self.stream_context['mood'] = random.choice([
            Mood.NEUTRAL, Mood.FUNNY, Mood.SUPPORTIVE
        ])
        
        return self.generate_response(prompt, EventType.RANDOM_COMMENT)
    
    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–û–ù–¢–ï–ö–°–¢–û–ú =====================
    def update_context(self, 
                      map_name: Optional[str] = None,
                      ct_score: Optional[int] = None,
                      t_score: Optional[int] = None,
                      round_number: Optional[int] = None,
                      player_stats: Optional[Dict] = None,
                      event: Optional[Dict] = None,
                      chat_activity: Optional[str] = None,
                      viewer_count: Optional[int] = None):
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å—Ç—Ä–∏–º–∞
        
        Args:
            map_name: –ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã
            ct_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã CT
            t_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã T
            round_number: –ù–æ–º–µ—Ä —Ä–∞—É–Ω–¥–∞
            player_stats: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
            event: –°–æ–±—ã—Ç–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é
            chat_activity: –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —á–∞—Ç–∞ (slow/normal/active/hyper)
            viewer_count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑—Ä–∏—Ç–µ–ª–µ–π
        """
        if map_name:
            self.game_state.map_name = map_name
            self.stream_context['current_map'] = map_name
        
        if ct_score is not None:
            self.game_state.score_ct = ct_score
            self.stream_context['score']['ct'] = ct_score
        
        if t_score is not None:
            self.game_state.score_t = t_score
            self.stream_context['score']['t'] = t_score
        
        if round_number is not None:
            self.stream_context['round_number'] = round_number
        
        if player_stats:
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞
            for key, value in player_stats.items():
                if hasattr(self.player_stats, key):
                    setattr(self.player_stats, key, value)
            
            # –†–∞—Å—á—ë—Ç K/D ratio
            if self.player_stats.deaths > 0:
                self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths
            elif self.player_stats.kills > 0:
                self.player_stats.kd_ratio = self.player_stats.kills
        
        if event:
            self.stream_context['recent_events'].append(event)
        
        if chat_activity:
            self.stream_context['chat_activity'] = chat_activity
        
        if viewer_count is not None:
            self.stream_context['viewer_count'] = viewer_count
            
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑—Ä–∏—Ç–µ–ª–µ–π
            if viewer_count > 1000:
                self.stream_context['mood'] = Mood.EXCITED
            elif viewer_count > 100:
                self.stream_context['mood'] = Mood.HAPPY
    
    def update_game_state(self, **kwargs):
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        
        Args:
            **kwargs: –ü–æ–ª—è GameState –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        """
        for key, value in kwargs.items():
            if hasattr(self.game_state, key):
                setattr(self.game_state, key, value)
    
    def update_player_stats(self, **kwargs):
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞
        
        Args:
            **kwargs: –ü–æ–ª—è PlayerStats –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        """
        for key, value in kwargs.items():
            if hasattr(self.player_stats, key):
                setattr(self.player_stats, key, value)
        
        # –ü–µ—Ä–µ—Å—á—ë—Ç K/D ratio
        if self.player_stats.deaths > 0:
            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths
    
    # ===================== –£–¢–ò–õ–ò–¢–´ –ò –°–¢–ê–¢–ò–°–¢–ò–ö–ê =====================
    def get_stats(self) -> Dict:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞–±–æ—Ç—ã Iris Brain
        
        Returns:
            Dict: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        """
        stats = self.stats.copy()
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        stats['conversation_history_size'] = len(self.conversation_history)
        stats['recent_events_count'] = len(self.stream_context['recent_events'])
        stats['current_mood'] = self.stream_context['mood'].value
        stats['uptime'] = time.time() - stats['start_time']
        stats['responses_per_minute'] = stats['total_responses'] / (stats['uptime'] / 60) if stats['uptime'] > 0 else 0
        
        # –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        stats['game_state'] = {
            'map': self.game_state.map_name,
            'score': f"{self.game_state.score_ct}-{self.game_state.score_t}",
            'bomb_planted': self.game_state.bomb_planted
        }
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
        stats['player_stats'] = asdict(self.player_stats)
        
        return stats
    
    def save_conversation(self, filename: str = None):
        """
        –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –≤ —Ñ–∞–π–ª
        
        Args:
            filename: –ò–º—è —Ñ–∞–π–ª–∞ (–µ—Å–ª–∏ None, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"iris_conversation_{timestamp}.json"
        
        conversation_data = []
        for msg in self.conversation_history:
            conversation_data.append({
                'role': msg.role,
                'content': msg.content,
                'timestamp': msg.timestamp,
                'time_str': datetime.fromtimestamp(msg.timestamp).strftime("%H:%M:%S")
            })
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(conversation_data, f, ensure_ascii=False, indent=2)
            logger.info(f"–ò—Å—Ç–æ—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {filename}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏: {e}")
    
    def load_conversation(self, filename: str):
        """
        –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏–∑ —Ñ–∞–π–ª–∞
        
        Args:
            filename: –ò–º—è —Ñ–∞–π–ª–∞
        """
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                conversation_data = json.load(f)
            
            self.conversation_history.clear()
            for msg_data in conversation_data:
                self.conversation_history.append(
                    ConversationMessage(
                        role=msg_data['role'],
                        content=msg_data['content'],
                        timestamp=msg_data['timestamp']
                    )
                )
            
            logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(conversation_data)} —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ {filename}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏: {e}")
    
    def clear_history(self):
        """–û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞"""
        self.conversation_history.clear()
        self.stream_context['recent_events'].clear()
        logger.info("–ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞")
    
    def reset_stats(self):
        """–°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        self.stats = {
            'total_responses': 0,
            'llm_responses': 0,
            'fallback_responses': 0,
            'errors': 0,
            'start_time': time.time()
        }
        logger.info("–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞")
    
    def set_mood(self, mood: Mood):
        """
        –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å
        
        Args:
            mood: –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –∏–∑ enum Mood
        """
        self.stream_context['mood'] = mood
        logger.info(f"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {mood.value}")
    
    def adjust_cooldown(self, event_type: EventType, cooldown: float):
        """
        –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞ –¥–ª—è —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
            cooldown: –ù–æ–≤—ã–π –∫—É–ª–¥–∞—É–Ω –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        """
        event_str = event_type.value if isinstance(event_type, EventType) else event_type
        self.cooldowns[event_str] = cooldown
        logger.info(f"–ö—É–ª–¥–∞—É–Ω {event_str} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {cooldown}—Å")


# ===================== –ü–†–ò–ú–ï–† –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø =====================
if __name__ == "__main__":
    print("=== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï IRIS BRAIN ===")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    iris = IrisBrain()
    
    print(f"–†–µ–∂–∏–º –∑–∞–≥–ª—É—à–∫–∏: {iris.fallback_mode}")
    print(f"–ú–æ–¥–µ–ª—å: {iris.model}")
    
    # –¢–µ—Å—Ç–æ–≤—ã–µ –≤—ã–∑–æ–≤—ã
    print("\n1. –¢–µ—Å—Ç —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è:")
    comment = iris.generate_random_comment()
    print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {comment}")
    
    print("\n2. –¢–µ—Å—Ç —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ:")
    kill_response = iris.react_to_kill({
        'weapon': 'ak47',
        'headshot': True,
        'round_kills': 2,
        'victim': '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫'
    })
    print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {kill_response}")
    
    print("\n3. –¢–µ—Å—Ç –¥–∏–∞–ª–æ–≥–∞:")
    chat_response = iris.chat_with_user("–ü—Ä–∏–≤–µ—Ç, –ò—Ä–∏—Å! –ö–∞–∫ —Ç–≤–æ–∏ –¥–µ–ª–∞?", "–¢–µ—Å—Ç–µ—Ä")
    print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {chat_response}")
    
    print("\n4. –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:")
    stats = iris.get_stats()
    print(f"–í—Å–µ–≥–æ –æ—Ç–≤–µ—Ç–æ–≤: {stats['total_responses']}")
    print(f"–û—Ç–≤–µ—Ç–æ–≤ LLM: {stats['llm_responses']}")
    print(f"–ó–∞–≥–ª—É—à–µ–∫: {stats['fallback_responses']}")
    
    print("\n=== –¢–ï–°–¢ –ó–ê–í–ï–†–®–ï–ù ===")
</file>

<file path="src/iris_core/modules/voice_ai.py">
"""
IRIS Voice Input - –°—É–ø–µ—Ä-–ø—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –≤–µ—Ä—Å–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
–í–µ—Ä—Å–∏—è: 5.0.0 - –ò–ò-–ú–æ–∑–≥ —Å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ–º –∏ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏
"""

import asyncio
import threading
import time
import queue
import os
import json
import logging
import sys
import pickle
import hashlib
import uuid
from typing import Optional, Callable, List, Dict, Any, Tuple, Union, Set
from pathlib import Path
from dataclasses import dataclass, asdict, field
from enum import Enum, auto
from datetime import datetime, timedelta
from collections import defaultdict, deque
import numpy as np
import wave
import io

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–º –∞–Ω–∞–ª–∏–∑–æ–º
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('iris_ai.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('IRIS-AI')

# ============================================
# –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò–ò-–ú–û–î–£–õ–Ø
# ============================================

AI_MODES = {
    "ADAPTIVE": "adaptive",           # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ–º
    "NEURAL": "neural",               # –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤–æ–π —Ä–µ–∂–∏–º
    "CONTEXTUAL": "contextual",       # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–≤–∏—Å–∏–º—ã–π
    "EMOTIONAL": "emotional",         # –° —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–æ–º
    "MULTIMODAL": "multimodal",       # –ú—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω—ã–π (–≥–æ–ª–æ—Å + —Ç–µ–∫—Å—Ç)
    "AUTONOMOUS": "autonomous"        # –ê–≤—Ç–æ–Ω–æ–º–Ω–æ–µ –ø—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏–π
}

EMOTION_TYPES = {
    "NEUTRAL": "neutral",
    "HAPPY": "happy",
    "SAD": "sad",
    "ANGRY": "angry",
    "EXCITED": "excited",
    "CALM": "calm",
    "STRESSED": "stressed",
    "CONFUSED": "confused"
}

CONTEXT_DOMAINS = {
    "WEATHER": "weather",
    "MUSIC": "music",
    "NEWS": "news",
    "SMART_HOME": "smart_home",
    "SCHEDULE": "schedule",
    "COMMUNICATION": "communication",
    "ENTERTAINMENT": "entertainment",
    "PRODUCTIVITY": "productivity",
    "LEARNING": "learning",
    "HEALTH": "health"
}

# ============================================
# –î–ò–ù–ê–ú–ò–ß–ï–°–ö–ò–ï –ò–ú–ü–û–†–¢–´ –ú–ê–®–ò–ù–ù–û–ì–û –û–ë–£–ß–ï–ù–ò–Ø
# ============================================

# –ë–∞–∑–æ–≤—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
try:
    import numpy as np
    NP_AVAILABLE = True
except ImportError:
    NP_AVAILABLE = False
    logger.warning("NumPy –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install numpy")

# –ê—É–¥–∏–æ–æ–±—Ä–∞–±–æ—Ç–∫–∞
try:
    import sounddevice as sd
    import soundfile as sf
    SOUND_AVAILABLE = True
except ImportError:
    SOUND_AVAILABLE = False
    logger.warning("SoundDevice/SoundFile –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")

try:
    import pyaudio
    import wave
    PYAUDIO_AVAILABLE = True
except ImportError:
    PYAUDIO_AVAILABLE = False

# –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏
try:
    from vosk import Model, KaldiRecognizer, SetLogLevel
    SetLogLevel(-1)
    VOSK_AVAILABLE = True
except ImportError:
    VOSK_AVAILABLE = False

try:
    import speech_recognition as sr
    SR_AVAILABLE = True
except ImportError:
    SR_AVAILABLE = False

# –Ø–Ω–¥–µ–∫—Å SpeechKit
try:
    import requests
    import uuid as uuid_lib
    YANDEX_AVAILABLE = True
except ImportError:
    YANDEX_AVAILABLE = False

# –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –∏ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏
ML_LIBS = {}
try:
    import torch
    import torch.nn as nn
    import torch.nn.functional as F
    from torch.utils.data import Dataset, DataLoader
    ML_LIBS['PYTORCH'] = True
except ImportError:
    ML_LIBS['PYTORCH'] = False

try:
    import tensorflow as tf
    ML_LIBS['TENSORFLOW'] = True
except ImportError:
    ML_LIBS['TENSORFLOW'] = False

try:
    import sklearn
    from sklearn.cluster import KMeans
    from sklearn.decomposition import PCA
    from sklearn.preprocessing import StandardScaler
    ML_LIBS['SKLEARN'] = True
except ImportError:
    ML_LIBS['SKLEARN'] = False

# NLP –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
try:
    import nltk
    from nltk.tokenize import word_tokenize
    from nltk.corpus import stopwords
    nltk.download('punkt', quiet=True)
    nltk.download('stopwords', quiet=True)
    NLP_AVAILABLE = True
except ImportError:
    NLP_AVAILABLE = False

# –ê—É–¥–∏–æ–æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è
try:
    import librosa
    import librosa.display
    AUDIO_ML_AVAILABLE = True
except ImportError:
    AUDIO_ML_AVAILABLE = False

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
try:
    import matplotlib.pyplot as plt
    from matplotlib.animation import FuncAnimation
    VISUAL_AVAILABLE = True
except ImportError:
    VISUAL_AVAILABLE = False

# ============================================
# –î–ê–¢–ê–ö–õ–ê–°–°–´ –î–õ–Ø –ò–ò-–°–¢–†–£–ö–¢–£–†
# ============================================

@dataclass
class NeuralConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤–æ–≥–æ –º–æ–¥—É–ª—è"""
    use_attention: bool = True
    use_transformer: bool = True
    hidden_layers: int = 4
    neurons_per_layer: int = 256
    dropout_rate: float = 0.3
    learning_rate: float = 0.001
    batch_size: int = 32
    epochs: int = 100
    use_pretrained: bool = True
    model_type: str = "transformer"  # transformer, lstm, cnn, hybrid
    feature_size: int = 128
    context_window: int = 10

@dataclass
class EmotionState:
    """–°–æ—Å—Ç–æ—è–Ω–∏–µ —ç–º–æ—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    emotion: str = "neutral"
    confidence: float = 0.0
    intensity: float = 0.0
    valence: float = 0.0  # –ü–æ–∑–∏—Ç–∏–≤–Ω–æ—Å—Ç—å
    arousal: float = 0.0  # –í–æ–∑–±—É–∂–¥–µ–Ω–∏–µ
    dominance: float = 0.0  # –î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
    timestamp: float = field(default_factory=time.time)
    history: List[Dict] = field(default_factory=list)

@dataclass
class UserProfile:
    """–ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∞–¥–∞–ø—Ç–∞—Ü–∏–µ–π"""
    user_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    voice_features: Dict = field(default_factory=dict)
    speech_patterns: Dict = field(default_factory=dict)
    preferences: Dict = field(default_factory=dict)
    learning_rate: float = 0.1
    adaptation_level: float = 0.0
    interaction_count: int = 0
    last_interaction: float = field(default_factory=time.time)
    created_at: float = field(default_factory=time.time)

@dataclass
class AIContext:
    """–ö–æ–Ω—Ç–µ–∫—Å—Ç –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞"""
    current_domain: str = ""
    previous_commands: List[str] = field(default_factory=list)
    user_intent: str = ""
    entities: List[Dict] = field(default_factory=list)
    conversation_history: List[Dict] = field(default_factory=list)
    memory: Dict = field(default_factory=dict)
    context_score: float = 0.0
    temporal_context: Dict = field(default_factory=dict)

@dataclass
class LearningData:
    """–î–∞–Ω–Ω—ã–µ –¥–ª—è —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è"""
    audio_samples: List = field(default_factory=list)
    transcriptions: List = field(default_factory=list)
    corrections: List = field(default_factory=list)
    success_patterns: List = field(default_factory=list)
    error_patterns: List = field(default_factory=list)
    reinforcement_signals: List = field(default_factory=list)

@dataclass
class PerformanceMetrics:
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
    real_time_factor: float = 0.0
    latency: Dict = field(default_factory=lambda: {"audio": 0.0, "processing": 0.0})
    accuracy: Dict = field(default_factory=lambda: {"wake": 0.0, "command": 0.0})
    efficiency: Dict = field(default_factory=lambda: {"cpu": 0.0, "memory": 0.0})
    quality: Dict = field(default_factory=lambda: {"audio": 0.0, "recognition": 0.0})

# ============================================
# –ù–ï–ô–†–û–°–ï–¢–ï–í–´–ï –ú–û–î–£–õ–ò
# ============================================

class VoiceEncoder(nn.Module):
    """–ù–µ–π—Ä–æ—Å–µ—Ç—å –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π"""
    def __init__(self, input_dim=128, hidden_dim=256, latent_dim=64):
        super().__init__()
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, latent_dim)
        )
        
        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, input_dim),
            nn.Sigmoid()
        )
        
    def forward(self, x):
        latent = self.encoder(x)
        reconstructed = self.decoder(latent)
        return latent, reconstructed

class EmotionClassifier(nn.Module):
    """–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä —ç–º–æ—Ü–∏–π –ø–æ –≥–æ–ª–æ—Å—É"""
    def __init__(self, input_dim=128, num_emotions=8):
        super().__init__()
        self.conv1 = nn.Conv1d(1, 32, kernel_size=5, stride=2)
        self.conv2 = nn.Conv1d(32, 64, kernel_size=5, stride=2)
        self.conv3 = nn.Conv1d(64, 128, kernel_size=5, stride=2)
        
        self.lstm = nn.LSTM(128, 128, batch_first=True, bidirectional=True)
        
        self.fc = nn.Sequential(
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(128, num_emotions),
            nn.Softmax(dim=1)
        )
        
    def forward(self, x):
        x = x.unsqueeze(1)  # Add channel dimension
        x = F.relu(self.conv1(x))
        x = F.relu(self.conv2(x))
        x = F.relu(self.conv3(x))
        
        x = x.transpose(1, 2)
        lstm_out, _ = self.lstm(x)
        
        # Use last hidden state
        last_hidden = lstm_out[:, -1, :]
        emotion_probs = self.fc(last_hidden)
        return emotion_probs

class IntentRecognizer:
    """–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –Ω–∞–º–µ—Ä–µ–Ω–∏–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º NLP"""
    def __init__(self):
        self.intent_patterns = {
            "–≤–∫–ª—é—á–∏—Ç—å": ["–≤–∫–ª—é—á–∏", "–∑–∞–ø—É—Å—Ç–∏", "–∞–∫—Ç–∏–≤–∏—Ä—É–π", "–≤—Ä—É–±–∏", "—Å—Ç–∞—Ä—Ç"],
            "–≤—ã–∫–ª—é—á–∏—Ç—å": ["–≤—ã–∫–ª—é—á–∏", "–æ—Å—Ç–∞–Ω–æ–≤–∏", "–¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–π", "–≤—ã—Ä—É–±–∏", "—Å—Ç–æ–ø"],
            "—É–∑–Ω–∞—Ç—å": ["—Å–∫–æ–ª—å–∫–æ", "–∫–∞–∫–∞—è", "–∫–∞–∫–æ–π", "—á—Ç–æ", "–∫—Ç–æ", "–≥–¥–µ", "–∫–æ–≥–¥–∞"],
            "–∏–∑–º–µ–Ω–∏—Ç—å": ["–∏–∑–º–µ–Ω–∏", "–Ω–∞—Å—Ç—Ä–æ–π", "—Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–π", "–ø–æ–ø—Ä–∞–≤—å"],
            "–Ω–∞–π—Ç–∏": ["–Ω–∞–π–¥–∏", "–ø–æ–∏—â–∏", "–∏—â–∏", "–æ—Ç—ã—â–∏", "–ª–æ–∫–∞–ª–∏–∑—É–π"],
            "—Å–æ–∑–¥–∞—Ç—å": ["—Å–æ–∑–¥–∞–π", "—Å–¥–µ–ª–∞–π", "–ø–æ—Å—Ç—Ä–æ–π", "–æ—Ä–≥–∞–Ω–∏–∑—É–π", "–ø—Ä–∏–¥—É–º–∞–π"],
            "—É–¥–∞–ª–∏—Ç—å": ["—É–¥–∞–ª–∏", "—É–±–µ—Ä–∏", "—Å—Ç–µ—Ä–Ω–∏", "–ª–∏–∫–≤–∏–¥–∏—Ä—É–π", "—Å–æ—Ç—Ä–∏"],
            "–ø–æ–º–æ—á—å": ["–ø–æ–º–æ–≥–∏", "–ø–æ–¥—Å–∫–∞–∂–∏", "–æ–±—ä—è—Å–Ω–∏", "–ø–æ—Å–æ–≤–µ—Ç—É–π", "—Ä–∞—Å—Å–∫–∞–∂–∏"]
        }
        
        self.entity_types = {
            "—É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ": ["—Ç–µ–ª–µ–≤–∏–∑–æ—Ä", "—Å–≤–µ—Ç", "–ª–∞–º–ø–∞", "–∫–æ–Ω–¥–∏—Ü–∏–æ–Ω–µ—Ä", "–æ–±–æ–≥—Ä–µ–≤–∞—Ç–µ–ª—å"],
            "–º–µ–¥–∏–∞": ["–º—É–∑—ã–∫–∞", "—Ñ–∏–ª—å–º", "–≤–∏–¥–µ–æ", "—Ä–∞–¥–∏–æ", "–ø–æ–¥–∫–∞—Å—Ç"],
            "–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è": ["–ø–æ–≥–æ–¥–∞", "–Ω–æ–≤–æ—Å—Ç–∏", "–∫—É—Ä—Å", "–≤—Ä–µ–º—è", "–¥–∞—Ç–∞"],
            "–Ω–∞—Å—Ç—Ä–æ–π–∫–∞": ["–≥—Ä–æ–º–∫–æ—Å—Ç—å", "—è—Ä–∫–æ—Å—Ç—å", "—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞", "—Å–∫–æ—Ä–æ—Å—Ç—å"]
        }
        
    def extract_intent(self, text: str) -> Dict:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –Ω–∞–º–µ—Ä–µ–Ω–∏—è –∏ —Å—É—â–Ω–æ—Å—Ç–µ–π –∏–∑ —Ç–µ–∫—Å—Ç–∞"""
        result = {
            "intent": "unknown",
            "confidence": 0.0,
            "entities": [],
            "action": "",
            "target": ""
        }
        
        text_lower = text.lower()
        words = text_lower.split()
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω—Ç–µ–Ω—Ç
        for intent, patterns in self.intent_patterns.items():
            for pattern in patterns:
                if pattern in text_lower:
                    result["intent"] = intent
                    result["confidence"] = 0.8
                    result["action"] = pattern
                    break
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å—É—â–Ω–æ—Å—Ç–∏
        for entity_type, entities in self.entity_types.items():
            for entity in entities:
                if entity in text_lower:
                    result["entities"].append({
                        "type": entity_type,
                        "value": entity,
                        "position": text_lower.find(entity)
                    })
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–µ–ª—å (–ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–µ)
        if NLP_AVAILABLE:
            try:
                tokens = word_tokenize(text_lower, language='russian')
                pos_tags = nltk.pos_tag(tokens, lang='rus')
                
                for word, tag in pos_tags:
                    if tag.startswith('S'):  # –°—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–µ
                        result["target"] = word
            except:
                pass
        
        return result

# ============================================
# –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° IRIS AI
# ============================================

class IRISVoiceAI:
    """
    –°—É–ø–µ—Ä-–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç —Å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ–º –∏ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏
    """
    
    # Wake word –≤–∞—Ä–∏–∞—Ü–∏–∏ —Å –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–º —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ–º
    WAKE_WORD_VARIANTS = [
        '–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏', '–∏—Ä–∏—Å–∫–∞', '–∏—Ä–∏—Å—Å', '–∏—Ä–∏—Å–∞',
        '–∞–π—Ä–∏—Å', '–∞—Ä–∏—Å', '–∏—Ä–∏—à', '–∏—Ä–∏—Å—å', '—Ä–∏—Å', '—ç—Ä–∏—Å',
        '–∏—Ä–∏—Å—é', '–∏—Ä–∏—Å—è', '–∏—Ä–∏—Å—É', '–∏—Ä–∏—Å–µ', '–∏—Ä–∏—à–∞'
    ]
    
    # –ö–æ–º–∞–Ω–¥—ã —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–º –ø–æ–Ω–∏–º–∞–Ω–∏–µ–º
    SMART_COMMANDS = {
        '–ø–æ–≥–æ–¥–∞': {
            'actions': ['–ø–æ–≥–æ–¥–∞', '–ø—Ä–æ–≥–Ω–æ–∑', '—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞', '–¥–æ–∂–¥—å', '—Å–æ–ª–Ω—Ü–µ'],
            'context': 'weather',
            'requires_location': True
        },
        '–º—É–∑—ã–∫–∞': {
            'actions': ['–º—É–∑—ã–∫–∞', '–ø–µ—Å–Ω—è', '—Ç—Ä–µ–∫', '–∞–ª—å–±–æ–º', '–ø–ª–µ–π–ª–∏—Å—Ç'],
            'context': 'music',
            'requires_query': True
        },
        '–Ω–æ–≤–æ—Å—Ç–∏': {
            'actions': ['–Ω–æ–≤–æ—Å—Ç–∏', '—Å–æ–±—ã—Ç–∏—è', '–ø—Ä–æ–∏—Å—à–µ—Å—Ç–≤–∏—è', '—Å–≤–æ–¥–∫–∞'],
            'context': 'news',
            'category': 'general'
        },
        '—É–º–Ω—ã–π –¥–æ–º': {
            'actions': ['–≤–∫–ª—é—á–∏', '–≤—ã–∫–ª—é—á–∏', '—Å–≤–µ—Ç', '—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞', '—Ä–æ–∑–µ—Ç–∫–∞'],
            'context': 'smart_home',
            'devices': ['—Å–≤–µ—Ç', '–ª–∞–º–ø–∞', '—Ç–µ–ª–µ–≤–∏–∑–æ—Ä', '–∫–æ–Ω–¥–∏—Ü–∏–æ–Ω–µ—Ä']
        }
    }
    
    def __init__(self, 
                 config_path: Optional[str] = None,
                 ai_mode: str = "adaptive",
                 neural_config: Optional[NeuralConfig] = None,
                 enable_self_learning: bool = True,
                 enable_emotion_recognition: bool = True,
                 enable_context_awareness: bool = True):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
        
        Args:
            config_path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            ai_mode: –†–µ–∂–∏–º –ò–ò (adaptive, neural, contextual, emotional, multimodal, autonomous)
            neural_config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π
            enable_self_learning: –í–∫–ª—é—á–∏—Ç—å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ
            enable_emotion_recognition: –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —ç–º–æ—Ü–∏–π
            enable_context_awareness: –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω–Ω–æ—Å—Ç—å
        """
        
        print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        print("‚ïë         üß† –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø IRIS AI –ú–û–ó–ì–ê                ‚ïë")
        print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
        
        # –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        self.ai_mode = ai_mode
        self.enable_self_learning = enable_self_learning
        self.enable_emotion_recognition = enable_emotion_recognition
        self.enable_context_awareness = enable_context_awareness
        
        # –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        self.neural_config = neural_config or NeuralConfig()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self._init_paths()
        self._init_components()
        self._init_neural_networks()
        self._init_ai_modules()
        
        # –°–æ—Å—Ç–æ—è–Ω–∏—è –ò–ò
        self.emotion_state = EmotionState()
        self.user_profile = UserProfile()
        self.ai_context = AIContext()
        self.learning_data = LearningData()
        self.performance_metrics = PerformanceMetrics()
        
        # –°–∏—Å—Ç–µ–º–∞ –æ—á–µ—Ä–µ–¥–µ–π –∏ –ø–æ—Ç–æ–∫–æ–≤
        self.command_queue = queue.PriorityQueue()
        self.audio_queue = queue.Queue()
        self.event_queue = asyncio.Queue()
        
        # –ü–æ—Ç–æ–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏
        self.threads = {}
        self.is_running = False
        self.is_learning = False
        
        # –ö–æ–ª–ª–±—ç–∫–∏ –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        self.callbacks = {
            'command': [],
            'wake': [],
            'error': [],
            'emotion_change': [],
            'context_change': [],
            'learning_update': [],
            'intent_detected': []
        }
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        if config_path and os.path.exists(config_path):
            self._load_config(config_path)
        
        # –í—ã–≤–æ–¥ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏—Å—Ç–µ–º–µ
        self._print_system_info()
        
        print("‚úÖ IRIS AI –ú–æ–∑–≥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
        print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    def _init_paths(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Ç–µ–π –¥–ª—è –¥–∞–Ω–Ω—ã—Ö –ò–ò"""
        self.base_dir = Path.home() / ".iris_ai"
        self.base_dir.mkdir(exist_ok=True)
        
        self.paths = {
            'models': self.base_dir / "models",
            'profiles': self.base_dir / "profiles",
            'learning': self.base_dir / "learning",
            'audio': self.base_dir / "audio_samples",
            'logs': self.base_dir / "logs",
            'config': self.base_dir / "config"
        }
        
        for path in self.paths.values():
            path.mkdir(exist_ok=True)
    
    def _init_components(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
        print("[IRIS AI] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤...")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
        self.speech_engines = {}
        
        if VOSK_AVAILABLE:
            self._init_vosk()
        
        if SR_AVAILABLE:
            self._init_speech_recognition()
        
        if YANDEX_AVAILABLE:
            self._init_yandex_speechkit()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ
        self._init_audio_system()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è NLP
        if NLP_AVAILABLE:
            self.intent_recognizer = IntentRecognizer()
            print("[IRIS AI] ‚úÖ NLP –º–æ–¥—É–ª—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        
        print("[IRIS AI] ‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
    
    def _init_neural_networks(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã—Ö –º–æ–¥–µ–ª–µ–π"""
        print("[IRIS AI] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã—Ö –º–æ–¥—É–ª–µ–π...")
        
        self.neural_models = {}
        
        if ML_LIBS.get('PYTORCH', False):
            try:
                # –ì–æ–ª–æ—Å–æ–≤–æ–π —ç–Ω–∫–æ–¥–µ—Ä
                self.neural_models['voice_encoder'] = VoiceEncoder()
                
                # –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä —ç–º–æ—Ü–∏–π
                self.neural_models['emotion_classifier'] = EmotionClassifier()
                
                # –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω—ã—Ö –≤–µ—Å–æ–≤, –µ—Å–ª–∏ –µ—Å—Ç—å
                self._load_neural_weights()
                
                print("[IRIS AI] ‚úÖ –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–µ –º–æ–¥–µ–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã (PyTorch)")
            except Exception as e:
                print(f"[IRIS AI] ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π: {e}")
        
        if ML_LIBS.get('SKLEARN', False):
            try:
                # –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –¥–ª—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
                self.neural_models['voice_cluster'] = KMeans(n_clusters=5)
                self.neural_models['feature_scaler'] = StandardScaler()
                print("[IRIS AI] ‚úÖ ML –º–æ–¥–µ–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã (Scikit-learn)")
            except Exception as e:
                print(f"[IRIS AI] ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ML: {e}")
    
    def _init_ai_modules(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ò–ò-–º–æ–¥—É–ª–µ–π"""
        print("[IRIS AI] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ò–ò-–º–æ–¥—É–ª–µ–π...")
        
        # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—å wake word
        self.adaptive_wake_detector = AdaptiveWakeDetector()
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä
        self.context_processor = ContextProcessor()
        
        # –ú–æ–¥—É–ª—å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è
        if self.enable_self_learning:
            self.learning_module = SelfLearningModule(self.base_dir)
        
        # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä
        if self.enable_emotion_recognition and AUDIO_ML_AVAILABLE:
            self.emotion_analyzer = EmotionAnalyzer()
        
        print("[IRIS AI] ‚úÖ –ò–ò-–º–æ–¥—É–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
    
    def _init_vosk(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Vosk —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª—å—é"""
        model_paths = [
            "models/vosk-model-ru-0.22",
            self.base_dir / "models/vosk-model-ru-0.22",
            Path.home() / ".vosk/vosk-model-ru-0.22",
            "/usr/share/vosk/vosk-model-ru-0.22"
        ]
        
        for path in model_paths:
            if os.path.exists(path):
                try:
                    self.vosk_model = Model(str(path))
                    self.vosk_recognizer = KaldiRecognizer(self.vosk_model, 16000)
                    self.vosk_recognizer.SetWords(True)
                    self.speech_engines['vosk'] = self.vosk_recognizer
                    print(f"[IRIS AI] ‚úÖ Vosk –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {path}")
                    return
                except Exception as e:
                    print(f"[IRIS AI] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Vosk –º–æ–¥–µ–ª–∏: {e}")
        
        print("[IRIS AI] ‚ö†Ô∏è –ú–æ–¥–µ–ª—å Vosk –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    
    def _init_speech_recognition(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SpeechRecognition —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
        try:
            self.sr_recognizer = sr.Recognizer()
            
            # –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            self.sr_recognizer.dynamic_energy_threshold = True
            self.sr_recognizer.energy_threshold = 3000
            self.sr_recognizer.pause_threshold = 0.8
            self.sr_recognizer.phrase_threshold = 0.3
            self.sr_recognizer.non_speaking_duration = 0.5
            
            self.speech_engines['google'] = self.sr_recognizer
            print("[IRIS AI] ‚úÖ SpeechRecognition –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ SpeechRecognition: {e}")
    
    def _init_yandex_speechkit(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ø–Ω–¥–µ–∫—Å SpeechKit"""
        # API –∫–ª—é—á –º–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
        self.yandex_api_key = os.getenv('YANDEX_SPEECHKIT_API_KEY', '')
        
        if self.yandex_api_key:
            self.speech_engines['yandex'] = True
            print("[IRIS AI] ‚úÖ –Ø–Ω–¥–µ–∫—Å SpeechKit –¥–æ—Å—Ç—É–ø–µ–Ω")
        else:
            print("[IRIS AI] ‚ö†Ô∏è –Ø–Ω–¥–µ–∫—Å SpeechKit API –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω")
    
    def _init_audio_system(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–π –∞—É–¥–∏–æ—Å–∏—Å—Ç–µ–º—ã"""
        print("[IRIS AI] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ—Å–∏—Å—Ç–µ–º—ã...")
        
        self.audio_processors = {}
        
        if PYAUDIO_AVAILABLE:
            try:
                self.pyaudio_instance = pyaudio.PyAudio()
                
                # –ü–æ–∏—Å–∫ –ª—É—á—à–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                self.audio_device = self._select_best_audio_device()
                
                # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ—Ç–æ–∫–∞
                self.stream_config = {
                    'format': pyaudio.paInt16,
                    'channels': 1,
                    'rate': 16000,
                    'frames_per_buffer': 2048,
                    'input': True,
                    'output': False,
                    'input_device_index': self.audio_device['index']
                }
                
                print(f"[IRIS AI] ‚úÖ –ê—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {self.audio_device.get('name', 'unknown')}")
                
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ PyAudio: {e}")
        
        if AUDIO_ML_AVAILABLE:
            try:
                # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ–æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å librosa
                self.audio_processors['enhancer'] = AudioEnhancer()
                print("[IRIS AI] ‚úÖ –ê—É–¥–∏–æ–æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –∞—É–¥–∏–æ–æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
    
    def _select_best_audio_device(self) -> Dict:
        """–í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ –∞—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫"""
        if not PYAUDIO_AVAILABLE:
            return {}
        
        devices = []
        
        for i in range(self.pyaudio_instance.get_device_count()):
            info = self.pyaudio_instance.get_device_info_by_index(i)
            
            if info.get('maxInputChannels', 0) > 0:
                # –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                score = 0
                
                # –í—ã—Å–æ–∫–∞—è —á–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
                score += info.get('defaultSampleRate', 0) / 44100
                
                # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–Ω–∞–ª–æ–≤
                score += info.get('maxInputChannels', 0) / 2
                
                # –ù–∏–∑–∫–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                latency = info.get('defaultLowInputLatency', 0.1)
                score += 1.0 - min(latency, 0.5) * 2
                
                devices.append({
                    'index': i,
                    'info': info,
                    'score': score,
                    'name': info.get('name', f'Device {i}')
                })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –æ—Ü–µ–Ω–∫–µ
        devices.sort(key=lambda x: x['score'], reverse=True)
        
        return devices[0] if devices else {}
    
    def _load_neural_weights(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω—ã—Ö –≤–µ—Å–æ–≤ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π"""
        model_path = self.paths['models'] / "neural_weights.pth"
        
        if model_path.exists():
            try:
                checkpoint = torch.load(model_path, map_location='cpu')
                
                for model_name, model in self.neural_models.items():
                    if model_name in checkpoint:
                        model.load_state_dict(checkpoint[model_name])
                        print(f"[IRIS AI] –í–µ—Å–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –¥–ª—è {model_name}")
                
                print("[IRIS AI] ‚úÖ –í–µ—Å–∞ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π –∑–∞–≥—Ä—É–∂–µ–Ω—ã")
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–µ—Å–æ–≤: {e}")
    
    def _load_config(self, config_path: str):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–∞"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
                
            # –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫
            if 'user_profile' in config:
                for key, value in config['user_profile'].items():
                    if hasattr(self.user_profile, key):
                        setattr(self.user_profile, key, value)
            
            if 'neural_config' in config:
                for key, value in config['neural_config'].items():
                    if hasattr(self.neural_config, key):
                        setattr(self.neural_config, key, value)
            
            print(f"[IRIS AI] –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {config_path}")
            
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
    
    def _print_system_info(self):
        """–í—ã–≤–æ–¥ –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏—Å—Ç–µ–º–µ"""
        print("\n" + "="*70)
        print("üß† IRIS AI - –°–ò–°–¢–ï–ú–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø")
        print("="*70)
        
        print(f"–†–µ–∂–∏–º –ò–ò: {self.ai_mode}")
        print(f"–°–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ: {'‚úÖ –í–ö–õ' if self.enable_self_learning else '‚ùå –í–´–ö–õ'}")
        print(f"–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —ç–º–æ—Ü–∏–π: {'‚úÖ –í–ö–õ' if self.enable_emotion_recognition else '‚ùå –í–´–ö–õ'}")
        print(f"–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω–Ω–æ—Å—Ç—å: {'‚úÖ –í–ö–õ' if self.enable_context_awareness else '‚ùå –í–´–ö–õ'}")
        
        print("\nüìä –î–û–°–¢–£–ü–ù–´–ï –ú–û–î–£–õ–ò:")
        print(f"  ‚Ä¢ Vosk: {'‚úÖ' if 'vosk' in self.speech_engines else '‚ùå'}")
        print(f"  ‚Ä¢ Google Speech: {'‚úÖ' if 'google' in self.speech_engines else '‚ùå'}")
        print(f"  ‚Ä¢ –Ø–Ω–¥–µ–∫—Å SpeechKit: {'‚úÖ' if 'yandex' in self.speech_engines else '‚ùå'}")
        print(f"  ‚Ä¢ PyTorch: {'‚úÖ' if ML_LIBS.get('PYTORCH') else '‚ùå'}")
        print(f"  ‚Ä¢ TensorFlow: {'‚úÖ' if ML_LIBS.get('TENSORFLOW') else '‚ùå'}")
        print(f"  ‚Ä¢ NLP: {'‚úÖ' if NLP_AVAILABLE else '‚ùå'}")
        print(f"  ‚Ä¢ –ê—É–¥–∏–æ–æ–±—Ä–∞–±–æ—Ç–∫–∞: {'‚úÖ' if AUDIO_ML_AVAILABLE else '‚ùå'}")
        
        print(f"\nüíæ –•–†–ê–ù–ò–õ–ò–©–ï: {self.base_dir}")
        print("="*70)
    
    # ============================================
    # –û–°–ù–û–í–ù–´–ï –ú–ï–¢–û–î–´ –û–ë–†–ê–ë–û–¢–ö–ò
    # ============================================
    
    def start(self):
        """–ó–∞–ø—É—Å–∫ –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞"""
        if self.is_running:
            print("[IRIS AI] –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω")
            return
        
        print("üöÄ –ó–∞–ø—É—Å–∫ IRIS AI...")
        self.is_running = True
        
        # –ó–∞–ø—É—Å–∫ –ø–æ—Ç–æ–∫–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∫–∏
        threads_to_start = [
            ('audio_capture', self._audio_capture_loop),
            ('speech_processing', self._speech_processing_loop),
            ('ai_processing', self._ai_processing_loop),
            ('command_handler', self._command_handling_loop),
            ('learning', self._learning_loop)
        ]
        
        for name, target in threads_to_start:
            thread = threading.Thread(target=target, daemon=True, name=f"iris_{name}")
            thread.start()
            self.threads[name] = thread
        
        # –ó–∞–ø—É—Å–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á
        asyncio.run(self._async_tasks_loop())
        
        print("‚úÖ IRIS AI –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç")
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞"""
        if not self.is_running:
            return
        
        print("[IRIS AI] –û—Å—Ç–∞–Ω–æ–≤–∫–∞...")
        self.is_running = False
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        self._save_state()
        
        # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ—Ç–æ–∫–æ–≤
        for thread in self.threads.values():
            if thread.is_alive():
                thread.join(timeout=2.0)
        
        # –ó–∞–∫—Ä—ã—Ç–∏–µ –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫–∞
        if hasattr(self, 'audio_stream') and self.audio_stream:
            self.audio_stream.stop_stream()
            self.audio_stream.close()
        
        print("‚úÖ IRIS AI –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    def _audio_capture_loop(self):
        """–¶–∏–∫–ª –∑–∞—Ö–≤–∞—Ç–∞ –∞—É–¥–∏–æ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π"""
        print("[IRIS AI] –ó–∞–ø—É—Å–∫ –∑–∞—Ö–≤–∞—Ç–∞ –∞—É–¥–∏–æ...")
        
        try:
            self.audio_stream = self.pyaudio_instance.open(**self.stream_config)
            self.audio_stream.start_stream()
            
            audio_buffer = []
            buffer_duration = 0.5  # 500 –º—Å –±—É—Ñ–µ—Ä
            chunk_size = self.stream_config['frames_per_buffer']
            
            while self.is_running:
                try:
                    # –ß—Ç–µ–Ω–∏–µ –∞—É–¥–∏–æ–¥–∞–Ω–Ω—ã—Ö
                    data = self.audio_stream.read(chunk_size, exception_on_overflow=False)
                    audio_buffer.append(data)
                    
                    # –ö–æ–≥–¥–∞ –Ω–∞–∫–æ–ø–∏–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö
                    if len(audio_buffer) >= (16000 * buffer_duration) / chunk_size:
                        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –±—É—Ñ–µ—Ä
                        audio_data = b''.join(audio_buffer)
                        
                        # –£–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞ –∑–≤—É–∫–∞
                        if 'enhancer' in self.audio_processors:
                            enhanced_audio = self.audio_processors['enhancer'].process(audio_data)
                            audio_data = enhanced_audio
                        
                        # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –æ—á–µ—Ä–µ–¥—å –æ–±—Ä–∞–±–æ—Ç–∫–∏
                        self.audio_queue.put({
                            'data': audio_data,
                            'timestamp': time.time(),
                            'sample_rate': 16000
                        })
                        
                        # –û—á–∏—Å—Ç–∫–∞ –±—É—Ñ–µ—Ä–∞
                        audio_buffer = []
                        
                except Exception as e:
                    print(f"[IRIS AI] –û—à–∏–±–∫–∞ –∑–∞—Ö–≤–∞—Ç–∞ –∞—É–¥–∏–æ: {e}")
                    time.sleep(0.1)
                    
        except Exception as e:
            print(f"[IRIS AI] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∞—É–¥–∏–æ: {e}")
    
    def _speech_processing_loop(self):
        """–¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ—á–∏ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –¥–≤–∏–∂–∫–∞–º–∏"""
        print("[IRIS AI] –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ—á–∏...")
        
        while self.is_running:
            try:
                # –ü–æ–ª—É—á–∞–µ–º –∞—É–¥–∏–æ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                audio_packet = self.audio_queue.get(timeout=0.5)
                audio_data = audio_packet['data']
                timestamp = audio_packet['timestamp']
                
                # –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–∞–∑–Ω—ã–º–∏ –¥–≤–∏–∂–∫–∞–º–∏
                recognition_results = []
                
                # Vosk —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ
                if 'vosk' in self.speech_engines:
                    vosk_result = self._recognize_with_vosk(audio_data)
                    if vosk_result:
                        vosk_result['engine'] = 'vosk'
                        recognition_results.append(vosk_result)
                
                # Google —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ
                if 'google' in self.speech_engines:
                    google_result = self._recognize_with_google(audio_data)
                    if google_result:
                        google_result['engine'] = 'google'
                        recognition_results.append(google_result)
                
                # –Ø–Ω–¥–µ–∫—Å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ
                if 'yandex' in self.speech_engines:
                    yandex_result = self._recognize_with_yandex(audio_data)
                    if yandex_result:
                        yandex_result['engine'] = 'yandex'
                        recognition_results.append(yandex_result)
                
                # –í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                if recognition_results:
                    best_result = self._select_best_recognition(recognition_results)
                    
                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ò–ò
                    self._process_with_ai(best_result)
                    
            except queue.Empty:
                continue
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ—á–∏: {e}")
    
    def _ai_processing_loop(self):
        """–¶–∏–∫–ª –ò–ò-–æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å –Ω–µ–π—Ä–æ—Å–µ—Ç—è–º–∏"""
        print("[IRIS AI] –ó–∞–ø—É—Å–∫ –ò–ò-–æ–±—Ä–∞–±–æ—Ç–∫–∏...")
        
        while self.is_running:
            try:
                # –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
                # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –æ—á–µ—Ä–µ–¥—å —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
                time.sleep(0.1)
                
                # –ê–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ
                if self.enable_emotion_recognition:
                    self._update_emotion_state()
                
                # –ê–¥–∞–ø—Ç–∞—Ü–∏—è –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                if self.enable_self_learning:
                    self._adapt_to_user()
                
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –ò–ò-–æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
    
    def _command_handling_loop(self):
        """–¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º"""
        print("[IRIS AI] –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥...")
        
        while self.is_running:
            try:
                # –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–∞–Ω–¥—É –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                priority, timestamp, command_data = self.command_queue.get(timeout=0.5)
                
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã —Å —É—á–µ—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
                processed_command = self._process_command_with_context(command_data)
                
                # –í—ã–∑–æ–≤ –∫–æ–ª–ª–±—ç–∫–æ–≤
                self._trigger_callbacks('command', processed_command)
                
                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
                self._update_context(processed_command)
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥: {e}")
    
    def _learning_loop(self):
        """–¶–∏–∫–ª —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è"""
        if not self.enable_self_learning:
            return
        
        print("[IRIS AI] –ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è...")
        
        learning_interval = 300  # 5 –º–∏–Ω—É—Ç
        
        while self.is_running:
            try:
                time.sleep(learning_interval)
                
                # –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
                training_data = self._collect_training_data()
                
                # –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π
                if training_data:
                    self._train_models(training_data)
                
                # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –æ–±—É—á–µ–Ω–∏—è
                self._save_learning_progress()
                
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è: {e}")
    
    async def _async_tasks_loop(self):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Ü–∏–∫–ª –¥–ª—è –∑–∞–¥–∞—á, —Ç—Ä–µ–±—É—é—â–∏—Ö asyncio"""
        print("[IRIS AI] –ó–∞–ø—É—Å–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á...")
        
        tasks = [
            self._async_event_processor(),
            self._async_network_monitor(),
            self._async_performance_monitor()
        ]
        
        await asyncio.gather(*tasks)
    
    # ============================================
    # –ú–ï–¢–û–î–´ –†–ê–°–ü–û–ó–ù–ê–í–ê–ù–ò–Ø –†–ï–ß–ò
    # ============================================
    
    def _recognize_with_vosk(self, audio_data: bytes) -> Optional[Dict]:
        """–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Vosk"""
        try:
            if self.vosk_recognizer.AcceptWaveform(audio_data):
                result = json.loads(self.vosk_recognizer.Result())
                text = result.get('text', '').strip()
                
                if text:
                    confidence = result.get('confidence', 0.0)
                    
                    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
                    words = result.get('result', [])
                    word_timings = [(w.get('word'), w.get('start'), w.get('end')) for w in words]
                    
                    return {
                        'text': text,
                        'confidence': confidence,
                        'language': 'ru',
                        'timings': word_timings,
                        'raw_result': result
                    }
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ Vosk: {e}")
        
        return None
    
    def _recognize_with_google(self, audio_data: bytes) -> Optional[Dict]:
        """–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Google Speech"""
        try:
            # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç SpeechRecognition
            audio = sr.AudioData(audio_data, 16000, 2)
            
            # –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ
            text = self.sr_recognizer.recognize_google(audio, language="ru-RU")
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            alternatives = []
            try:
                raw_result = self.sr_recognizer.recognize_google(audio, language="ru-RU", show_all=True)
                if isinstance(raw_result, dict) and 'alternative' in raw_result:
                    alternatives = [alt.get('transcript', '') for alt in raw_result['alternative'][1:]]
            except:
                pass
            
            return {
                'text': text,
                'confidence': 0.85,  # Google –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç confidence –¥–ª—è —Ä—É—Å—Å–∫–æ–≥–æ
                'language': 'ru',
                'alternatives': alternatives
            }
            
        except sr.UnknownValueError:
            return None
        except sr.RequestError as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ Google API: {e}")
            return None
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ Google —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: {e}")
            return None
    
    def _recognize_with_yandex(self, audio_data: bytes) -> Optional[Dict]:
        """–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é –Ø–Ω–¥–µ–∫—Å SpeechKit"""
        if not self.yandex_api_key:
            return None
        
        try:
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
            url = "https://stt.api.cloud.yandex.net/speech/v1/stt:recognize"
            
            headers = {
                "Authorization": f"Api-Key {self.yandex_api_key}",
            }
            
            params = {
                "lang": "ru-RU",
                "sampleRateHertz": "16000",
                "format": "lpcm",
                "profanityFilter": "false"
            }
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
            response = requests.post(url, headers=headers, params=params, data=audio_data)
            
            if response.status_code == 200:
                result = response.json()
                text = result.get('result', '')
                
                if text:
                    return {
                        'text': text,
                        'confidence': 0.9,  # –Ø–Ω–¥–µ–∫—Å –æ–±—ã—á–Ω–æ –¥–∞–µ—Ç –≤—ã—Å–æ–∫—É—é —Ç–æ—á–Ω–æ—Å—Ç—å
                        'language': 'ru',
                        'service': 'yandex'
                    }
        
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ –Ø–Ω–¥–µ–∫—Å SpeechKit: {e}")
        
        return None
    
    def _select_best_recognition(self, results: List[Dict]) -> Dict:
        """–í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è"""
        if not results:
            return {}
        
        # –í–∑–≤–µ—à–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        scored_results = []
        
        for result in results:
            score = result.get('confidence', 0.0)
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã
            engine_weights = {
                'yandex': 1.1,  # –Ø–Ω–¥–µ–∫—Å –ª—É—á—à–µ –¥–ª—è —Ä—É—Å—Å–∫–æ–≥–æ
                'vosk': 1.0,
                'google': 0.9
            }
            
            engine = result.get('engine', '')
            if engine in engine_weights:
                score *= engine_weights[engine]
            
            # –ù–∞–∫–∞–∑–∞–Ω–∏–µ –∑–∞ –∫–æ—Ä–æ—Ç–∫–∏–µ —Ç–µ–∫—Å—Ç—ã
            text_length = len(result.get('text', ''))
            if text_length < 3:
                score *= 0.5
            
            scored_results.append((score, result))
        
        # –í—ã–±–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º score
        best_score, best_result = max(scored_results, key=lambda x: x[0])
        
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–±–æ—Ä–∞
        print(f"[IRIS AI] –í—ã–±—Ä–∞–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç {best_result.get('engine')} "
              f"(–æ—Ü–µ–Ω–∫–∞: {best_score:.2f}): {best_result.get('text', '')[:50]}...")
        
        return best_result
    
    # ============================================
    # –ò–ò-–û–ë–†–ê–ë–û–¢–ö–ê –ò –°–ê–ú–û–û–ë–£–ß–ï–ù–ò–ï
    # ============================================
    
    def _process_with_ai(self, recognition_result: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–º–æ—â—å—é –ò–ò"""
        if not recognition_result:
            return
        
        text = recognition_result.get('text', '')
        confidence = recognition_result.get('confidence', 0.0)
        
        # –ê–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π –≤ —Ç–µ–∫—Å—Ç–µ
        if self.enable_emotion_recognition:
            emotion_analysis = self._analyze_emotion_from_text(text)
            self._update_emotion_state(emotion_analysis)
        
        # –ê–Ω–∞–ª–∏–∑ –Ω–∞–º–µ—Ä–µ–Ω–∏–π
        intent_analysis = self._analyze_intent(text)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ wake word —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–º
        wake_detected, cleaned_text = self._adaptive_wake_detection(text, confidence)
        
        if wake_detected:
            print(f"üîî [IRIS AI] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω! (–∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º)")
            self._trigger_callbacks('wake', {})
            
            # –ê–∫—Ç–∏–≤–∞—Ü–∏—è —Ä–µ–∂–∏–º–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è
            self._activate_listening_mode()
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã –ø–æ—Å–ª–µ wake word
            if cleaned_text:
                self._process_command(cleaned_text, intent_analysis)
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ
        elif self._is_listening_active():
            self._process_command(text, intent_analysis)
        
        # –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
        if self.enable_self_learning:
            self._collect_learning_sample(text, recognition_result)
    
    def _analyze_emotion_from_text(self, text: str) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π –ø–æ —Ç–µ–∫—Å—Ç—É"""
        emotion_scores = {
            'neutral': 0.5,
            'happy': 0.0,
            'sad': 0.0,
            'angry': 0.0,
            'excited': 0.0
        }
        
        # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞
        emotion_words = {
            'happy': ['—Ö–æ—Ä–æ—à–æ', '–æ—Ç–ª–∏—á–Ω–æ', '–ø—Ä–µ–∫—Ä–∞—Å–Ω–æ', '—Ä–∞–¥', '—Å—á–∞—Å—Ç–ª–∏–≤', '—É—Ä–∞', '—Å—É–ø–µ—Ä'],
            'sad': ['–ø–ª–æ—Ö–æ', '–≥—Ä—É—Å—Ç–Ω–æ', '–ø–µ—á–∞–ª—å–Ω–æ', '—Ç–æ—Å–∫–ª–∏–≤–æ', '–∂–∞–ª—å'],
            'angry': ['–∑–ª–æ–π', '—Å–µ—Ä–¥–∏—Ç', '—Ä–∞–∑–æ–∑–ª–∏–ª—Å—è', '–±–µ—Å–∏—Ç', '—Ä–∞–∑–¥—Ä–∞–∂–µ–Ω'],
            'excited': ['–≤–æ–ª–Ω—É—é—Å—å', '–≤–∑–≤–æ–ª–Ω–æ–≤–∞–Ω', '–∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ', '–æ–∂–∏–¥–∞—é', '–Ω–µ —Ç–µ—Ä–ø–∏—Ç—Å—è']
        }
        
        text_lower = text.lower()
        
        for emotion, words in emotion_words.items():
            for word in words:
                if word in text_lower:
                    emotion_scores[emotion] += 0.2
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–æ–º–∏–Ω–∏—Ä—É—é—â–µ–π —ç–º–æ—Ü–∏–∏
        dominant_emotion = max(emotion_scores.items(), key=lambda x: x[1])
        
        return {
            'emotion': dominant_emotion[0],
            'confidence': dominant_emotion[1],
            'scores': emotion_scores
        }
    
    def _analyze_intent(self, text: str) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –Ω–∞–º–µ—Ä–µ–Ω–∏–π –≤ —Ç–µ–∫—Å—Ç–µ"""
        if hasattr(self, 'intent_recognizer'):
            return self.intent_recognizer.extract_intent(text)
        
        # –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
        text_lower = text.lower()
        intent = "unknown"
        
        for cmd_type, cmd_info in self.SMART_COMMANDS.items():
            for action in cmd_info['actions']:
                if action in text_lower:
                    intent = cmd_type
                    break
        
        return {
            'intent': intent,
            'confidence': 0.7 if intent != "unknown" else 0.0,
            'entities': []
        }
    
    def _adaptive_wake_detection(self, text: str, confidence: float) -> Tuple[bool, str]:
        """–ê–¥–∞–ø—Ç–∏–≤–Ω–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ wake word —Å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ–º"""
        if not text:
            return False, ""
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –¥–µ—Ç–µ–∫—Ç–æ—Ä
        if hasattr(self, 'adaptive_wake_detector'):
            return self.adaptive_wake_detector.detect(text, confidence, self.user_profile)
        
        # –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
        text_lower = text.lower()
        
        for variant in self.WAKE_WORD_VARIANTS:
            if variant in text_lower:
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –ø–æ—Å–ª–µ wake word
                start_idx = text_lower.find(variant)
                cleaned_text = text_lower[start_idx + len(variant):].strip()
                return True, cleaned_text
        
        return False, text_lower
    
    def _process_command(self, command: str, intent_analysis: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã —Å –ò–ò-–∞–Ω–∞–ª–∏–∑–æ–º"""
        if not command:
            return
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å —É—á–µ—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        contextual_command = self._apply_context_to_command(command, intent_analysis)
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –æ—á–µ—Ä–µ–¥—å –∫–æ–º–∞–Ω–¥
        priority = self._calculate_command_priority(command, intent_analysis)
        self.command_queue.put((priority, time.time(), {
            'command': command,
            'contextual': contextual_command,
            'intent': intent_analysis,
            'emotion': self.emotion_state.emotion,
            'timestamp': time.time()
        }))
        
        print(f"üí≠ [IRIS AI] –û–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –∫–æ–º–∞–Ω–¥–∞: {command}")
        print(f"   üéØ –ù–∞–º–µ—Ä–µ–Ω–∏–µ: {intent_analysis.get('intent', 'unknown')}")
        print(f"   üòä –≠–º–æ—Ü–∏—è: {self.emotion_state.emotion}")
    
    def _apply_context_to_command(self, command: str, intent: Dict) -> str:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∫ –∫–æ–º–∞–Ω–¥–µ"""
        if not self.enable_context_awareness:
            return command
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        context_info = self.context_processor.get_context_for_command(command, intent)
        
        enhanced_command = {
            'raw': command,
            'context': context_info,
            'user_profile': self.user_profile.user_id,
            'current_emotion': self.emotion_state.emotion,
            'domain': intent.get('intent', 'general')
        }
        
        return json.dumps(enhanced_command, ensure_ascii=False)
    
    def _calculate_command_priority(self, command: str, intent: Dict) -> int:
        """–†–∞—Å—á–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –∫–æ–º–∞–Ω–¥—ã"""
        priority = 1  # –°—Ä–µ–¥–Ω–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        # –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
        critical_words = ['—Å—Ç–æ–ø', '–æ—Å—Ç–∞–Ω–æ–≤–∏—Å—å', '–ø–æ–º–æ—â—å', '—Å–ø–∞—Å–∏', '—Ç—Ä–µ–≤–æ–≥–∞']
        if any(word in command.lower() for word in critical_words):
            priority = 0
        
        # –ù–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        info_words = ['—á—Ç–æ', '–∫–∞–∫', '–ø–æ—á–µ–º—É', '—Ä–∞—Å—Å–∫–∞–∂–∏', '–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è']
        if any(word in command.lower() for word in info_words):
            priority = 2
        
        # –£—á–µ—Ç —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        if self.emotion_state.emotion in ['angry', 'stressed']:
            priority = 0  # –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø—Ä–∏ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ã—Ö —ç–º–æ—Ü–∏—è—Ö
        
        return priority
    
    def _update_emotion_state(self, new_analysis: Optional[Dict] = None):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        if not self.enable_emotion_recognition:
            return
        
        if new_analysis:
            self.emotion_state.emotion = new_analysis.get('emotion', 'neutral')
            self.emotion_state.confidence = new_analysis.get('confidence', 0.0)
            self.emotion_state.timestamp = time.time()
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
            self.emotion_state.history.append({
                'emotion': self.emotion_state.emotion,
                'confidence': self.emotion_state.confidence,
                'timestamp': self.emotion_state.timestamp
            })
            
            # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏
            if len(self.emotion_state.history) > 100:
                self.emotion_state.history.pop(0)
            
            # –í—ã–∑–æ–≤ –∫–æ–ª–ª–±—ç–∫–æ–≤
            self._trigger_callbacks('emotion_change', asdict(self.emotion_state))
    
    def _adapt_to_user(self):
        """–ê–¥–∞–ø—Ç–∞—Ü–∏—è –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π"""
        if not self.enable_self_learning:
            return
        
        # –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π
        self.user_profile.interaction_count += 1
        
        # –†–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏
        base_adaptation = min(self.user_profile.interaction_count / 100, 1.0)
        
        # –£—á–µ—Ç —É—Å–ø–µ—à–Ω—ã—Ö —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–π
        success_rate = self._calculate_success_rate()
        adaptation = base_adaptation * success_rate
        
        self.user_profile.adaptation_level = adaptation
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è
        self._save_user_profile()
    
    def _collect_training_data(self) -> Dict:
        """–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
        samples = []
        
        # –°–±–æ—Ä –∞—É–¥–∏–æ –æ–±—Ä–∞–∑—Ü–æ–≤
        if hasattr(self, 'learning_data') and self.learning_data.audio_samples:
            samples.extend(self.learning_data.audio_samples[:10])  # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10
        
        # –°–±–æ—Ä —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –æ–±—Ä–∞–∑—Ü–æ–≤
        recent_history = self.get_recent_history(20)
        
        training_data = {
            'audio_samples': samples,
            'transcriptions': [h.get('text', '') for h in recent_history],
            'timestamps': [h.get('timestamp', 0) for h in recent_history],
            'success_rate': self._calculate_success_rate()
        }
        
        return training_data
    
    def _train_models(self, training_data: Dict):
        """–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π –Ω–∞ —Å–æ–±—Ä–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        if not training_data or not self.enable_self_learning:
            return
        
        print("[IRIS AI] –ó–∞–ø—É—Å–∫ –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–µ–π...")
        
        try:
            # –û–±—É—á–µ–Ω–∏–µ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ wake word –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞
            if hasattr(self, 'adaptive_wake_detector'):
                self.adaptive_wake_detector.train(training_data)
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã—Ö –º–æ–¥–µ–ª–µ–π
            if ML_LIBS.get('PYTORCH', False) and 'transcriptions' in training_data:
                self._train_neural_models(training_data['transcriptions'])
            
            print("[IRIS AI] ‚úÖ –ú–æ–¥–µ–ª–∏ –æ–±—É—á–µ–Ω—ã")
            
            # –í—ã–∑–æ–≤ –∫–æ–ª–ª–±—ç–∫–æ–≤
            self._trigger_callbacks('learning_update', {
                'timestamp': time.time(),
                'samples_processed': len(training_data.get('transcriptions', [])),
                'success_rate': training_data.get('success_rate', 0.0)
            })
            
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è: {e}")
    
    def _train_neural_models(self, texts: List[str]):
        """–û–±—É—á–µ–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã—Ö –º–æ–¥–µ–ª–µ–π"""
        if not texts or len(texts) < 5:
            return
        
        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è
        # –î–ª—è –ø—Ä–∏–º–µ—Ä–∞ –ø—Ä–æ—Å—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        try:
            if 'voice_encoder' in self.neural_models:
                model_path = self.paths['models'] / "voice_encoder_latest.pth"
                torch.save(self.neural_models['voice_encoder'].state_dict(), model_path)
            
            print(f"[IRIS AI] –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–µ –º–æ–¥–µ–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –Ω–∞ {len(texts)} –ø—Ä–∏–º–µ—Ä–∞—Ö")
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π: {e}")
    
    def _collect_learning_sample(self, text: str, recognition_result: Dict):
        """–°–±–æ—Ä –æ–±—Ä–∞–∑—Ü–∞ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
        sample = {
            'text': text,
            'recognition_result': recognition_result,
            'timestamp': time.time(),
            'emotion': self.emotion_state.emotion,
            'user_id': self.user_profile.user_id
        }
        
        self.learning_data.transcriptions.append(sample)
        
        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞
        if len(self.learning_data.transcriptions) > 1000:
            self.learning_data.transcriptions.pop(0)
    
    def _calculate_success_rate(self) -> float:
        """–†–∞—Å—á–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞ —É—Å–ø–µ—à–Ω—ã—Ö —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–π"""
        if not self.learning_data.transcriptions:
            return 0.0
        
        # –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞: —Å—á–∏—Ç–∞–µ–º —É—Å–ø–µ—à–Ω—ã–º–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Å –¥–æ–≤–µ—Ä–∏–µ–º > 0.7
        successful = sum(1 for t in self.learning_data.transcriptions 
                        if t.get('recognition_result', {}).get('confidence', 0) > 0.7)
        
        total = len(self.learning_data.transcriptions)
        
        return successful / total if total > 0 else 0.0
    
    # ============================================
    # –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ –ò –ò–ù–¢–ï–†–§–ï–ô–°
    # ============================================
    
    def add_callback(self, callback_type: str, callback: Callable):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–±—ç–∫–∞"""
        if callback_type in self.callbacks:
            self.callbacks[callback_type].append(callback)
            print(f"[IRIS AI] –î–æ–±–∞–≤–ª–µ–Ω –∫–æ–ª–ª–±—ç–∫ —Ç–∏–ø–∞: {callback_type}")
    
    def _trigger_callbacks(self, callback_type: str, data: Any):
        """–í—ã–∑–æ–≤ –∫–æ–ª–ª–±—ç–∫–æ–≤"""
        if callback_type in self.callbacks:
            for callback in self.callbacks[callback_type]:
                try:
                    callback(data)
                except Exception as e:
                    print(f"[IRIS AI] –û—à–∏–±–∫–∞ –≤ –∫–æ–ª–ª–±—ç–∫–µ {callback_type}: {e}")
    
    def _is_listening_active(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ä–µ–∂–∏–º–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è"""
        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ —Ç–∞–π–º–∞—É—Ç–∞
        return True
    
    def _activate_listening_mode(self, duration: float = 10.0):
        """–ê–∫—Ç–∏–≤–∞—Ü–∏—è —Ä–µ–∂–∏–º–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è"""
        self.listening_active_until = time.time() + duration
        print(f"[IRIS AI] –†–µ–∂–∏–º –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ {duration} —Å–µ–∫—É–Ω–¥")
    
    def _update_context(self, command_data: Dict):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã"""
        if not self.enable_context_awareness:
            return
        
        command = command_data.get('command', '') if isinstance(command_data, dict) else command_data
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –≤ –∏—Å—Ç–æ—Ä–∏—é
        self.ai_context.previous_commands.append(command)
        
        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏
        if len(self.ai_context.previous_commands) > 20:
            self.ai_context.previous_commands.pop(0)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ —Å–∫–æ—Ä–∞
        self.ai_context.context_score = self._calculate_context_score()
    
    def _calculate_context_score(self) -> float:
        """–†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–π —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏"""
        if not self.ai_context.previous_commands:
            return 0.0
        
        # –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞: –±–æ–ª—å—à–µ –∫–æ–º–∞–Ω–¥ = –≤—ã—à–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        return min(len(self.ai_context.previous_commands) / 20, 1.0)
    
    def get_system_status(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã"""
        return {
            'status': 'running' if self.is_running else 'stopped',
            'ai_mode': self.ai_mode,
            'user_profile': asdict(self.user_profile),
            'emotion_state': asdict(self.emotion_state),
            'performance': asdict(self.performance_metrics),
            'queue_sizes': {
                'audio': self.audio_queue.qsize(),
                'commands': self.command_queue.qsize()
            },
            'threads_alive': {name: thread.is_alive() for name, thread in self.threads.items()},
            'learning_enabled': self.enable_self_learning,
            'adaptation_level': self.user_profile.adaptation_level,
            'success_rate': self._calculate_success_rate()
        }
    
    def get_recent_history(self, count: int = 10) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∑–∞–ø–∏—Å–µ–π –∏—Å—Ç–æ—Ä–∏–∏"""
        return self.learning_data.transcriptions[-count:] if self.learning_data.transcriptions else []
    
    def save_state(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã"""
        self._save_state()
    
    def _save_state(self):
        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–µ—Ç–æ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        print("[IRIS AI] –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è...")
        
        try:
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è
            profile_path = self.paths['profiles'] / f"{self.user_profile.user_id}.json"
            with open(profile_path, 'w', encoding='utf-8') as f:
                json.dump(asdict(self.user_profile), f, indent=2, ensure_ascii=False)
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ–±—É—á–µ–Ω–∏—è
            learning_path = self.paths['learning'] / "learning_data.pkl"
            with open(learning_path, 'wb') as f:
                pickle.dump(self.learning_data, f)
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            config_path = self.paths['config'] / "ai_config.json"
            config = {
                'ai_mode': self.ai_mode,
                'neural_config': asdict(self.neural_config),
                'user_profile_id': self.user_profile.user_id,
                'last_save': time.time()
            }
            
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
            
            print("[IRIS AI] ‚úÖ –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
            
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
    
    def _save_user_profile(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            profile_path = self.paths['profiles'] / f"{self.user_profile.user_id}.json"
            with open(profile_path, 'w', encoding='utf-8') as f:
                json.dump(asdict(self.user_profile), f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è: {e}")
    
    def _save_learning_progress(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –æ–±—É—á–µ–Ω–∏—è"""
        if not self.enable_self_learning:
            return
        
        try:
            progress_path = self.paths['learning'] / "progress.json"
            progress = {
                'total_samples': len(self.learning_data.transcriptions),
                'last_training': time.time(),
                'success_rate': self._calculate_success_rate(),
                'adaptation_level': self.user_profile.adaptation_level
            }
            
            with open(progress_path, 'w', encoding='utf-8') as f:
                json.dump(progress, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            print(f"[IRIS AI] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞: {e}")
    
    async def _async_event_processor(self):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π"""
        while self.is_running:
            try:
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                await asyncio.sleep(0.1)
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π: {e}")
    
    async def _async_network_monitor(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–µ—Ç–µ–≤—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
        while self.is_running:
            try:
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å–æ–≤
                await asyncio.sleep(60)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
                
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–µ—Ç–∏: {e}")
    
    async def _async_performance_monitor(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        while self.is_running:
            try:
                # –°–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                self.performance_metrics.latency['audio'] = 0.05  # –ü—Ä–∏–º–µ—Ä
                self.performance_metrics.latency['processing'] = 0.1
                
                await asyncio.sleep(5)  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
                
            except Exception as e:
                print(f"[IRIS AI] –û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: {e}")

# ============================================
# –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ –ò–ò-–ú–û–î–£–õ–ï–ô
# ============================================

class AdaptiveWakeDetector:
    """–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –¥–µ—Ç–µ–∫—Ç–æ—Ä wake word —Å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ–º"""
    
    def __init__(self):
        self.wake_patterns = []
        self.user_specific_patterns = {}
        self.learning_rate = 0.1
        self.threshold = 0.7
        
    def detect(self, text: str, confidence: float, user_profile: UserProfile) -> Tuple[bool, str]:
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ wake word —Å –∞–¥–∞–ø—Ç–∞—Ü–∏–µ–π"""
        text_lower = text.lower()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        for pattern in self.wake_patterns:
            if pattern in text_lower:
                return True, text_lower.replace(pattern, "", 1).strip()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        user_id = user_profile.user_id
        if user_id in self.user_specific_patterns:
            for pattern in self.user_specific_patterns[user_id]:
                if pattern in text_lower:
                    return True, text_lower.replace(pattern, "", 1).strip()
        
        # Fuzzy matching –¥–ª—è –Ω–æ–≤—ã—Ö –≤–∞—Ä–∏–∞—Ü–∏–π
        wake_variants = ['–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏']
        for variant in wake_variants:
            if variant in text_lower:
                # –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –Ω–æ–≤–æ–º –ø–∞—Ç—Ç–µ—Ä–Ω–µ
                self._learn_pattern(text_lower, variant, user_profile)
                return True, text_lower.replace(variant, "", 1).strip()
        
        return False, text_lower
    
    def _learn_pattern(self, text: str, detected_variant: str, user_profile: UserProfile):
        """–û–±—É—á–µ–Ω–∏–µ –Ω–∞ –Ω–æ–≤–æ–º –ø–∞—Ç—Ç–µ—Ä–Ω–µ wake word"""
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤–æ–∫—Ä—É–≥ wake word
        idx = text.find(detected_variant)
        context = text[max(0, idx-5):min(len(text), idx+len(detected_variant)+5)]
        
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        pattern = {
            'text': context,
            'variant': detected_variant,
            'user_id': user_profile.user_id,
            'timestamp': time.time()
        }
        
        self.wake_patterns.append(context)
        
        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        if len(self.wake_patterns) > 50:
            self.wake_patterns.pop(0)
    
    def train(self, training_data: Dict):
        """–û–±—É—á–µ–Ω–∏–µ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –Ω–∞ –¥–∞–Ω–Ω—ã—Ö"""
        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è
        print("[AdaptiveWakeDetector] –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö...")

class ContextProcessor:
    """–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥"""
    
    def __init__(self):
        self.context_memory = {}
        self.conversation_history = []
        self.entity_tracker = {}
        
    def get_context_for_command(self, command: str, intent: Dict) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è –∫–æ–º–∞–Ω–¥—ã"""
        context = {
            'previous_commands': self.conversation_history[-3:],  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 3 –∫–æ–º–∞–Ω–¥—ã
            'time_of_day': self._get_time_context(),
            'detected_intent': intent.get('intent', 'unknown'),
            'entities': intent.get('entities', []),
            'context_score': self._calculate_relevance(command)
        }
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –≤ –∏—Å—Ç–æ—Ä–∏—é
        self.conversation_history.append({
            'command': command,
            'intent': intent,
            'timestamp': time.time()
        })
        
        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
        if len(self.conversation_history) > 100:
            self.conversation_history.pop(0)
        
        return context
    
    def _get_time_context(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞"""
        now = datetime.now()
        
        return {
            'hour': now.hour,
            'minute': now.minute,
            'day_of_week': now.weekday(),
            'is_working_hours': 9 <= now.hour < 18,
            'is_night': now.hour < 6 or now.hour >= 22
        }
    
    def _calculate_relevance(self, command: str) -> float:
        """–†–∞—Å—á–µ—Ç —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏ –∫–æ–º–∞–Ω–¥—ã —Ç–µ–∫—É—â–µ–º—É –∫–æ–Ω—Ç–µ–∫—Å—Ç—É"""
        # –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞
        if not self.conversation_history:
            return 0.0
        
        last_command = self.conversation_history[-1].get('command', '').lower()
        current_command = command.lower()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Å–≤—è–∑–∏
        common_words = set(last_command.split()) & set(current_command.split())
        
        return len(common_words) / max(len(set(last_command.split())), 1)

class SelfLearningModule:
    """–ú–æ–¥—É–ª—å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞"""
    
    def __init__(self, base_dir: Path):
        self.base_dir = base_dir
        self.learning_data = []
        self.model_versions = {}
        
    def add_sample(self, text: str, correct_transcription: str, confidence: float):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–∑—Ü–∞ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
        sample = {
            'input': text,
            'target': correct_transcription,
            'confidence': confidence,
            'timestamp': time.time()
        }
        
        self.learning_data.append(sample)
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö
        if len(self.learning_data) >= 100:
            self.train()
    
    def train(self):
        """–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π –Ω–∞ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        if len(self.learning_data) < 10:
            return
        
        print("[SelfLearningModule] –ó–∞–ø—É—Å–∫ –æ–±—É—á–µ–Ω–∏—è...")
        
        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è
        # –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–æ–æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
        
        # –ü–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è –æ—á–∏—â–∞–µ–º —á–∞—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
        self.learning_data = self.learning_data[-500:]  # –û—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 500
        
        print(f"[SelfLearningModule] –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –û–±—Ä–∞–∑—Ü–æ–≤: {len(self.learning_data)}")
    
    def save_progress(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –æ–±—É—á–µ–Ω–∏—è"""
        progress_path = self.base_dir / "learning_progress.pkl"
        
        try:
            with open(progress_path, 'wb') as f:
                pickle.dump({
                    'learning_data': self.learning_data,
                    'model_versions': self.model_versions,
                    'last_trained': time.time()
                }, f)
        except Exception as e:
            print(f"[SelfLearningModule] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")

class EmotionAnalyzer:
    """–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä —ç–º–æ—Ü–∏–π –ø–æ –≥–æ–ª–æ—Å—É"""
    
    def __init__(self):
        self.emotion_models = {}
        self.feature_extractor = None
        
    def analyze_audio(self, audio_data: np.ndarray, sample_rate: int) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π –ø–æ –∞—É–¥–∏–æ–¥–∞–Ω–Ω—ã–º"""
        try:
            # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Å librosa
            features = self._extract_audio_features(audio_data, sample_rate)
            
            # –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —ç–º–æ—Ü–∏–π
            emotion_probs = self._classify_emotion(features)
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–æ–º–∏–Ω–∏—Ä—É—é—â–µ–π —ç–º–æ—Ü–∏–∏
            dominant_emotion = max(emotion_probs.items(), key=lambda x: x[1])
            
            return {
                'emotion': dominant_emotion[0],
                'confidence': dominant_emotion[1],
                'probabilities': emotion_probs,
                'features': features.tolist() if isinstance(features, np.ndarray) else features
            }
            
        except Exception as e:
            print(f"[EmotionAnalyzer] –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {e}")
            return {'emotion': 'neutral', 'confidence': 0.0}
    
    def _extract_audio_features(self, audio: np.ndarray, sr: int) -> np.ndarray:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∞—É–¥–∏–æ-–ø—Ä–∏–∑–Ω–∞–∫–æ–≤"""
        features = []
        
        try:
            # MFCC (Mel-frequency cepstral coefficients)
            mfcc = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=13)
            features.append(mfcc.mean(axis=1))
            
            # Chroma features
            chroma = librosa.feature.chroma_stft(y=audio, sr=sr)
            features.append(chroma.mean(axis=1))
            
            # Spectral contrast
            contrast = librosa.feature.spectral_contrast(y=audio, sr=sr)
            features.append(contrast.mean(axis=1))
            
            # Zero crossing rate
            zcr = librosa.feature.zero_crossing_rate(y=audio)
            features.append([zcr.mean()])
            
            # RMS energy
            rms = librosa.feature.rms(y=audio)
            features.append([rms.mean()])
            
            # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
            combined = np.concatenate(features)
            
            return combined
            
        except Exception as e:
            print(f"[EmotionAnalyzer] –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: {e}")
            return np.zeros(50)  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω—É–ª–µ–≤—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ –ø—Ä–∏ –æ—à–∏–±–∫–µ
    
    def _classify_emotion(self, features: np.ndarray) -> Dict:
        """–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —ç–º–æ—Ü–∏–π –ø–æ –ø—Ä–∏–∑–Ω–∞–∫–∞–º"""
        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—ã–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
        return {
            'neutral': 0.3,
            'happy': 0.2,
            'sad': 0.15,
            'angry': 0.1,
            'excited': 0.1,
            'calm': 0.1,
            'stressed': 0.05
        }

class AudioEnhancer:
    """–£–ª—É—á—à–∏—Ç–µ–ª—å –∫–∞—á–µ—Å—Ç–≤–∞ –∞—É–¥–∏–æ"""
    
    def __init__(self):
        self.noise_profile = None
        self.enhancement_params = {
            'noise_reduction': 0.8,
            'gain': 1.2,
            'compression': 0.5
        }
    
    def process(self, audio_data: bytes) -> bytes:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ —É–ª—É—á—à–µ–Ω–∏–µ –∞—É–¥–∏–æ"""
        try:
            # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ bytes –≤ numpy array
            audio_array = np.frombuffer(audio_data, dtype=np.int16).astype(np.float32) / 32768.0
            
            # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —É–ª—É—á—à–µ–Ω–∏–π
            enhanced = self._apply_enhancements(audio_array)
            
            # –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ bytes
            enhanced_bytes = (enhanced * 32768.0).astype(np.int16).tobytes()
            
            return enhanced_bytes
            
        except Exception as e:
            print(f"[AudioEnhancer] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
            return audio_data  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
    
    def _apply_enhancements(self, audio: np.ndarray) -> np.ndarray:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —É–ª—É—á—à–µ–Ω–∏–π –∫ –∞—É–¥–∏–æ"""
        # –®—É–º–æ–ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ
        if self.noise_profile is not None:
            audio = self._reduce_noise(audio)
        
        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏
        audio = self._normalize_volume(audio)
        
        # –ö–æ–º–ø—Ä–µ—Å—Å–∏—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        audio = self._compress_dynamic_range(audio)
        
        return audio
    
    def _reduce_noise(self, audio: np.ndarray) -> np.ndarray:
        """–ü–æ–¥–∞–≤–ª–µ–Ω–∏–µ —à—É–º–∞"""
        # –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ—Ä–æ–≥–æ–≤–æ–≥–æ –ø–æ–¥–∞–≤–ª–µ–Ω–∏—è —à—É–º–∞
        threshold = np.std(audio) * self.enhancement_params['noise_reduction']
        audio[abs(audio) < threshold] = 0
        return audio
    
    def _normalize_volume(self, audio: np.ndarray) -> np.ndarray:
        """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏"""
        max_amp = np.max(np.abs(audio))
        if max_amp > 0:
            audio = audio / max_amp * self.enhancement_params['gain']
        return np.clip(audio, -1.0, 1.0)
    
    def _compress_dynamic_range(self, audio: np.ndarray) -> np.ndarray:
        """–ö–æ–º–ø—Ä–µ—Å—Å–∏—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞"""
        compression = self.enhancement_params['compression']
        return np.tanh(audio * compression) / np.tanh(compression)

# ============================================
# –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ò –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø
# ============================================

def create_iris_ai(config: Optional[Dict] = None) -> IRISVoiceAI:
    """
    –§–∞–±—Ä–∏—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è IRIS AI –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    
    Args:
        config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    
    Returns:
        IRISVoiceAI: –≠–∫–∑–µ–º–ø–ª—è—Ä –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    """
    config = config or {}
    
    ai = IRISVoiceAI(
        config_path=config.get('config_path'),
        ai_mode=config.get('ai_mode', 'adaptive'),
        neural_config=config.get('neural_config'),
        enable_self_learning=config.get('enable_self_learning', True),
        enable_emotion_recognition=config.get('enable_emotion_recognition', True),
        enable_context_awareness=config.get('enable_context_awareness', True)
    )
    
    return ai

async def demo_iris_ai():
    """–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π IRIS AI"""
    print("\n" + "="*70)
    print("üöÄ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø IRIS AI - –£–ú–ù–´–ô –ì–û–õ–û–°–û–í–û–ô –ê–°–°–ò–°–¢–ï–ù–¢")
    print("="*70)
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    config = {
        'ai_mode': 'adaptive',
        'enable_self_learning': True,
        'enable_emotion_recognition': True,
        'enable_context_awareness': True
    }
    
    iris = create_iris_ai(config)
    
    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–±—ç–∫–æ–≤
    def on_wake():
        print("\nüéØ Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω! IRIS –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
    
    def on_command(command):
        print(f"\nüí¨ –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞: {command}")
    
    def on_emotion_change(emotion_state):
        print(f"\nüòä –ò–∑–º–µ–Ω–∏–ª–∞—Å—å —ç–º–æ—Ü–∏—è: {emotion_state['emotion']} "
              f"(—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {emotion_state['confidence']:.1%})")
    
    def on_learning_update(update):
        print(f"\nüìö –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—É—á–µ–Ω–∏—è: –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {update['samples_processed']} –æ–±—Ä–∞–∑—Ü–æ–≤")
    
    iris.add_callback('wake', on_wake)
    iris.add_callback('command', on_command)
    iris.add_callback('emotion_change', on_emotion_change)
    iris.add_callback('learning_update', on_learning_update)
    
    # –ó–∞–ø—É—Å–∫ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    print("\n‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫–∞—é IRIS AI...")
    iris.start()
    
    print("\nüìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:")
    print("   ‚Ä¢ –°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å' –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏")
    print("   ‚Ä¢ –ó–∞—Ç–µ–º –ø—Ä–æ–∏–∑–Ω–µ—Å–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É (–Ω–∞–ø—Ä–∏–º–µ—Ä: '–ò—Ä–∏—Å, –∫–∞–∫–∞—è –ø–æ–≥–æ–¥–∞?')")
    print("   ‚Ä¢ –°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å, —Ä–∞—Å—Å–∫–∞–∂–∏ –∞–Ω–µ–∫–¥–æ—Ç'")
    print("   ‚Ä¢ –°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å, –≤–∫–ª—é—á–∏ –º—É–∑—ã–∫—É'")
    print("   ‚Ä¢ –°–∫–∞–∂–∏—Ç–µ '—Å—Ç–æ–ø' –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–µ–º–æ")
    
    print("\n‚è≥ –î–µ–º–æ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å 60 —Å–µ–∫—É–Ω–¥...")
    
    # –î–µ–º–æ –Ω–∞ 60 —Å–µ–∫—É–Ω–¥
    try:
        start_time = time.time()
        
        while time.time() - start_time < 60:
            await asyncio.sleep(1)
            
            # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π –≤—ã–≤–æ–¥ —Å—Ç–∞—Ç—É—Å–∞
            if int(time.time() - start_time) % 10 == 0:
                status = iris.get_system_status()
                print(f"\nüìä –°—Ç–∞—Ç—É—Å: {status['status']}, "
                      f"–∞–¥–∞–ø—Ç–∞—Ü–∏—è: {status['adaptation_level']:.1%}, "
                      f"—ç–º–æ—Ü–∏—è: {status['emotion_state']['emotion']}")
    
    except KeyboardInterrupt:
        print("\n\nüõë –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    
    finally:
        # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
        print("\n‚èπÔ∏è –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é IRIS AI...")
        iris.stop()
        
        # –§–∏–Ω–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        print("\n" + "="*70)
        print("üìà –§–ò–ù–ê–õ–¨–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê –î–ï–ú–û")
        print("="*70)
        
        final_stats = iris.get_system_status()
        for key, value in final_stats.items():
            if key not in ['user_profile', 'emotion_state', 'performance']:
                print(f"  {key}: {value}")
        
        print("\n‚úÖ –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
        print("="*70)

if __name__ == "__main__":
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
    print("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π IRIS AI...")
    
    deps = {
        "NumPy": NP_AVAILABLE,
        "PyAudio": PYAUDIO_AVAILABLE,
        "Vosk": VOSK_AVAILABLE,
        "SpeechRecognition": SR_AVAILABLE,
        "Requests": YANDEX_AVAILABLE,
        "PyTorch": ML_LIBS.get('PYTORCH', False),
        "Scikit-learn": ML_LIBS.get('SKLEARN', False),
        "Librosa": AUDIO_ML_AVAILABLE,
        "NLTK": NLP_AVAILABLE
    }
    
    print("\nüì¶ –£–°–¢–ê–ù–û–í–õ–ï–ù–ù–´–ï –ó–ê–í–ò–°–ò–ú–û–°–¢–ò:")
    for dep, available in deps.items():
        status = "‚úÖ" if available else "‚ùå"
        print(f"  {status} {dep}")
    
    # –ó–∞–ø—É—Å–∫ –¥–µ–º–æ
    asyncio.run(demo_iris_ai())
</file>

<file path="src/iris_smart_engine.py">
"""
üöÄ IRIS Smart Context & Priority Engine v2.1
–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏–∏ —Å–æ–±—ã—Ç–∏–π
"""

import time
import threading
from enum import Enum
from typing import Dict, Optional, List
from dataclasses import dataclass, field

class PlayerState(Enum):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä–æ–∫–∞"""
    PLAYING = 1        # –ê–∫—Ç–∏–≤–Ω–∞—è –∏–≥—Ä–∞
    SPECTATING = 2     # –ù–∞–±–ª—é–¥–µ–Ω–∏–µ (–º—ë—Ä—Ç–≤)
    FREEZETIME = 3     # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ä–∞—É–Ω–¥–∞
    UNKNOWN = 4        # –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ

class EventPriority(Enum):
    """–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã —Å–æ–±—ã—Ç–∏–π"""
    CRITICAL = 100     # –ó–¥–æ—Ä–æ–≤—å–µ, —Å–º–µ—Ä—Ç—å
    HIGH = 75          # –ö–∏–ª—ã 3+, –±–æ–º–±–∞
    MEDIUM = 50        # –û–±—ã—á–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
    LOW = 25           # –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
    IGNORE = 0         # –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å

class SmartContextAnalyzer:
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ–±—ã—Ç–∏—è"""
    
    def __init__(self):
        self.cache = {}
        self.cache_ttl = 2.0  # 2 —Å–µ–∫—É–Ω–¥—ã
    
    def analyze_ammo_situation(self, player, event_data: dict) -> Dict:
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–∏—Ç—É–∞—Ü–∏—é —Å –±–æ–µ–ø—Ä–∏–ø–∞—Å–∞–º–∏"""
        mag = event_data.get('ammo_magazine', 0)
        reserve = event_data.get('ammo_reserve', 0)
        total = mag + reserve
        weapon = event_data.get('weapon', 'unknown')
        
        return {
            'magazine': mag,
            'reserve': reserve,
            'total': total,
            'weapon': weapon,
            'status': 'critical' if total <= 3 else 'low' if total <= 10 else 'medium',
            'advice_urgent': total <= 3,
        }
    
    def analyze_health_situation(self, player, event_data: dict) -> Dict:
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–∏—Ç—É–∞—Ü–∏—é —Å –∑–¥–æ—Ä–æ–≤—å–µ–º"""
        hp = event_data.get('current_health', player.health)
        armor = player.armor if player else 0
        damage = event_data.get('damage', 0)
        
        status = 'critical' if hp <= 1 else 'very_low' if hp <= 15 else 'low' if hp <= 30 else 'medium'
        
        return {
            'health': hp,
            'armor': armor,
            'damage_taken': damage,
            'status': status,
            'is_critical': hp <= 15,
            'has_armor': armor > 0,
        }
    
    def analyze_kill_context(self, event_data: dict, player) -> Dict:
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∫–∏–ª–ª–∞"""
        kills_this = event_data.get('round_kills', 0)
        streak = event_data.get('kill_streak', 0)
        headshot = event_data.get('headshot', False)
        weapon = event_data.get('weapon', 'unknown')
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∫–∏–ª–ª–∞
        if kills_this >= 5:
            kill_type = 'ace'
        elif kills_this >= 4:
            kill_type = 'quadra'
        elif kills_this >= 3:
            kill_type = 'triple'
        elif kills_this >= 2:
            kill_type = 'double'
        else:
            kill_type = 'single'
        
        return {
            'round_kills': kills_this,
            'kill_streak': streak,
            'headshot': headshot,
            'weapon': weapon,
            'kill_type': kill_type,
            'is_special': kill_type in ['triple', 'quadra', 'ace'],
        }

class EventPriorityManager:
    """–£–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏ —Å–æ–±—ã—Ç–∏–π"""
    
    def __init__(self):
        self.event_weights = {
            'low_health': (EventPriority.CRITICAL, "–ó–¥–æ—Ä–æ–≤—å–µ –∫—Ä–∏—Ç–∏—á–Ω–æ–µ"),
            'low_ammo_warning': (EventPriority.HIGH, "–ü–∞—Ç—Ä–æ–Ω—ã –∫–æ–Ω—á–∞—é—Ç—Å—è"),
            'death': (EventPriority.CRITICAL, "–°–º–µ—Ä—Ç—å"),
            'ace': (EventPriority.HIGH, "–ê–¶–≠!"),
            'quadra_kill': (EventPriority.HIGH, "–ß–µ—Ç–≤–µ—Ä–∫–∞"),
            'triple_kill': (EventPriority.HIGH, "–¢—Ä–æ–π–∫–∞"),
            'double_kill': (EventPriority.MEDIUM, "–î–≤–æ–π–∫–∞"),
            'kill': (EventPriority.LOW, "–ö–∏–ª–ª"),
            'heavy_damage': (EventPriority.MEDIUM, "–£—Ä–æ–Ω"),
            'bomb_planted': (EventPriority.HIGH, "–ë–æ–º–±–∞!"),
            'bomb_defused': (EventPriority.HIGH, "–†–∞–∑–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∞"),
            'round_start': (EventPriority.LOW, "–†–∞—É–Ω–¥ –Ω–∞—á–∞–ª—Å—è"),
            'round_end': (EventPriority.MEDIUM, "–†–∞—É–Ω–¥ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è"),
        }
    
    def get_priority(self, event_type: str, event_data: dict = None) -> EventPriority:
        """–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Å–æ–±—ã—Ç–∏—è"""
        priority, _ = self.event_weights.get(event_type, (EventPriority.LOW, ""))
        
        # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø–æ–≤—ã—à–µ–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
        if event_type == 'low_health' and event_data:
            hp = event_data.get('current_health', 50)
            if hp <= 1:
                priority = EventPriority.CRITICAL  # –ú–∞–∫—Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
        
        return priority
    
    def should_interrupt(self, current_priority: EventPriority, new_priority: EventPriority) -> bool:
        """–î–æ–ª–∂–µ–Ω –ª–∏ –Ω–æ–≤—ã–π event –ø—Ä–µ—Ä–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π?"""
        # –ü—Ä–µ—Ä—ã–≤–∞–µ–º –µ—Å–ª–∏ —Ä–∞–∑–Ω–∏—Ü–∞ –≤ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–µ >= 50
        return (new_priority.value - current_priority.value) >= 50

class PlayerStateTracker:
    """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä–æ–∫–∞"""
    
    def __init__(self):
        self.current_state = PlayerState.UNKNOWN
        self.last_hp = 100
        self.last_state_change = time.time()
    
    def update(self, player_alive: bool, is_spectating: bool, round_phase: str = ""):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä–æ–∫–∞"""
        old_state = self.current_state
        
        if not player_alive:
            self.current_state = PlayerState.SPECTATING
        elif round_phase == 'freezetime':
            self.current_state = PlayerState.FREEZETIME
        elif is_spectating:
            self.current_state = PlayerState.SPECTATING
        else:
            self.current_state = PlayerState.PLAYING
        
        if old_state != self.current_state:
            self.last_state_change = time.time()
    
    def is_in_game(self) -> bool:
        """–ê–∫—Ç–∏–≤–Ω–æ –ª–∏ –≤ –∏–≥—Ä–µ?"""
        return self.current_state == PlayerState.PLAYING
    
    def is_spectating(self) -> bool:
        """–í —Ä–µ–∂–∏–º–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è?"""
        return self.current_state == PlayerState.SPECTATING

class EventInterruptHandler:
    """–£–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ–º —Ç–µ–∫—É—â–∏—Ö —Å–æ–±—ã—Ç–∏–π"""
    
    def __init__(self):
        self.current_event = None
        self.current_priority = EventPriority.LOW
        self.speaking_lock = threading.Lock()
    
    def can_interrupt(self, new_priority: EventPriority) -> bool:
        """–ú–æ–∂–µ—Ç –ª–∏ –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ –ø—Ä–µ—Ä–≤–∞—Ç—å —Ç–µ–∫—É—â–µ–µ?"""
        return (new_priority.value - self.current_priority.value) >= 50
    
    def set_current_event(self, event_type: str, priority: EventPriority):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ–±—ã—Ç–∏–µ"""
        with self.speaking_lock:
            self.current_event = event_type
            self.current_priority = priority
    
    def clear_current_event(self):
        """–û—á–∏—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ–±—ã—Ç–∏–µ"""
        with self.speaking_lock:
            self.current_event = None
            self.current_priority = EventPriority.LOW

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
</file>

<file path="src/prompt_builder.py">
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üí¨ SMART PROMPT BUILDER - –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–æ–º–ø—Ç—ã –¥–ª—è AI
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import logging
from typing import Optional, Dict

logger = logging.getLogger("IRIS")


class SmartPromptBuilder:
    """
    –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø—Ä–æ–º–ø—Ç–æ–≤ –¥–ª—è LLM
    
    –†–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã:
    ‚úÖ –ù–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã–µ –ø—Ä–æ–º–ø—Ç—ã - —á–µ—Ç–∫–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ EVENT‚ÜíSTATUS‚ÜíREACTION
    ‚úÖ AI –±—Ä–µ–¥ - —è–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ —á—Ç–æ –Ω—É–∂–Ω–æ
    ‚úÖ –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã - –ª–∏–º–∏—Ç –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–≤
    ‚úÖ –†—É—Å—Å–∫–∏–π —Ç–µ–∫—Å—Ç - –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –Ω–∞ —Ä—É—Å—Å–∫–æ–º
    """
    
    @staticmethod
    def build_kill_prompt(context: Dict, event_type: str) -> str:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–æ–º–ø—Ç –¥–ª—è —Å–æ–±—ã—Ç–∏—è —É–±–∏–π—Å—Ç–≤–∞
        
        Args:
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –∏–≥—Ä–æ–∫–∞ –∏–∑ SmartContextBuilder
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è (kill, headshot, double_kill –∏ —Ç.–¥.)
        
        Returns:
            –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–æ–º–ø—Ç–æ–º –¥–ª—è LLM
        """
        if not context:
            return None
        
        # ‚úÖ –§–æ—Ä–º–∏—Ä—É–µ–º –±–æ–Ω—É—Å –∑–∞ kill streak
        streak_bonus = ""
        if context['kill_streak'] >= 10:
            streak_bonus = f" MEGA Kill Streak {context['kill_streak']}!!! üî•üî•üî•"
        elif context['kill_streak'] >= 5:
            streak_bonus = f" Kill Streak {context['kill_streak']}! üî•"
        elif context['kill_streak'] >= 3:
            streak_bonus = f" Streak {context['kill_streak']}!"
        
        # ‚úÖ –û–ø–∏—Å–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏–π —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
        event_map = {
            'kill': f'–¢—ã —É–±–∏–ª –≤—Ä–∞–≥–∞{streak_bonus}',
            'headshot': f'–•–ï–î–®–û–¢! –í—Ä–∞–≥ –ø–∞–¥–∞–µ—Ç{streak_bonus}',
            'double_kill': f'–î–í–û–ô–ù–û–ô –ö–ò–õ–õ! –î–≤–∞ –≤—Ä–∞–≥–∞ —É–±–∏—Ç—ã{streak_bonus}',
            'triple_kill': f'–¢–†–û–ô–ù–û–ô –ö–ò–õ–õ! –¢–†–ò –≤—Ä–∞–≥–∞!{streak_bonus}',
            'quadra_kill': f'–ß–ï–¢–´–†–Å–•–ö–†–ê–¢–ù–´–ô –ö–ò–õ–õ! –ß–ï–¢–´–†–µ!{streak_bonus}',
            'ace': f'–ê–¶–≠!!! –í–°–ï 5 –í–†–ê–ì–û–í –ü–ê–í–®–ò–•!!!{streak_bonus}'
        }
        
        event_desc = event_map.get(event_type, '–ö–∏–ª–ª!')
        
        # ‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç
        prompt = f"""–ò–†–ò–° - AI –¥–ª—è CS2 —Å—Ç—Ä–∏–º–æ–≤. –†–µ–∞–≥–∏—Ä—É–π –ñ–ò–í–û –∏ –ö–û–†–û–¢–ö–û.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
–°–û–ë–´–¢–ò–ï: {event_desc}

–°–¢–ê–¢–£–° –ò–ì–†–û–ö–ê:
‚Ä¢ HP: {context['health']}/100
‚Ä¢ Armor: {context['armor']}
‚Ä¢ Weapon: {context['weapon']}
‚Ä¢ Kills this round: {context['round_kills']}
‚Ä¢ Kill Streak: {context['kill_streak']}
‚Ä¢ Money: ${context['money']}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

–¢–í–û–Ø –ó–ê–î–ê–ß–ê:
1. –†–µ–∞–≥–∏—Ä—É–π –∫–∞–∫ –±–æ–µ–≤–æ–π —Ç–æ–≤–∞—Ä–∏—â/–ø–æ–¥—Ä—É–≥–∞
2. –ò—Å–ø–æ–ª—å–∑—É–π –≥–µ–π–º–∏–Ω–≥ —Å–ª–µ–Ω–≥ (–∫–ª–∞—Ç—á, –º–∞–Ω–∏—è–∫, –≤ –æ–≥–Ω–µ, —ç–ø–∏—á–Ω–æ, –∫—Ä–∞—Å–∞–≤–∞)
3. –ú–ê–ö–°–ò–ú–£–ú 12 –°–õ–û–í - —ç—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ!
4. 1-2 —ç–º–æ–¥–∑–∏ –º–∞–∫—Å–∏–º—É–º
5. –ù–ò–ö–û–ì–î–ê –Ω–µ —É–ø–æ–º–∏–Ω–∞–π –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ - —Ç–æ–ª—å–∫–æ –æ–Ω/—Ç—ã

–ü–†–ò–ú–ï–†–´ –•–û–†–û–®–ò–• –†–ï–ê–ö–¶–ò–ô:
- "–û–¥–∏–Ω–æ—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª! –ú–∞–Ω–∏—è–∫ –ø–æ –∫–∏–ª–∫–∞–º!" (7 —Å–ª–æ–≤)
- "–ö–∏–ª–ª-—Å—Ç—Ä–∏–∫ –≥–æ—Ä–∏—Ç! –ü—Ä–æ–¥–æ–ª–∂–∞–π!" (5 —Å–ª–æ–≤)
- "–ú–∞–Ω—å—è–∫ –ø–æ —Ö—ç–¥—à–æ—Ç–∞–º! üéØ" (4 —Å–ª–æ–≤–∞)
- "–î–≤–æ–π–Ω–æ–π –∫–ª–∞—Ç—á! –ö—Ä–∞—Å–∞–≤–∞!" (4 —Å–ª–æ–≤–∞)
- "–í –æ–≥–Ω–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å! –î–µ—Ä–∂–∏!" (5 —Å–ª–æ–≤)

–¢–û–õ–¨–ö–û –¢–í–û–Ø –ñ–ò–í–ê–Ø –†–ï–ê–ö–¶–ò–Ø (–±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π, –º–∞–∫—Å–∏–º—É–º 12 —Å–ª–æ–≤):"""
        
        return prompt
    
    @staticmethod
    def build_damage_prompt(context: Dict) -> Optional[str]:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–æ–º–ø—Ç –¥–ª—è —Å–æ–±—ã—Ç–∏—è —É—Ä–æ–Ω–∞
        
        Args:
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –∏–≥—Ä–æ–∫–∞
        
        Returns:
            –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–æ–º–ø—Ç–æ–º –¥–ª—è LLM –∏–ª–∏ None –µ—Å–ª–∏ –•–ü –≤ –Ω–æ—Ä–º–µ
        """
        if not context:
            return None
        
        hp = context['health']
        
        # ‚úÖ –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç—å —É—Ä–æ–Ω–∞
        if hp <= 5:
            severity = "–ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –•–ü! –¢—ã –ø–æ—á—Ç–∏ –º–µ—Ä—Ç–≤! –û–¥–∏–Ω –≤—ã—Å—Ç—Ä–µ–ª –∏ –∫–æ–Ω–µ—Ü!"
            urgency = "–°–†–û–ß–ù–û –í –£–ö–†–´–¢–ò–ï!"
        elif hp <= 15:
            severity = "–û–ß–ï–ù–¨ –ù–ò–ó–ö–û–ï –•–ü! –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –æ–ø–∞—Å–Ω–æ!"
            urgency = "–ò—â–∏ –ø–æ–∑–∏—Ü–∏—é –∑–∞—â–∏—Ç—ã!"
        elif hp <= 30:
            severity = "–ù–∏–∑–∫–æ–µ –•–ü. –ù—É–∂–Ω–∞ –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å."
            urgency = "–ë–µ—Ä–µ–≥–∏ —Å–µ–±—è!"
        else:
            return None  # –ù–æ—Ä–º–∞–ª—å–Ω—ã–π —É—Ä–æ–Ω - –Ω–µ –æ–∑–≤—É—á–∏–≤–∞–µ–º
        
        prompt = f"""–ò–†–ò–° - AI –¥–ª—è CS2 —Å—Ç—Ä–∏–º–æ–≤. –†–ï–ê–ì–ò–†–£–ô –°–†–û–ß–ù–û –ò –ö–û–†–û–¢–ö–û!

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
–°–û–ë–´–¢–ò–ï: –°–∏–ª—å–Ω—ã–π —É—Ä–æ–Ω!

–°–¢–ê–¢–£–° –ò–ì–†–û–ö–ê:
‚Ä¢ HP: {hp}/100 (–ö–†–ò–¢–ò–ß–ù–û!)
‚Ä¢ Armor: {context['armor']}
‚Ä¢ Weapon: {context['weapon']}

–°–ò–¢–£–ê–¶–ò–Ø: {severity}
{urgency}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

–¢–í–û–Ø –ó–ê–î–ê–ß–ê:
1. –†–µ–∞–≥–∏—Ä—É–π –∫–∞–∫ –±–æ–µ–≤–æ–π —Ç–æ–≤–∞—Ä–∏—â - –°–†–û–ß–ù–û!
2. –°–æ–≤–µ—Ç—É–π —á—Ç–æ –¥–µ–ª–∞—Ç—å (—É–∫—Ä—ã—Ç–∏–µ, –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ, –æ–±–æ—Ä–æ–Ω–∞)
3. –ú–ê–ö–°–ò–ú–£–ú 10 –°–õ–û–í - –≤—Ä–µ–º—è –¥–æ—Ä–æ–≥–æ!
4. –ë–µ–∑ –ª–∏—à–Ω–∏—Ö —ç–º–æ–¥–∑–∏ - —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ
5. –ó–≤—É—á–∏ –∫–∞–∫ —Ä–µ–∞–ª—å–Ω—ã–π —Ç–∏–º–º–µ–π—Ç

–ü–†–ò–ú–ï–†–´:
- "–ö—Ä–∏—Ç–∏—á–Ω–æ–µ –•–ü! –£–∫—Ä—ã–≤–∞–π—Å—è —Å–∫–æ—Ä–µ–π!" (5 —Å–ª–æ–≤)
- "–ù–∞ –≤–æ–ª–æ—Å–∫–µ! –í —É–∫—Ä—ã—Ç–∏–µ!" (4 —Å–ª–æ–≤–∞)
- "–†–∞–Ω–µ–Ω! –ó–∞—â–∏—â–∞–π—Å—è! üö®" (3 —Å–ª–æ–≤–∞)

–¢–û–õ–¨–ö–û –¢–í–û–Ø –°–†–û–ß–ù–ê–Ø –†–ï–ê–ö–¶–ò–Ø (–º–∞–∫—Å–∏–º—É–º 10 —Å–ª–æ–≤):"""
        
        return prompt
    
    @staticmethod
    def build_ammo_prompt(context: Dict) -> Optional[str]:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–æ–º–ø—Ç –¥–ª—è —Å–æ–±—ã—Ç–∏—è –Ω–µ—Ö–≤–∞—Ç–∫–∏ –±–æ–µ–ø—Ä–∏–ø–∞—Å–æ–≤
        
        Args:
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –∏–≥—Ä–æ–∫–∞
        
        Returns:
            –°—Ç—Ä–æ–∫–∞ —Å –ø—Ä–æ–º–ø—Ç–æ–º –¥–ª—è LLM –∏–ª–∏ None –µ—Å–ª–∏ –±–æ–µ–ø—Ä–∏–ø–∞—Å–æ–≤ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ
        """
        if not context:
            return None
        
        total = context['ammo_total']
        mag = context['ammo_mag']
        
        # ‚úÖ –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å –∫—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç–∏
        if mag <= 0 and total <= 2:
            severity = "–ü–û–õ–ù–û–°–¢–¨–Æ –ü–£–°–¢–û! –ù–∏ –æ–¥–Ω–æ–≥–æ –ø–∞—Ç—Ä–æ–Ω–∞!"
            action = "–ò—Å–ø–æ–ª—å–∑—É–π –Ω–æ–∂–∏–∫ –∏–ª–∏ –Ω–∞–π–¥–∏ –æ—Ä—É–∂–∏–µ –Ω–∞ –∑–µ–º–ª–µ!"
        elif total <= 5:
            severity = "–ü–û–ß–¢–ò –ù–ï–¢! –ú–∞–∫—Å–∏–º—É–º 5 –ø–∞—Ç—Ä–æ–Ω–æ–≤ –æ—Å—Ç–∞–ª–æ—Å—å!"
            action = "–ö–∞–∂–¥—ã–π –≤—ã—Å—Ç—Ä–µ–ª –≤ —Å—á–µ—Ç –∏–ª–∏ –∏—â–∏ –æ—Ä—É–∂–∏–µ!"
        elif total <= 10:
            severity = "–ú–∞–ª–æ –ø–∞—Ç—Ä–æ–Ω–æ–≤. –≠–∫–æ–Ω–æ–º—å!"
            action = "–¶–µ–ª—å—Å—è –∞–∫–∫—É—Ä–∞—Ç–Ω–µ–µ!"
        else:
            return None  # –ë–æ–µ–ø—Ä–∏–ø–∞—Å–æ–≤ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ
        
        prompt = f"""–ò–†–ò–° - AI –¥–ª—è CS2 —Å—Ç—Ä–∏–º–æ–≤. –†–ï–ê–ì–ò–†–£–ô –°–†–û–ß–ù–û!

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
–°–û–ë–´–¢–ò–ï: –ë–æ–µ–ø—Ä–∏–ø–∞—Å—ã!

–°–¢–ê–¢–£–° –ò–ì–†–û–ö–ê:
‚Ä¢ –í –º–∞–≥–∞–∑–∏–Ω–µ: {mag}
‚Ä¢ –í —Ä–µ–∑–µ—Ä–≤–µ: {context['ammo_reserve']}
‚Ä¢ –í–°–ï–ì–û: {total} –ø–∞—Ç—Ä–æ–Ω–æ–≤!
‚Ä¢ Weapon: {context['weapon']}

–°–ò–¢–£–ê–¶–ò–Ø: {severity}
{action}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

–¢–í–û–Ø –ó–ê–î–ê–ß–ê:
1. –†–µ–∞–≥–∏—Ä—É–π –∫–∞–∫ –±–æ–µ–≤–æ–π —Ç–æ–≤–∞—Ä–∏—â
2. –°–æ–≤–µ—Ç—É–π —á—Ç–æ –¥–µ–ª–∞—Ç—å (—ç–∫–æ–Ω–æ–º–∏—Ç—å, –º–µ–Ω—è—Ç—å –æ—Ä—É–∂–∏–µ, –∏—Å–∫–∞—Ç—å)
3. –ú–ê–ö–°–ò–ú–£–ú 10 –°–õ–û–í
4. –ó–≤—É—á–∏ —Å—Ä–æ—á–Ω–æ –∏ –ø–æ –¥–µ–ª—É

–ü–†–ò–ú–ï–†–´:
- "–ü–∞—Ç—Ä–æ–Ω—ã –∫–æ–Ω—á–∏–ª–∏—Å—å! –ù–æ–∂–∏–∫! üî™" (4 —Å–ª–æ–≤–∞)
- "–í—Å–µ–≥–æ 5! –ö–∞–∂–¥—ã–π –≤ —Å—á–µ—Ç!" (5 —Å–ª–æ–≤)
- "–≠–∫–æ–Ω–æ–º—å! –¶–µ–ª—å—Å—è –ª—É—á—à–µ!" (4 —Å–ª–æ–≤–∞)

–¢–û–õ–¨–ö–û –¢–í–û–Ø –†–ï–ê–ö–¶–ò–Ø (–º–∞–∫—Å–∏–º—É–º 10 —Å–ª–æ–≤):"""
        
        return prompt
</file>

<file path="src/queue_manager.py">
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üéØ TTS QUEUE MANAGER - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥—å—é —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏ –∏ –±–µ–∑ —Å–ø–∞–º–∞
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import threading
import time
import logging
from collections import deque
from typing import Optional, Dict

logger = logging.getLogger("IRIS")


class TTSQueueManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä –æ—á–µ—Ä–µ–¥–∏ TTS —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏ –∏ –¥–µ–±–∞—É–Ω—Å–µ—Ä–æ–º
    
    –†–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã:
    ‚úÖ –°–ø–∞–º –æ–∑–≤—É—á–µ–∫ - –º–∞–∫—Å–∏–º—É–º 1 –æ–∑–≤—É—á–∫–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
    ‚úÖ –î–æ–ª–≥–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è - –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å (–∫—Ä–∏—Ç–∏—á–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è —Å—Ä–∞–∑—É)
    ‚úÖ –ü–µ—Ä–µ–∫—Ä—ã–≤–∞—é—â–∏–µ—Å—è —Å–æ–±—ã—Ç–∏—è - –¥–µ–±–∞—É–Ω—Å–µ—Ä 300–º—Å –º–µ–∂–¥—É –æ–∑–≤—É—á–∫–∞–º–∏
    ‚úÖ –ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ - –º–∞–∫—Å–∏–º—É–º N —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏
    """
    
    PRIORITY_CRITICAL = 10  # –ö—Ä–∏—Ç–∏—á–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è (–Ω–∏–∑–∫–æ –•–ü, –Ω–µ—Ç –ø–∞—Ç—Ä–æ–Ω–æ–≤)
    PRIORITY_KILL = 8       # –ö–∏–ª—ã –∏ –º—É–ª—å—Ç–∏–∫–∏–ª—ã
    PRIORITY_REGULAR = 5    # –û–±—ã—á–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
    PRIORITY_COMMENT = 1    # –°–ª—É—á–∞–π–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
    
    def __init__(self, tts_engine, max_queue_size: int = 8):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä –æ—á–µ—Ä–µ–¥–∏
        
        Args:
            tts_engine: –û–±—ä–µ–∫—Ç TTSEngine –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è
            max_queue_size: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏ (8 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
        """
        self.tts = tts_engine
        self.queue: deque = deque(maxlen=max_queue_size)
        self.last_speak_time = 0.0
        self.debounce_interval = 0.3  # 300–º—Å –º–µ–∂–¥—É –æ–∑–≤—É—á–∫–∞–º–∏
        self.is_speaking = False
        self.lock = threading.Lock()
        self.processor_thread: Optional[threading.Thread] = None
        self.is_running = False
        
    def add(self, text: str, emotion: str = 'neutral', priority: int = None) -> bool:
        """
        –î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –æ—á–µ—Ä–µ–¥—å
        
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è
            emotion: –≠–º–æ—Ü–∏—è –¥–ª—è TTS (neutral, excited, tense, happy, gentle –∏ —Ç.–¥.)
            priority: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é PRIORITY_REGULAR)
        
        Returns:
            True –µ—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω, False –µ—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞
        """
        if priority is None:
            priority = self.PRIORITY_REGULAR
        
        with self.lock:
            if len(self.queue) >= self.queue.maxlen:
                logger.warning(f"[TTS] –û—á–µ—Ä–µ–¥—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞ ({len(self.queue)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤)")
                return False
            
            self.queue.append({
                'text': text.strip(),
                'emotion': emotion,
                'priority': priority,
                'timestamp': time.time()
            })
            logger.debug(f"[TTS] –î–æ–±–∞–≤–ª–µ–Ω–æ: {text[:60]} (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç {priority})")
            return True
    
    def start(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—á–µ—Ä–µ–¥–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
        if self.is_running:
            return
        
        self.is_running = True
        self.processor_thread = threading.Thread(
            target=self._process_loop,
            daemon=True,
            name="TTSQueueProcessor"
        )
        self.processor_thread.start()
        logger.info("[TTS] Queue Manager –∑–∞–ø—É—â–µ–Ω")
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—á–µ—Ä–µ–¥–∏"""
        self.is_running = False
        if self.processor_thread:
            self.processor_thread.join(timeout=2)
        logger.info("[TTS] Queue Manager –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    def _process_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏ - —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
        while self.is_running:
            now = time.time()
            
            # ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–µ–±–∞—É–Ω—Å (–Ω–µ —Å–ø–µ—à–∏–º –º–µ–∂–¥—É –æ–∑–≤—É—á–∫–∞–º–∏)
            if now - self.last_speak_time < self.debounce_interval:
                time.sleep(0.05)
                continue
            
            # ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≥–æ–≤–æ—Ä–∏—Ç –ª–∏ TTS
            if self.tts.is_busy():
                time.sleep(0.1)
                continue
            
            with self.lock:
                if not self.queue:
                    time.sleep(0.1)
                    continue
                
                # ‚úÖ –í—ã–±–∏—Ä–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç —Å –Ω–∞–∏–≤—ã—Å—à–∏–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
                item = max(self.queue, key=lambda x: (x['priority'], -x['timestamp']))
                self.queue.remove(item)
            
            # ‚úÖ –û–∑–≤—É—á–∏–≤–∞–µ–º
            try:
                self.tts.speak(item['text'], emotion=item['emotion'])
                self.last_speak_time = time.time()
                
                priority_name = {
                    10: "CRITICAL",
                    8: "KILL",
                    5: "REGULAR",
                    1: "COMMENT"
                }.get(item['priority'], f"P{item['priority']}")
                
                logger.info(f"[TTS] üé§ [{priority_name}] {item['text'][:70]}")
            except Exception as e:
                logger.error(f"[TTS] ‚ùå –û—à–∏–±–∫–∞ –æ–∑–≤—É—á–∫–∏: {e}")
    
    def get_queue_size(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏"""
        with self.lock:
            return len(self.queue)
    
    def get_status(self) -> Dict:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å –º–µ–Ω–µ–¥–∂–µ—Ä–∞"""
        return {
            'queue_size': self.get_queue_size(),
            'is_running': self.is_running,
            'last_speak_time': self.last_speak_time,
            'debounce_interval': self.debounce_interval,
        }
</file>

<file path="src/session_memory.py">
"""
IRIS Session Memory v3.0 - –°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ —Å–µ—Å—Å–∏–π
–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ä–∞–∑–≥–æ–≤–æ—Ä–æ–≤, –∏–≥—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –∏ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π
"""

import json
import os
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field, asdict
from pathlib import Path
import threading
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('SessionMemory')


@dataclass
class MemoryEntry:
    """–ó–∞–ø–∏—Å—å –≤ –ø–∞–º—è—Ç–∏"""
    id: str
    category: str
    content: str
    importance: float = 0.5
    timestamp: float = field(default_factory=time.time)
    access_count: int = 0
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ConversationEntry:
    """–ó–∞–ø–∏—Å—å —Ä–∞–∑–≥–æ–≤–æ—Ä–∞"""
    role: str
    content: str
    timestamp: float = field(default_factory=time.time)
    emotion: str = "neutral"
    context: Dict[str, Any] = field(default_factory=dict)


@dataclass
class GameEventEntry:
    """–ó–∞–ø–∏—Å—å –∏–≥—Ä–æ–≤–æ–≥–æ —Å–æ–±—ã—Ç–∏—è"""
    event_type: str
    data: Dict[str, Any]
    timestamp: float = field(default_factory=time.time)
    reaction: Optional[str] = None
    map_name: str = ""
    round_number: int = 0


@dataclass
class UserPreference:
    """–ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    key: str
    value: Any
    confidence: float = 0.5
    updated_at: float = field(default_factory=time.time)
    source: str = "inferred"


class SessionMemory:
    """
    –°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ —Å–µ—Å—Å–∏–π –ò—Ä–∏—Å
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–æ–≤, –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è, –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    
    def __init__(self, 
                 data_dir: str = None,
                 max_conversation_history: int = 100,
                 max_game_events: int = 500,
                 auto_save_interval: int = 60):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏
        
        Args:
            data_dir: –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
            max_conversation_history: –ú–∞–∫—Å. –∫–æ–ª-–≤–æ –∑–∞–ø–∏—Å–µ–π —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
            max_game_events: –ú–∞–∫—Å. –∫–æ–ª-–≤–æ –∏–≥—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π
            auto_save_interval: –ò–Ω—Ç–µ—Ä–≤–∞–ª –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (—Å–µ–∫—É–Ω–¥—ã)
        """
        self.data_dir = Path(data_dir or os.path.expanduser("~/.iris_memory"))
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        self.max_conversation_history = max_conversation_history
        self.max_game_events = max_game_events
        self.auto_save_interval = auto_save_interval
        
        self.current_session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        self.conversation_history: List[ConversationEntry] = []
        self.game_events: List[GameEventEntry] = []
        self.user_preferences: Dict[str, UserPreference] = {}
        self.long_term_memory: List[MemoryEntry] = []
        
        self.session_context = {
            'streamer_name': '',
            'current_game': 'CS2',
            'current_map': '',
            'session_start': time.time(),
            'total_kills': 0,
            'total_deaths': 0,
            'mood': 'neutral',
            'energy_level': 0.5,
        }
        
        self._running = False
        self._save_thread = None
        self._lock = threading.Lock()
        
        self._load_persistent_data()
        
        print(f"[MEMORY] –°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞: {self.data_dir}")
        print(f"[MEMORY] ID —Å–µ—Å—Å–∏–∏: {self.current_session_id}")
    
    def _get_file_path(self, filename: str) -> Path:
        """–ü–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–∞–Ω–Ω—ã—Ö"""
        return self.data_dir / filename
    
    def _load_persistent_data(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        try:
            prefs_file = self._get_file_path("user_preferences.json")
            if prefs_file.exists():
                with open(prefs_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, pref_data in data.items():
                        self.user_preferences[key] = UserPreference(**pref_data)
                print(f"[MEMORY] –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.user_preferences)} –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π: {e}")
        
        try:
            memory_file = self._get_file_path("long_term_memory.json")
            if memory_file.exists():
                with open(memory_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for entry_data in data:
                        self.long_term_memory.append(MemoryEntry(**entry_data))
                print(f"[MEMORY] –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.long_term_memory)} –∑–∞–ø–∏—Å–µ–π –ø–∞–º—è—Ç–∏")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–∞–º—è—Ç–∏: {e}")
        
        try:
            history_file = self._get_file_path("recent_conversation.json")
            if history_file.exists():
                with open(history_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    
                    cutoff_time = time.time() - 24 * 3600
                    for entry_data in data:
                        if entry_data.get('timestamp', 0) > cutoff_time:
                            self.conversation_history.append(ConversationEntry(**entry_data))
                print(f"[MEMORY] –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.conversation_history)} –∑–∞–ø–∏—Å–µ–π —Ä–∞–∑–≥–æ–≤–æ—Ä–∞")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏: {e}")
    
    def _save_persistent_data(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –¥–∏—Å–∫"""
        with self._lock:
            try:
                prefs_file = self._get_file_path("user_preferences.json")
                with open(prefs_file, 'w', encoding='utf-8') as f:
                    data = {k: asdict(v) for k, v in self.user_preferences.items()}
                    json.dump(data, f, ensure_ascii=False, indent=2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π: {e}")
            
            try:
                memory_file = self._get_file_path("long_term_memory.json")
                with open(memory_file, 'w', encoding='utf-8') as f:
                    data = [asdict(entry) for entry in self.long_term_memory]
                    json.dump(data, f, ensure_ascii=False, indent=2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–∞–º—è—Ç–∏: {e}")
            
            try:
                history_file = self._get_file_path("recent_conversation.json")
                with open(history_file, 'w', encoding='utf-8') as f:
                    data = [asdict(entry) for entry in self.conversation_history[-50:]]
                    json.dump(data, f, ensure_ascii=False, indent=2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏: {e}")
    
    def _auto_save_loop(self):
        """–¶–∏–∫–ª –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è"""
        while self._running:
            time.sleep(self.auto_save_interval)
            if self._running:
                self._save_persistent_data()
    
    def add_conversation(self, role: str, content: str, 
                        emotion: str = "neutral", 
                        context: Dict[str, Any] = None):
        """
        –î–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å —Ä–∞–∑–≥–æ–≤–æ—Ä–∞
        
        Args:
            role: –†–æ–ª—å (user, assistant, system)
            content: –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
            emotion: –≠–º–æ—Ü–∏—è
            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        """
        entry = ConversationEntry(
            role=role,
            content=content,
            emotion=emotion,
            context=context or {}
        )
        
        with self._lock:
            self.conversation_history.append(entry)
            
            if len(self.conversation_history) > self.max_conversation_history:
                old_entries = self.conversation_history[:10]
                self._archive_conversations(old_entries)
                self.conversation_history = self.conversation_history[10:]
    
    def add_game_event(self, event_type: str, data: Dict[str, Any],
                      reaction: str = None):
        """
        –î–æ–±–∞–≤–∏—Ç—å –∏–≥—Ä–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ
        
        Args:
            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è (kill, death, round_end, etc.)
            data: –î–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
            reaction: –†–µ–∞–∫—Ü–∏—è –ò—Ä–∏—Å
        """
        entry = GameEventEntry(
            event_type=event_type,
            data=data,
            reaction=reaction,
            map_name=self.session_context.get('current_map', ''),
            round_number=data.get('round', 0)
        )
        
        with self._lock:
            self.game_events.append(entry)
            
            if event_type == 'kill':
                self.session_context['total_kills'] = self.session_context.get('total_kills', 0) + 1
            elif event_type == 'death':
                self.session_context['total_deaths'] = self.session_context.get('total_deaths', 0) + 1
            
            if len(self.game_events) > self.max_game_events:
                self.game_events = self.game_events[-self.max_game_events:]
    
    def set_preference(self, key: str, value: Any, 
                      confidence: float = 0.5, source: str = "inferred"):
        """
        –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        Args:
            key: –ö–ª—é—á –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è
            value: –ó–Ω–∞—á–µ–Ω–∏–µ
            confidence: –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å (0.0-1.0)
            source: –ò—Å—Ç–æ—á–Ω–∏–∫ (explicit, inferred, learned)
        """
        with self._lock:
            if key in self.user_preferences:
                existing = self.user_preferences[key]
                if source == "explicit" or confidence > existing.confidence:
                    self.user_preferences[key] = UserPreference(
                        key=key,
                        value=value,
                        confidence=confidence,
                        source=source
                    )
            else:
                self.user_preferences[key] = UserPreference(
                    key=key,
                    value=value,
                    confidence=confidence,
                    source=source
                )
    
    def get_preference(self, key: str, default: Any = None) -> Any:
        """–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        with self._lock:
            if key in self.user_preferences:
                pref = self.user_preferences[key]
                pref.access_count = getattr(pref, 'access_count', 0) + 1
                return pref.value
            return default
    
    def remember(self, content: str, category: str = "general",
                importance: float = 0.5, tags: List[str] = None,
                metadata: Dict[str, Any] = None):
        """
        –ó–∞–ø–æ–º–Ω–∏—Ç—å –≤–∞–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        
        Args:
            content: –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
            category: –ö–∞—Ç–µ–≥–æ—Ä–∏—è (general, user_info, game_fact, preference)
            importance: –í–∞–∂–Ω–æ—Å—Ç—å (0.0-1.0)
            tags: –¢–µ–≥–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞
            metadata: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        """
        import uuid
        entry = MemoryEntry(
            id=str(uuid.uuid4()),
            category=category,
            content=content,
            importance=importance,
            tags=tags or [],
            metadata=metadata or {}
        )
        
        with self._lock:
            self.long_term_memory.append(entry)
            
            if importance >= 0.8:
                self._save_persistent_data()
    
    def recall(self, query: str = None, category: str = None,
              tags: List[str] = None, limit: int = 10) -> List[MemoryEntry]:
        """
        –í—Å–ø–æ–º–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        
        Args:
            query: –ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
            category: –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            tags: –§–∏–ª—å—Ç—Ä –ø–æ —Ç–µ–≥–∞–º
            limit: –ú–∞–∫—Å–∏–º—É–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            
        Returns:
            –°–ø–∏—Å–æ–∫ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π
        """
        with self._lock:
            results = []
            
            for entry in self.long_term_memory:
                if category and entry.category != category:
                    continue
                
                if tags and not any(tag in entry.tags for tag in tags):
                    continue
                
                if query:
                    query_lower = query.lower()
                    if query_lower not in entry.content.lower():
                        continue
                
                entry.access_count += 1
                results.append(entry)
            
            results.sort(key=lambda x: (x.importance, x.access_count), reverse=True)
            return results[:limit]
    
    def get_recent_conversation(self, count: int = 10) -> List[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–ø–∏—Å–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞"""
        with self._lock:
            entries = self.conversation_history[-count:]
            return [asdict(entry) for entry in entries]
    
    def get_conversation_context(self, max_tokens: int = 2000) -> str:
        """
        –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –¥–ª—è LLM
        
        Args:
            max_tokens: –ü—Ä–∏–º–µ—Ä–Ω—ã–π –ª–∏–º–∏—Ç —Å–∏–º–≤–æ–ª–æ–≤
            
        Returns:
            –¢–µ–∫—Å—Ç–æ–≤—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        """
        with self._lock:
            context_parts = []
            
            for pref_key in ['streamer_name', 'communication_style', 'humor_level']:
                if pref_key in self.user_preferences:
                    pref = self.user_preferences[pref_key]
                    context_parts.append(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {pref_key}={pref.value}")
            
            for entry in self.conversation_history[-20:]:
                role_name = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å" if entry.role == "user" else "–ò—Ä–∏—Å"
                context_parts.append(f"{role_name}: {entry.content}")
            
            context = "\n".join(context_parts)
            
            if len(context) > max_tokens:
                context = context[-max_tokens:]
            
            return context
    
    def get_session_summary(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–≤–æ–¥–∫—É —Ç–µ–∫—É—â–µ–π —Å–µ—Å—Å–∏–∏"""
        with self._lock:
            session_duration = time.time() - self.session_context.get('session_start', time.time())
            
            kills = sum(1 for e in self.game_events if e.event_type == 'kill')
            deaths = sum(1 for e in self.game_events if e.event_type == 'death')
            
            return {
                'session_id': self.current_session_id,
                'duration_minutes': int(session_duration / 60),
                'total_kills': kills,
                'total_deaths': deaths,
                'kd_ratio': round(kills / max(1, deaths), 2),
                'conversation_count': len(self.conversation_history),
                'events_count': len(self.game_events),
                'current_map': self.session_context.get('current_map', 'Unknown'),
                'current_mood': self.session_context.get('mood', 'neutral'),
            }
    
    def _archive_conversations(self, entries: List[ConversationEntry]):
        """–ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–µ —Ä–∞–∑–≥–æ–≤–æ—Ä—ã –≤ –ø–∞–º—è—Ç—å"""
        for entry in entries:
            if len(entry.content) > 50:
                self.remember(
                    content=f"[{entry.role}] {entry.content[:200]}",
                    category="conversation_archive",
                    importance=0.3,
                    metadata={'original_timestamp': entry.timestamp}
                )
    
    def update_session_context(self, key: str, value: Any):
        """–û–±–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–µ—Å—Å–∏–∏"""
        with self._lock:
            self.session_context[key] = value
    
    def get_session_context(self, key: str = None) -> Any:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–µ—Å—Å–∏–∏"""
        with self._lock:
            if key:
                return self.session_context.get(key)
            return dict(self.session_context)
    
    def start(self):
        """–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏"""
        if self._running:
            return
        
        self._running = True
        self._save_thread = threading.Thread(
            target=self._auto_save_loop,
            daemon=True,
            name="MemoryAutoSave"
        )
        self._save_thread.start()
        print("[MEMORY] –°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ –∑–∞–ø—É—â–µ–Ω–∞")
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏"""
        if not self._running:
            return
        
        self._running = False
        
        if self._save_thread:
            self._save_thread.join(timeout=2.0)
        
        self._save_persistent_data()
        
        self._save_session_log()
        
        print("[MEMORY] –°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
    
    def _save_session_log(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ª–æ–≥ —Å–µ—Å—Å–∏–∏"""
        try:
            sessions_dir = self.data_dir / "sessions"
            sessions_dir.mkdir(exist_ok=True)
            
            session_file = sessions_dir / f"session_{self.current_session_id}.json"
            
            session_data = {
                'session_id': self.current_session_id,
                'summary': self.get_session_summary(),
                'context': self.session_context,
                'conversation_count': len(self.conversation_history),
                'events_count': len(self.game_events),
            }
            
            with open(session_file, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–æ–≥–∞ —Å–µ—Å—Å–∏–∏: {e}")


if __name__ == "__main__":
    print("=== –¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏ –ò—Ä–∏—Å ===\n")
    
    memory = SessionMemory()
    memory.start()
    
    memory.set_preference("streamer_name", "TestStreamer", confidence=1.0, source="explicit")
    memory.set_preference("humor_level", "high", confidence=0.7, source="inferred")
    
    memory.add_conversation("user", "–ü—Ä–∏–≤–µ—Ç, –ò—Ä–∏—Å!")
    memory.add_conversation("assistant", "–ü—Ä–∏–≤–µ—Ç! –†–∞–¥–∞ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å!", emotion="happy")
    memory.add_conversation("user", "–ö–∞–∫ –¥–µ–ª–∞?")
    memory.add_conversation("assistant", "–û—Ç–ª–∏—á–Ω–æ! –ì–æ—Ç–æ–≤–∞ –ø–æ–º–æ–≥–∞—Ç—å –Ω–∞ —Å—Ç—Ä–∏–º–µ!", emotion="excited")
    
    memory.add_game_event("kill", {"weapon": "ak47", "headshot": True}, "–ö—Ä–∞—Å–∏–≤—ã–π —Ö–µ–¥—à–æ—Ç!")
    memory.add_game_event("kill", {"weapon": "awp", "headshot": False}, "–°–Ω–∞–π–ø–µ—Ä –≤ –¥–µ–ª–µ!")
    memory.add_game_event("death", {"attacker": "Enemy", "weapon": "m4a4"}, "–ë—ã–≤–∞–µ—Ç...")
    
    memory.remember(
        "–°—Ç—Ä–∏–º–µ—Ä –ª—é–±–∏—Ç –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π —Å—Ç–∏–ª—å –∏–≥—Ä—ã",
        category="user_info",
        importance=0.8,
        tags=["playstyle", "preference"]
    )
    
    print("–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–∞–∑–≥–æ–≤–æ—Ä—ã:")
    for conv in memory.get_recent_conversation(5):
        print(f"  [{conv['role']}]: {conv['content']}")
    
    print(f"\n–ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ 'streamer_name': {memory.get_preference('streamer_name')}")
    
    print("\n–ü–æ–∏—Å–∫ –≤ –ø–∞–º—è—Ç–∏ '—Å—Ç–∏–ª—å':")
    for entry in memory.recall(query="—Å—Ç–∏–ª—å"):
        print(f"  - {entry.content}")
    
    print(f"\n–°–≤–æ–¥–∫–∞ —Å–µ—Å—Å–∏–∏: {memory.get_session_summary()}")
    
    time.sleep(1)
    memory.stop()
    
    print("\n–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω!")
</file>

<file path="src/statistics_tracker.py">
"""
IRIS Statistics Tracker v3.0 - –°–∏—Å—Ç–µ–º–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –≤—Å–µ –≤—Ä–µ–º—è
–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π, —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä—ã –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Å—Ç—Ä–∏–º–µ—Ä–∞
"""

import json
import os
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field, asdict
from pathlib import Path
from enum import Enum
import threading
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('Statistics')


class AchievementType(Enum):
    KILLS = "kills"
    HEADSHOTS = "headshots"
    CLUTCHES = "clutches"
    ACES = "aces"
    STREAM_TIME = "stream_time"
    WIN_STREAK = "win_streak"
    SESSIONS = "sessions"


@dataclass
class Achievement:
    """–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ"""
    id: str
    name: str
    description: str
    type: str
    requirement: int
    unlocked: bool = False
    unlocked_at: Optional[float] = None
    progress: int = 0
    icon: str = "üèÜ"
    rarity: str = "common"


@dataclass
class SessionStats:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–¥–Ω–æ–π —Å–µ—Å—Å–∏–∏"""
    session_id: str
    date: str
    duration_minutes: int
    kills: int = 0
    deaths: int = 0
    headshots: int = 0
    clutches: int = 0
    aces: int = 0
    rounds_won: int = 0
    rounds_lost: int = 0
    maps_played: List[str] = field(default_factory=list)
    best_weapon: str = ""
    highlight_moments: List[Dict] = field(default_factory=list)


@dataclass
class LifetimeStats:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –≤—Å–µ –≤—Ä–µ–º—è"""
    total_sessions: int = 0
    total_stream_minutes: int = 0
    total_kills: int = 0
    total_deaths: int = 0
    total_headshots: int = 0
    total_clutches: int = 0
    total_aces: int = 0
    total_rounds_won: int = 0
    total_rounds_lost: int = 0
    best_kd_ratio: float = 0.0
    best_kill_streak: int = 0
    longest_session_minutes: int = 0
    first_stream_date: Optional[str] = None
    favorite_map: str = ""
    favorite_weapon: str = ""
    current_win_streak: int = 0
    best_win_streak: int = 0


class StatisticsTracker:
    """
    –°–∏—Å—Ç–µ–º–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ò—Ä–∏—Å
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    """
    
    DEFAULT_ACHIEVEMENTS = [
        Achievement("first_blood", "–ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å", "–ü–µ—Ä–≤–æ–µ —É–±–∏–π—Å—Ç–≤–æ —Å –ò—Ä–∏—Å", "kills", 1, icon="ü©∏", rarity="common"),
        Achievement("killer_10", "–ù–æ–≤–∏—á–æ–∫", "10 —É–±–∏–π—Å—Ç–≤", "kills", 10, icon="üî´", rarity="common"),
        Achievement("killer_100", "–û—Ö–æ—Ç–Ω–∏–∫", "100 —É–±–∏–π—Å—Ç–≤", "kills", 100, icon="üíÄ", rarity="uncommon"),
        Achievement("killer_500", "–ò—Å—Ç—Ä–µ–±–∏—Ç–µ–ª—å", "500 —É–±–∏–π—Å—Ç–≤", "kills", 500, icon="‚ò†Ô∏è", rarity="rare"),
        Achievement("killer_1000", "–õ–µ–≥–µ–Ω–¥–∞", "1000 —É–±–∏–π—Å—Ç–≤", "kills", 1000, icon="üëë", rarity="epic"),
        Achievement("headshot_10", "–ú–µ—Ç–∫–∏–π —Å—Ç—Ä–µ–ª–æ–∫", "10 —Ö–µ–¥—à–æ—Ç–æ–≤", "headshots", 10, icon="üéØ", rarity="common"),
        Achievement("headshot_100", "–°–Ω–∞–π–ø–µ—Ä", "100 —Ö–µ–¥—à–æ—Ç–æ–≤", "headshots", 100, icon="üî≠", rarity="rare"),
        Achievement("first_ace", "–ê–°!", "–ü–µ—Ä–≤—ã–π —ç–π—Å", "aces", 1, icon="‚ô†Ô∏è", rarity="rare"),
        Achievement("ace_5", "–ú–∞—Å—Ç–µ—Ä —ç–π—Å–æ–≤", "5 —ç–π—Å–æ–≤", "aces", 5, icon="üÉè", rarity="epic"),
        Achievement("first_clutch", "–ö–ª–∞—Ç—á!", "–ü–µ—Ä–≤—ã–π –∫–ª–∞—Ç—á", "clutches", 1, icon="üí™", rarity="uncommon"),
        Achievement("clutch_10", "–°–ø–∞—Å–∏—Ç–µ–ª—å", "10 –∫–ª–∞—Ç—á–µ–π", "clutches", 10, icon="ü¶∏", rarity="rare"),
        Achievement("stream_1h", "–ü–µ—Ä–≤—ã–π —á–∞—Å", "1 —á–∞—Å —Å—Ç—Ä–∏–º–æ–≤", "stream_time", 60, icon="‚è∞", rarity="common"),
        Achievement("stream_10h", "–°—Ç—Ä–∏–º–µ—Ä", "10 —á–∞—Å–æ–≤ —Å—Ç—Ä–∏–º–æ–≤", "stream_time", 600, icon="üì∫", rarity="uncommon"),
        Achievement("stream_100h", "–í–µ—Ç–µ—Ä–∞–Ω", "100 —á–∞—Å–æ–≤ —Å—Ç—Ä–∏–º–æ–≤", "stream_time", 6000, icon="üéñÔ∏è", rarity="epic"),
        Achievement("win_streak_3", "–ü–æ–±–µ–¥–Ω–∞—è —Å–µ—Ä–∏—è", "3 –ø–æ–±–µ–¥—ã –ø–æ–¥—Ä—è–¥", "win_streak", 3, icon="üî•", rarity="common"),
        Achievement("win_streak_5", "–ù–∞ –∫—É—Ä–∞–∂–µ", "5 –ø–æ–±–µ–¥ –ø–æ–¥—Ä—è–¥", "win_streak", 5, icon="üåü", rarity="uncommon"),
        Achievement("win_streak_10", "–ù–µ–ø–æ–±–µ–¥–∏–º—ã–π", "10 –ø–æ–±–µ–¥ –ø–æ–¥—Ä—è–¥", "win_streak", 10, icon="üí´", rarity="epic"),
        Achievement("sessions_10", "–ü–æ—Å—Ç–æ—è–Ω—Å—Ç–≤–æ", "10 —Å–µ—Å—Å–∏–π —Å –ò—Ä–∏—Å", "sessions", 10, icon="üìÖ", rarity="common"),
        Achievement("sessions_50", "–ü—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å", "50 —Å–µ—Å—Å–∏–π —Å –ò—Ä–∏—Å", "sessions", 50, icon="üíù", rarity="rare"),
        Achievement("sessions_100", "–ù–µ—Ä–∞–∑–ª—É—á–Ω—ã", "100 —Å–µ—Å—Å–∏–π —Å –ò—Ä–∏—Å", "sessions", 100, icon="üíñ", rarity="legendary"),
    ]
    
    def __init__(self, data_dir: str = None, auto_save: bool = True):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–∫–µ—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        
        Args:
            data_dir: –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –¥–∞–Ω–Ω—ã—Ö
            auto_save: –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        """
        self.data_dir = Path(data_dir or os.path.expanduser("~/.iris_stats"))
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        self.auto_save = auto_save
        
        self.lifetime_stats = LifetimeStats()
        self.achievements: Dict[str, Achievement] = {}
        self.session_history: List[SessionStats] = []
        self.current_session: Optional[SessionStats] = None
        
        self.kill_streak = 0
        self.round_kills = 0
        
        self.weapon_kills: Dict[str, int] = {}
        self.map_stats: Dict[str, Dict[str, int]] = {}
        
        self._running = False
        self._lock = threading.Lock()
        
        self._init_achievements()
        self._load_data()
        
        print(f"[STATS] –°–∏—Å—Ç–µ–º–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞: {self.data_dir}")
    
    def _init_achievements(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π"""
        for achievement in self.DEFAULT_ACHIEVEMENTS:
            self.achievements[achievement.id] = Achievement(
                id=achievement.id,
                name=achievement.name,
                description=achievement.description,
                type=achievement.type,
                requirement=achievement.requirement,
                icon=achievement.icon,
                rarity=achievement.rarity
            )
    
    def _load_data(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        try:
            stats_file = self.data_dir / "lifetime_stats.json"
            if stats_file.exists():
                with open(stats_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for key, value in data.items():
                        if hasattr(self.lifetime_stats, key):
                            setattr(self.lifetime_stats, key, value)
                print(f"[STATS] –ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {self.lifetime_stats.total_kills} —É–±–∏–π—Å—Ç–≤")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
        
        try:
            achievements_file = self.data_dir / "achievements.json"
            if achievements_file.exists():
                with open(achievements_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for ach_id, ach_data in data.items():
                        if ach_id in self.achievements:
                            self.achievements[ach_id].unlocked = ach_data.get('unlocked', False)
                            self.achievements[ach_id].unlocked_at = ach_data.get('unlocked_at')
                            self.achievements[ach_id].progress = ach_data.get('progress', 0)
                unlocked = sum(1 for a in self.achievements.values() if a.unlocked)
                print(f"[STATS] –ó–∞–≥—Ä—É–∂–µ–Ω—ã –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è: {unlocked}/{len(self.achievements)}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π: {e}")
        
        try:
            weapons_file = self.data_dir / "weapon_stats.json"
            if weapons_file.exists():
                with open(weapons_file, 'r', encoding='utf-8') as f:
                    self.weapon_kills = json.load(f)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –æ—Ä—É–∂–∏—è: {e}")
        
        try:
            maps_file = self.data_dir / "map_stats.json"
            if maps_file.exists():
                with open(maps_file, 'r', encoding='utf-8') as f:
                    self.map_stats = json.load(f)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–∞—Ä—Ç: {e}")
    
    def _save_data(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö"""
        with self._lock:
            try:
                stats_file = self.data_dir / "lifetime_stats.json"
                with open(stats_file, 'w', encoding='utf-8') as f:
                    json.dump(asdict(self.lifetime_stats), f, ensure_ascii=False, indent=2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
            
            try:
                achievements_file = self.data_dir / "achievements.json"
                with open(achievements_file, 'w', encoding='utf-8') as f:
                    data = {}
                    for ach_id, ach in self.achievements.items():
                        data[ach_id] = {
                            'unlocked': ach.unlocked,
                            'unlocked_at': ach.unlocked_at,
                            'progress': ach.progress
                        }
                    json.dump(data, f, ensure_ascii=False, indent=2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π: {e}")
            
            try:
                weapons_file = self.data_dir / "weapon_stats.json"
                with open(weapons_file, 'w', encoding='utf-8') as f:
                    json.dump(self.weapon_kills, f, ensure_ascii=False, indent=2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –æ—Ä—É–∂–∏—è: {e}")
            
            try:
                maps_file = self.data_dir / "map_stats.json"
                with open(maps_file, 'w', encoding='utf-8') as f:
                    json.dump(self.map_stats, f, ensure_ascii=False, indent=2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–∞—Ä—Ç: {e}")
    
    def start_session(self) -> str:
        """
        –ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é
        
        Returns:
            ID —Å–µ—Å—Å–∏–∏
        """
        session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        self.current_session = SessionStats(
            session_id=session_id,
            date=datetime.now().strftime("%Y-%m-%d"),
            duration_minutes=0
        )
        
        self.kill_streak = 0
        self.round_kills = 0
        
        self.lifetime_stats.total_sessions += 1
        
        if not self.lifetime_stats.first_stream_date:
            self.lifetime_stats.first_stream_date = datetime.now().strftime("%Y-%m-%d")
        
        self._check_achievement("sessions", self.lifetime_stats.total_sessions)
        
        self._running = True
        print(f"[STATS] –°–µ—Å—Å–∏—è –Ω–∞—á–∞—Ç–∞: {session_id}")
        
        return session_id
    
    def end_session(self, duration_minutes: int = None):
        """–ó–∞–≤–µ—Ä—à–∏—Ç—å —Å–µ—Å—Å–∏—é"""
        if not self.current_session:
            return
        
        if duration_minutes:
            self.current_session.duration_minutes = duration_minutes
        
        self.lifetime_stats.total_stream_minutes += self.current_session.duration_minutes
        
        if self.current_session.duration_minutes > self.lifetime_stats.longest_session_minutes:
            self.lifetime_stats.longest_session_minutes = self.current_session.duration_minutes
        
        self._check_achievement("stream_time", self.lifetime_stats.total_stream_minutes)
        
        if self.current_session.deaths > 0:
            kd = self.current_session.kills / self.current_session.deaths
            if kd > self.lifetime_stats.best_kd_ratio:
                self.lifetime_stats.best_kd_ratio = round(kd, 2)
        
        self._update_favorite_weapon()
        self._update_favorite_map()
        
        self.session_history.append(self.current_session)
        
        self._save_data()
        self._save_session_history()
        
        print(f"[STATS] –°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {self.current_session.kills} —É–±–∏–π—Å—Ç–≤, {self.current_session.deaths} —Å–º–µ—Ä—Ç–µ–π")
        
        self.current_session = None
        self._running = False
    
    def record_kill(self, weapon: str = "", headshot: bool = False, 
                   map_name: str = "", victim: str = "") -> List[Achievement]:
        """
        –ó–∞–ø–∏—Å–∞—Ç—å —É–±–∏–π—Å—Ç–≤–æ
        
        Returns:
            –°–ø–∏—Å–æ–∫ –Ω–æ–≤—ã—Ö —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
        """
        new_achievements = []
        
        with self._lock:
            self.lifetime_stats.total_kills += 1
            self.kill_streak += 1
            self.round_kills += 1
            
            if self.current_session:
                self.current_session.kills += 1
            
            if headshot:
                self.lifetime_stats.total_headshots += 1
                if self.current_session:
                    self.current_session.headshots += 1
            
            if weapon:
                self.weapon_kills[weapon] = self.weapon_kills.get(weapon, 0) + 1
                if self.current_session and not self.current_session.best_weapon:
                    self.current_session.best_weapon = weapon
            
            if map_name:
                if map_name not in self.map_stats:
                    self.map_stats[map_name] = {'kills': 0, 'deaths': 0, 'rounds': 0}
                self.map_stats[map_name]['kills'] += 1
            
            if self.kill_streak > self.lifetime_stats.best_kill_streak:
                self.lifetime_stats.best_kill_streak = self.kill_streak
            
            if self.round_kills == 5:
                self.lifetime_stats.total_aces += 1
                if self.current_session:
                    self.current_session.aces += 1
                    self.current_session.highlight_moments.append({
                        'type': 'ace',
                        'timestamp': time.time(),
                        'weapon': weapon
                    })
                ach = self._check_achievement("aces", self.lifetime_stats.total_aces)
                if ach:
                    new_achievements.append(ach)
            
            ach = self._check_achievement("kills", self.lifetime_stats.total_kills)
            if ach:
                new_achievements.append(ach)
            
            if headshot:
                ach = self._check_achievement("headshots", self.lifetime_stats.total_headshots)
                if ach:
                    new_achievements.append(ach)
        
        if self.auto_save and self.lifetime_stats.total_kills % 50 == 0:
            self._save_data()
        
        return new_achievements
    
    def record_death(self, attacker: str = "", weapon: str = "", map_name: str = ""):
        """–ó–∞–ø–∏—Å–∞—Ç—å —Å–º–µ—Ä—Ç—å"""
        with self._lock:
            self.lifetime_stats.total_deaths += 1
            self.kill_streak = 0
            
            if self.current_session:
                self.current_session.deaths += 1
            
            if map_name and map_name in self.map_stats:
                self.map_stats[map_name]['deaths'] += 1
    
    def record_round_end(self, won: bool, map_name: str = ""):
        """–ó–∞–ø–∏—Å–∞—Ç—å –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ä–∞—É–Ω–¥–∞"""
        with self._lock:
            self.round_kills = 0
            
            if won:
                self.lifetime_stats.total_rounds_won += 1
                self.lifetime_stats.current_win_streak += 1
                
                if self.lifetime_stats.current_win_streak > self.lifetime_stats.best_win_streak:
                    self.lifetime_stats.best_win_streak = self.lifetime_stats.current_win_streak
                
                if self.current_session:
                    self.current_session.rounds_won += 1
                
                self._check_achievement("win_streak", self.lifetime_stats.current_win_streak)
            else:
                self.lifetime_stats.total_rounds_lost += 1
                self.lifetime_stats.current_win_streak = 0
                
                if self.current_session:
                    self.current_session.rounds_lost += 1
            
            if map_name:
                if map_name not in self.map_stats:
                    self.map_stats[map_name] = {'kills': 0, 'deaths': 0, 'rounds': 0}
                self.map_stats[map_name]['rounds'] += 1
    
    def record_clutch(self, enemies_killed: int = 1, map_name: str = "") -> Optional[Achievement]:
        """–ó–∞–ø–∏—Å–∞—Ç—å –∫–ª–∞—Ç—á"""
        with self._lock:
            self.lifetime_stats.total_clutches += 1
            
            if self.current_session:
                self.current_session.clutches += 1
                self.current_session.highlight_moments.append({
                    'type': 'clutch',
                    'timestamp': time.time(),
                    'enemies': enemies_killed
                })
            
            return self._check_achievement("clutches", self.lifetime_stats.total_clutches)
    
    def _check_achievement(self, achievement_type: str, current_value: int) -> Optional[Achievement]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ"""
        for ach_id, ach in self.achievements.items():
            if ach.type == achievement_type and not ach.unlocked:
                ach.progress = current_value
                
                if current_value >= ach.requirement:
                    ach.unlocked = True
                    ach.unlocked_at = time.time()
                    print(f"[STATS] üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: {ach.icon} {ach.name}")
                    return ach
        return None
    
    def _update_favorite_weapon(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –ª—é–±–∏–º–æ–µ –æ—Ä—É–∂–∏–µ"""
        if self.weapon_kills:
            self.lifetime_stats.favorite_weapon = max(
                self.weapon_kills, 
                key=self.weapon_kills.get
            )
    
    def _update_favorite_map(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –ª—é–±–∏–º—É—é –∫–∞—Ä—Ç—É"""
        if self.map_stats:
            self.lifetime_stats.favorite_map = max(
                self.map_stats,
                key=lambda m: self.map_stats[m].get('rounds', 0)
            )
    
    def _save_session_history(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å–µ—Å—Å–∏–π"""
        try:
            history_file = self.data_dir / "session_history.json"
            
            recent_sessions = self.session_history[-100:]
            data = [asdict(s) for s in recent_sessions]
            
            with open(history_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ —Å–µ—Å—Å–∏–π: {e}")
    
    def get_lifetime_summary(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–≤–æ–¥–∫—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –≤—Å–µ –≤—Ä–µ–º—è"""
        return {
            'total_sessions': self.lifetime_stats.total_sessions,
            'total_hours': round(self.lifetime_stats.total_stream_minutes / 60, 1),
            'total_kills': self.lifetime_stats.total_kills,
            'total_deaths': self.lifetime_stats.total_deaths,
            'kd_ratio': round(
                self.lifetime_stats.total_kills / max(1, self.lifetime_stats.total_deaths), 2
            ),
            'total_headshots': self.lifetime_stats.total_headshots,
            'headshot_percent': round(
                self.lifetime_stats.total_headshots / max(1, self.lifetime_stats.total_kills) * 100, 1
            ),
            'total_aces': self.lifetime_stats.total_aces,
            'total_clutches': self.lifetime_stats.total_clutches,
            'best_kill_streak': self.lifetime_stats.best_kill_streak,
            'best_win_streak': self.lifetime_stats.best_win_streak,
            'favorite_weapon': self.lifetime_stats.favorite_weapon,
            'favorite_map': self.lifetime_stats.favorite_map,
            'first_stream': self.lifetime_stats.first_stream_date,
        }
    
    def get_unlocked_achievements(self) -> List[Achievement]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è"""
        return [a for a in self.achievements.values() if a.unlocked]
    
    def get_next_achievements(self, limit: int = 3) -> List[Tuple[Achievement, float]]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –±–ª–∏–∂–∞–π—à–∏–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∫ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–µ
        
        Returns:
            –°–ø–∏—Å–æ–∫ (–¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ, –ø—Ä–æ–≥—Ä–µ—Å—Å –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö)
        """
        locked = [a for a in self.achievements.values() if not a.unlocked]
        
        with_progress = []
        for ach in locked:
            progress_percent = min(100, (ach.progress / ach.requirement) * 100)
            with_progress.append((ach, progress_percent))
        
        with_progress.sort(key=lambda x: x[1], reverse=True)
        return with_progress[:limit]
    
    def format_stats_message(self) -> str:
        """–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π"""
        stats = self.get_lifetime_summary()
        
        message = f"""üìä –¢–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è:

üéØ –£–±–∏–π—Å—Ç–≤: {stats['total_kills']} (K/D: {stats['kd_ratio']})
üíÄ –°–º–µ—Ä—Ç–µ–π: {stats['total_deaths']}
üéØ –•–µ–¥—à–æ—Ç–æ–≤: {stats['total_headshots']} ({stats['headshot_percent']}%)
‚ô†Ô∏è –≠–π—Å–æ–≤: {stats['total_aces']}
üí™ –ö–ª–∞—Ç—á–µ–π: {stats['total_clutches']}
üî• –õ—É—á—à–∞—è —Å–µ—Ä–∏—è: {stats['best_kill_streak']} —É–±–∏–π—Å—Ç–≤

‚è±Ô∏è –í—Ä–µ–º—è —Å—Ç—Ä–∏–º–æ–≤: {stats['total_hours']} —á–∞—Å–æ–≤
üì∫ –°–µ—Å—Å–∏–π: {stats['total_sessions']}
üó∫Ô∏è –õ—é–±–∏–º–∞—è –∫–∞—Ä—Ç–∞: {stats['favorite_map'] or '–ü–æ–∫–∞ –Ω–µ—Ç'}
üî´ –õ—é–±–∏–º–æ–µ –æ—Ä—É–∂–∏–µ: {stats['favorite_weapon'] or '–ü–æ–∫–∞ –Ω–µ—Ç'}

üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏–π: {len(self.get_unlocked_achievements())}/{len(self.achievements)}"""
        
        return message


if __name__ == "__main__":
    print("=== –¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ò—Ä–∏—Å ===\n")
    
    tracker = StatisticsTracker()
    
    session_id = tracker.start_session()
    print(f"–°–µ—Å—Å–∏—è: {session_id}\n")
    
    new_achs = tracker.record_kill(weapon="ak47", headshot=True, map_name="de_dust2")
    for ach in new_achs:
        print(f"–ù–æ–≤–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {ach.icon} {ach.name}")
    
    tracker.record_kill(weapon="ak47", headshot=False)
    tracker.record_kill(weapon="awp", headshot=True)
    tracker.record_death(attacker="Enemy", weapon="m4a4")
    tracker.record_round_end(won=True, map_name="de_dust2")
    
    for i in range(5):
        tracker.record_kill(weapon="ak47")
    
    tracker.end_session(duration_minutes=45)
    
    print("\n" + tracker.format_stats_message())
    
    print("\n\n–ë–ª–∏–∂–∞–π—à–∏–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è:")
    for ach, progress in tracker.get_next_achievements():
        print(f"  {ach.icon} {ach.name}: {progress:.1f}%")
    
    print("\n–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω!")
</file>

<file path="src/utils/tts_utils.py">
"""
TTS Utils - –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API
"""
from src.utils import synthesize_and_play

__all__ = ['synthesize_and_play']
</file>

<file path="src/voice_recognition.py">
import os
import time
import threading
import queue

try:
    import speech_recognition as sr
    SR_AVAILABLE = True
except ImportError:
    SR_AVAILABLE = False
    print("[VOICE] SpeechRecognition –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

PYAUDIO_AVAILABLE = False
try:
    import pyaudio
    PYAUDIO_AVAILABLE = True
except ImportError:
    print("[VOICE] PyAudio –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - –≥–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –º–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ")

class VoiceRecognition:
    WAKE_WORDS = ['–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∏–∫', '—ç–π –∏—Ä–∏—Å', 'hey iris', '–∏—Ä–∏—Å–∫–∞']
    
    def __init__(self, 
                 wake_word_callback=None,
                 command_callback=None,
                 language: str = "ru-RU"):
        
        self.wake_word_callback = wake_word_callback
        self.command_callback = command_callback
        self.language = language
        
        self.is_listening = False
        self.conversation_mode = False
        self.conversation_timeout = 30.0
        self.last_interaction_time = 0
        
        if SR_AVAILABLE and PYAUDIO_AVAILABLE:
            self.recognizer = sr.Recognizer()
            self.recognizer.energy_threshold = 300
            self.recognizer.dynamic_energy_threshold = True
            self.recognizer.pause_threshold = 0.8
        else:
            self.recognizer = None
            
        self.listen_thread = None
            
    def start_listening(self):
        if not SR_AVAILABLE or not PYAUDIO_AVAILABLE:
            print("[VOICE] –ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥")
            return False
            
        self.is_listening = True
        self.listen_thread = threading.Thread(target=self._listen_loop, daemon=True)
        self.listen_thread.start()
        
        print("[VOICE] –°–ª—É—à–∞—é... –°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å' –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏")
        return True
        
    def stop_listening(self):
        self.is_listening = False
        self.conversation_mode = False
        
    def _listen_loop(self):
        try:
            with sr.Microphone() as source:
                print("[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...")
                self.recognizer.adjust_for_ambient_noise(source, duration=1)
                print("[VOICE] –ì–æ—Ç–æ–≤ –∫ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—é!")
                
                while self.is_listening:
                    try:
                        audio = self.recognizer.listen(source, timeout=5, phrase_time_limit=10)
                        
                        threading.Thread(
                            target=self._process_audio, 
                            args=(audio,),
                            daemon=True
                        ).start()
                        
                    except sr.WaitTimeoutError:
                        if self.conversation_mode:
                            if time.time() - self.last_interaction_time > self.conversation_timeout:
                                self.conversation_mode = False
                                print("[VOICE] –†–µ–∂–∏–º —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∑–∞–≤–µ—Ä—à—ë–Ω –ø–æ —Ç–∞–π–º–∞—É—Ç—É")
                        continue
                    except Exception as e:
                        print(f"[VOICE] –û—à–∏–±–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è: {e}")
                        continue
                        
        except Exception as e:
            print(f"[VOICE] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
            
    def _process_audio(self, audio):
        try:
            text = self.recognizer.recognize_google(audio, language=self.language)
            text = text.lower().strip()
            
            if not text:
                return
                
            print(f"[VOICE] –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {text}")
            self._handle_transcription(text)
            
        except sr.UnknownValueError:
            pass
        except sr.RequestError as e:
            print(f"[VOICE] –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: {e}")
        except Exception as e:
            print(f"[VOICE] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
            
    def _handle_transcription(self, text: str):
        if self.conversation_mode:
            self.last_interaction_time = time.time()
            if self.command_callback:
                self.command_callback(text, is_conversation=True)
            return
            
        for wake_word in self.WAKE_WORDS:
            if wake_word in text:
                self.conversation_mode = True
                self.last_interaction_time = time.time()
                
                command = text
                for ww in self.WAKE_WORDS:
                    command = command.replace(ww, '').strip()
                    
                print(f"[VOICE] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω! –ö–æ–º–∞–Ω–¥–∞: {command}")
                
                if self.wake_word_callback:
                    self.wake_word_callback()
                    
                if command and self.command_callback:
                    self.command_callback(command, is_conversation=False)
                elif self.command_callback:
                    self.command_callback("", is_conversation=False)
                    
                return
                
    def set_conversation_mode(self, enabled: bool):
        self.conversation_mode = enabled
        if enabled:
            self.last_interaction_time = time.time()
            
    def is_in_conversation(self) -> bool:
        return self.conversation_mode
        

class TextInputFallback:
    def __init__(self, command_callback=None):
        self.command_callback = command_callback
        self.is_listening = False
        self.input_thread = None
        
    def start_listening(self):
        self.is_listening = True
        self.input_thread = threading.Thread(target=self._input_loop, daemon=True)
        self.input_thread.start()
        print("[TEXT] –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω. –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:")
        return True
        
    def stop_listening(self):
        self.is_listening = False
        
    def _input_loop(self):
        while self.is_listening:
            try:
                user_input = input("> ").strip()
                if user_input and self.command_callback:
                    self.command_callback(user_input, is_conversation=True)
            except EOFError:
                break
            except Exception as e:
                print(f"[TEXT] –û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞: {e}")
                time.sleep(1)
</file>

<file path="src/windows_audio.py">
import os
import sys
import subprocess
from typing import Optional, List, Dict

class WindowsAudioController:
    def __init__(self):
        self.is_windows = sys.platform == 'win32'
        self.pycaw_available = False
        
        if self.is_windows:
            try:
                from pycaw.pycaw import AudioUtilities, ISimpleAudioVolume
                from comtypes import CLSCTX_ALL
                from pycaw.pycaw import IAudioEndpointVolume
                self.pycaw_available = True
            except ImportError:
                print("[AUDIO] pycaw –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ Windows")
                print("[AUDIO] –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install pycaw")
                
    def get_running_apps(self) -> List[Dict]:
        if not self.is_windows or not self.pycaw_available:
            return self._get_mock_apps()
            
        try:
            from pycaw.pycaw import AudioUtilities
            
            sessions = AudioUtilities.GetAllSessions()
            apps = []
            
            for session in sessions:
                if session.Process:
                    apps.append({
                        'name': session.Process.name(),
                        'pid': session.Process.pid,
                        'session': session
                    })
                    
            return apps
            
        except Exception as e:
            print(f"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π: {e}")
            return []
            
    def _get_mock_apps(self) -> List[Dict]:
        return [
            {'name': 'Yandex Music (mock)', 'pid': 0, 'volume': 1.0},
            {'name': 'Spotify (mock)', 'pid': 0, 'volume': 1.0},
            {'name': 'Discord (mock)', 'pid': 0, 'volume': 1.0},
            {'name': 'Chrome (mock)', 'pid': 0, 'volume': 1.0}
        ]
        
    def set_app_volume(self, app_name: str, volume: float) -> bool:
        volume = max(0.0, min(1.0, volume))
        
        if not self.is_windows or not self.pycaw_available:
            print(f"[AUDIO] (Mock) –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≥—Ä–æ–º–∫–æ—Å—Ç—å {app_name}: {int(volume * 100)}%")
            return True
            
        try:
            from pycaw.pycaw import AudioUtilities
            
            sessions = AudioUtilities.GetAllSessions()
            
            for session in sessions:
                if session.Process and app_name.lower() in session.Process.name().lower():
                    volume_interface = session._ctl.QueryInterface(
                        __import__('pycaw.pycaw', fromlist=['ISimpleAudioVolume']).ISimpleAudioVolume
                    )
                    volume_interface.SetMasterVolume(volume, None)
                    print(f"[AUDIO] –ì—Ä–æ–º–∫–æ—Å—Ç—å {session.Process.name()}: {int(volume * 100)}%")
                    return True
                    
            print(f"[AUDIO] –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ '{app_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            return False
            
        except Exception as e:
            print(f"[AUDIO] –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}")
            return False
            
    def get_app_volume(self, app_name: str) -> Optional[float]:
        if not self.is_windows or not self.pycaw_available:
            return 1.0
            
        try:
            from pycaw.pycaw import AudioUtilities, ISimpleAudioVolume
            
            sessions = AudioUtilities.GetAllSessions()
            
            for session in sessions:
                if session.Process and app_name.lower() in session.Process.name().lower():
                    volume_interface = session._ctl.QueryInterface(ISimpleAudioVolume)
                    return volume_interface.GetMasterVolume()
                    
            return None
            
        except Exception as e:
            print(f"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}")
            return None
            
    def mute_app(self, app_name: str) -> bool:
        return self.set_app_volume(app_name, 0.0)
        
    def unmute_app(self, app_name: str, volume: float = 1.0) -> bool:
        return self.set_app_volume(app_name, volume)
        
    def set_master_volume(self, volume: float) -> bool:
        volume = max(0.0, min(1.0, volume))
        
        if not self.is_windows:
            print(f"[AUDIO] (Mock) –°–∏—Å—Ç–µ–º–Ω–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: {int(volume * 100)}%")
            return True
            
        if not self.pycaw_available:
            try:
                nircmd_volume = int(volume * 65535)
                subprocess.run(['nircmd', 'setsysvolume', str(nircmd_volume)], check=True)
                return True
            except:
                pass
                
        try:
            from pycaw.pycaw import AudioUtilities
            from comtypes import CLSCTX_ALL
            from pycaw.pycaw import IAudioEndpointVolume
            
            devices = AudioUtilities.GetSpeakers()
            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
            volume_interface = interface.QueryInterface(IAudioEndpointVolume)
            volume_interface.SetMasterVolumeLevelScalar(volume, None)
            
            print(f"[AUDIO] –°–∏—Å—Ç–µ–º–Ω–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: {int(volume * 100)}%")
            return True
            
        except Exception as e:
            print(f"[AUDIO] –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–∏—Å—Ç–µ–º–Ω–æ–π –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}")
            return False
            
    def get_master_volume(self) -> Optional[float]:
        if not self.is_windows or not self.pycaw_available:
            return 1.0
            
        try:
            from pycaw.pycaw import AudioUtilities
            from comtypes import CLSCTX_ALL
            from pycaw.pycaw import IAudioEndpointVolume
            
            devices = AudioUtilities.GetSpeakers()
            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
            volume_interface = interface.QueryInterface(IAudioEndpointVolume)
            
            return volume_interface.GetMasterVolumeLevelScalar()
            
        except Exception as e:
            print(f"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–Ω–æ–π –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}")
            return None

    def parse_volume_command(self, command: str) -> Dict:
        command = command.lower()
        
        result = {
            'action': None,
            'app': None,
            'volume': None
        }
        
        app_keywords = {
            '–º—É–∑—ã–∫': ['yandex', 'spotify', '–º—É–∑—ã–∫'],
            '—è–Ω–¥–µ–∫—Å': ['yandex'],
            'spotify': ['spotify'],
            '–¥–∏—Å–∫–æ—Ä–¥': ['discord'],
            'discord': ['discord'],
            '–±—Ä–∞—É–∑–µ—Ä': ['chrome', 'firefox', 'browser', 'edge'],
            '—Ö—Ä–æ–º': ['chrome'],
            'chrome': ['chrome']
        }
        
        for keyword, apps in app_keywords.items():
            if keyword in command:
                result['app'] = apps[0]
                break
                
        if '—Ç–∏—à–µ' in command or '—É–±–∞–≤' in command or '–ø–æ–Ω–∏–∑—å' in command:
            result['action'] = 'decrease'
            result['volume'] = 0.3
        elif '–≥—Ä–æ–º—á–µ' in command or '–ø—Ä–∏–±–∞–≤' in command or '–ø–æ–≤—ã—Å—å' in command:
            result['action'] = 'increase'
            result['volume'] = 0.7
        elif '–≤—ã–∫–ª—é—á' in command or '–∑–∞–º—É—Ç' in command or 'mute' in command:
            result['action'] = 'mute'
            result['volume'] = 0.0
        elif '–≤–∫–ª—é—á' in command or '—Ä–∞–∑–º—É—Ç' in command or 'unmute' in command:
            result['action'] = 'unmute'
            result['volume'] = 1.0
        elif any(word in command for word in ['50%', '–ø–æ–ª–æ–≤–∏–Ω', '—Å—Ä–µ–¥–Ω']):
            result['action'] = 'set'
            result['volume'] = 0.5
        elif any(word in command for word in ['100%', '–º–∞–∫—Å–∏–º', '–ø–æ–ª–Ω']):
            result['action'] = 'set'
            result['volume'] = 1.0
        elif any(word in command for word in ['25%', '—á–µ—Ç–≤–µ—Ä—Ç—å']):
            result['action'] = 'set'
            result['volume'] = 0.25
            
        return result
        
    def execute_voice_command(self, command: str) -> str:
        parsed = self.parse_volume_command(command)
        
        if not parsed['action']:
            return "–ù–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –°–∫–∞–∂–∏ –Ω–∞–ø—Ä–∏–º–µ—Ä: '—Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ' –∏–ª–∏ '–≤—ã–∫–ª—é—á–∏ –¥–∏—Å–∫–æ—Ä–¥'"
            
        if parsed['app']:
            if parsed['action'] == 'mute':
                success = self.mute_app(parsed['app'])
                return f"{'–í—ã–∫–ª—é—á–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ –≤—ã–∫–ª—é—á–∏—Ç—å'} {parsed['app']}"
            elif parsed['action'] == 'unmute':
                success = self.unmute_app(parsed['app'])
                return f"{'–í–∫–ª—é—á–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ –≤–∫–ª—é—á–∏—Ç—å'} {parsed['app']}"
            else:
                success = self.set_app_volume(parsed['app'], parsed['volume'])
                percent = int(parsed['volume'] * 100)
                return f"{'–£—Å—Ç–∞–Ω–æ–≤–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å'} –≥—Ä–æ–º–∫–æ—Å—Ç—å {parsed['app']} –Ω–∞ {percent}%"
        else:
            if parsed['action'] == 'mute':
                success = self.set_master_volume(0.0)
                return "–í—ã–∫–ª—é—á–∏–ª–∞ –∑–≤—É–∫" if success else "–ù–µ —Å–º–æ–≥–ª–∞ –≤—ã–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫"
            elif parsed['action'] == 'unmute':
                success = self.set_master_volume(1.0)
                return "–í–∫–ª—é—á–∏–ª–∞ –∑–≤—É–∫" if success else "–ù–µ —Å–º–æ–≥–ª–∞ –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫"
            else:
                success = self.set_master_volume(parsed['volume'])
                percent = int(parsed['volume'] * 100)
                return f"{'–£—Å—Ç–∞–Ω–æ–≤–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å'} —Å–∏—Å—Ç–µ–º–Ω—É—é –≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ {percent}%"
</file>

<file path="temp_repo/.replit">
modules = ["python-3.11"]
[agent]
expertMode = true
integrations = ["python_openai:1.0.0", "web_scraper:1.0.0"]

[nix]
channel = "stable-25_05"
packages = ["SDL2", "SDL2_image", "SDL2_mixer", "SDL2_ttf", "fontconfig", "freetype", "libjpeg", "libpng", "libxcrypt", "pkg-config", "portmidi", "xsimd"]

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Iris Assistant"

[[workflows.workflow]]
name = "Iris Assistant"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "python main.py"
waitForPort = 3000

[workflows.workflow.metadata]
outputType = "console"

[[ports]]
localPort = 3000
externalPort = 3000
</file>

<file path="test_tts_sound.py">
# test_tts_sound.py
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src.tts_engine import TTSEngine
import time

print("üîä –¢–µ—Å—Ç –∑–≤—É–∫–∞ TTS...")

def test_callback(speaking, intensity):
    print(f"[VISUAL] –ì–æ–≤–æ—Ä–∏—Ç: {speaking}, –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å: {intensity}")

try:
    # –¢–µ—Å—Ç 1: –ü—Ä–æ—Å—Ç–æ–π TTS
    print("–¢–µ—Å—Ç 1: –ë–∞–∑–æ–≤—ã–π TTS...")
    tts = TTSEngine(visual_callback=test_callback)
    tts.start()
    tts.speak("–ü—Ä–∏–≤–µ—Ç! –¢–µ—Å—Ç –∑–≤—É–∫–∞ –æ–¥–∏–Ω –¥–≤–∞ —Ç—Ä–∏.", emotion='neutral')
    time.sleep(5)
    tts.stop()
    
    # –¢–µ—Å—Ç 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤ pygame
    print("\n–¢–µ—Å—Ç 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ pygame...")
    import pygame
    pygame.mixer.init()
    print(f"PyAudio —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {pygame.mixer.get_num_channels()}")
    
    # –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ Edge TTS
    print("\n–¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ Edge TTS...")
    import edge_tts
    import asyncio
    
    async def test_edge_tts():
        voices = await edge_tts.VoicesManager.create()
        voice = voices.find(Gender="Female", Language="ru")
        print(f"–ù–∞–π–¥–µ–Ω –≥–æ–ª–æ—Å: {voice['Name'] if voice else '–ù–µ—Ç'}")
    
    asyncio.run(test_edge_tts())
    
except Exception as e:
    print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
    import traceback
    traceback.print_exc()

print("\n‚úÖ –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω")
</file>

<file path="test_tts.py">
# test_tts.py
import sys
import os

# –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –≤ –ø—É—Ç—å
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    from src.tts_engine import TTSEngine
    print("‚úì –ò–º–ø–æ—Ä—Ç TTSEngine —É—Å–ø–µ—à–µ–Ω!")
    
    # –ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç
    def test_callback(speaking, intensity):
        status = "–ì–û–í–û–†–ò–¢" if speaking else "–ú–û–õ–ß–ò–¢"
        print(f"[CALLBACK] {status} (–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å: {intensity:.2f})")
    
    tts = TTSEngine(visual_callback=test_callback)
    tts.start()
    
    print("–¢–µ—Å—Ç 1: –ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è —Ñ—Ä–∞–∑–∞...")
    tts.speak("–ü—Ä–∏–≤–µ—Ç, –º–∏—Ä! –≠—Ç–æ —Ç–µ—Å—Ç TTS —Å–∏—Å—Ç–µ–º—ã.", emotion='neutral')
    
    import time
    time.sleep(5)
    
    print("–¢–µ—Å—Ç 2: –†–∞–¥–æ—Å—Ç–Ω–∞—è —Ñ—Ä–∞–∑–∞...")
    tts.speak("–£—Ä–∞! –í—Å—ë —Ä–∞–±–æ—Ç–∞–µ—Ç –æ—Ç–ª–∏—á–Ω–æ!", emotion='happy')
    
    time.sleep(5)
    
    tts.stop()
    print("‚úì –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ!")
    
except SyntaxError as e:
    print(f"‚úó –°–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ tts_engine.py: {e}")
    print("–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—Å–µ –∫–∞–≤—ã—á–∫–∏ –∑–∞–∫—Ä—ã—Ç—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ.")
except ImportError as e:
    print(f"‚úó –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {e}")
    print("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: pip install edge-tts pygame")
except Exception as e:
    print(f"‚úó –û–±—â–∞—è –æ—à–∏–±–∫–∞: {e}")
    import traceback
    traceback.print_exc()
</file>

<file path="test_vosk.py">
import os
import sys

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –º–æ–¥–µ–ª–∏
model_path = "models/vosk-model-ru-0.22"
if os.path.exists(model_path):
    print(f"‚úÖ –ú–æ–¥–µ–ª—å –Ω–∞–π–¥–µ–Ω–∞: {model_path}")
    print(f"   –†–∞–∑–º–µ—Ä –ø–∞–ø–∫–∏: {sum(os.path.getsize(os.path.join(dirpath, filename)) 
    for dirpath, dirnames, filenames in os.walk(model_path) 
    for filename in filenames) / (1024**3):.2f} –ì–ë")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
    print("\nüìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥–µ–ª–∏:")
    for root, dirs, files in os.walk(model_path):
        level = root.replace(model_path, '').count(os.sep)
        indent = ' ' * 2 * level
        print(f'{indent}{os.path.basename(root)}/')
        subindent = ' ' * 2 * (level + 1)
        for file in files[:5]:  # –ü–µ—Ä–≤—ã–µ 5 —Ñ–∞–π–ª–æ–≤
            print(f'{subindent}{file}')
        if len(files) > 5:
            print(f'{subindent}... –∏ –µ—â–µ {len(files) - 5} —Ñ–∞–π–ª–æ–≤')
        break  # –¢–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π —É—Ä–æ–≤–µ–Ω—å
else:
    print(f"‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {model_path}")
    print("\nüîç –ò—â–µ–º –º–æ–¥–µ–ª—å...")
    possible_paths = [
        "vosk-model-ru-0.22",
        "models/vosk-model-ru-0.22",
        os.path.expanduser("~/vosk-model-ru-0.22"),
        "C:/vosk-model-ru-0.22",
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            print(f"‚úÖ –ù–∞–π–¥–µ–Ω–∞ –≤: {path}")
            # –°–æ–∑–¥–∞–µ–º —Å–∏–º–ª–∏–Ω–∫ –∏–ª–∏ –∫–æ–ø–∏—Ä—É–µ–º
            os.makedirs("models", exist_ok=True)
            print(f"üìÅ –ö–æ–ø–∏—Ä—É–µ–º –≤ models/...")
            import shutil
            try:
                shutil.copytree(path, "models/vosk-model-ru-0.22", dirs_exist_ok=True)
                print("‚úÖ –ú–æ–¥–µ–ª—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞")
                break
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
</file>

<file path="voice_stats.json">
{
  "timestamp": 1766190666.0642102,
  "stats": {
    "total_phrases": 0,
    "wake_detected": 0,
    "vosk_success": 0,
    "google_success": 0,
    "avg_confidence": 0.0,
    "last_recognition": "",
    "audio_quality": 0.9969171007474263
  },
  "settings": {
    "wake_word": "–∏—Ä–∏—Å",
    "sensitivity": 0.75,
    "mode": "hybrid",
    "sample_rate": 16000
  },
  "recent_history": []
}
</file>

<file path=".env.example">
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IRIS - AI Assistant Configuration Example
# Copy values to .env (Windows) or Replit Secrets (cloud)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# OLLAMA - Local LLM (REQUIRED)
OLLAMA_URL=http://localhost:11434
OLLAMA_MODEL=qwen3:4b-instruct

# Voice & Speech (RECOMMENDED)
VOICE_ENABLED=true
WAKE_WORD=–∏—Ä–∏—Å
TTS_ENGINE=edge-tts
TTS_VOICE=ru_female_soft
TTS_VOLUME=0.9
LOG_LEVEL=INFO

# CS2 Game State Integration
CS2_GSI_PORT=3000

# StreamElements Chat Integration (OPTIONAL)
# Get token at: https://streamelements.com/dashboard/account/settings
# On Replit: Add as SECRET via Secrets tab
STREAMELEMENTS_JWT_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjaXRhZGVsIiwiZXhwIjoxNzgxNDUzNDYwLCJqdGkiOiJjYzM3ZjUwNS1lNGRkLTQxZjktOGIwZS1lNTNhZjUzM2M0ODIiLCJjaGFubmVsIjoiNjk0MTg0OTNjMjdmNzk4NGQ1Y2UwNmNkIiwicm9sZSI6Im93bmVyIiwiYXV0aFRva2VuIjoiMVdQckRUYUZUN21mc3RHSlNfZFpxV3NtNmlicFhYeGdDbmdjcThpeHlCbG9HTXpVIiwidXNlciI6IjY5NDE4NDkzYzI3Zjc5ODRkNWNlMDZjYyIsInVzZXJfaWQiOiIwYjhiZTJhZS1kNjIyLTRlNGEtODdmMy01NjJhYTcxMGM5YWYiLCJ1c2VyX3JvbGUiOiJjcmVhdG9yIiwicHJvdmlkZXIiOiJ0d2l0Y2giLCJwcm92aWRlcl9pZCI6IjE4NzU3MjUyNyIsImNoYW5uZWxfaWQiOiJlMjU4YzczZS04ZTgxLTQyNzktOGNjMS0wZWI2OTE2ZmIyMDMiLCJjcmVhdG9yX2lkIjoiNGQ4Zjk5YzktMGE3OC00YjlkLWJlNWEtZjVmNDY2ZGMyZjk4In0.UDj-xNNlOjOplW8gliL0-cb9S8_rnuCZaQCpLUvMq1o

# Groq API (OPTIONAL - Fallback for AI)
# Get key at: https://console.groq.com
GROQ_API_KEY=your_key_here

# System Settings
PERSONALITY=jarvis           # jarvis, funny, serious, helpful
RESPONSE_SPEED=fast          # fast, normal, thoughtful
DEBUG=false                  # Detailed logging
</file>

<file path="gamestate_integration_iris.cfg">
"Iris Stream Assistant v2.1"
{
	"uri" "http://localhost:3000/"
	"timeout" "5.0"
	"buffer"  "0.1"
	"throttle" "0.1"
	"heartbeat" "10.0"
	
	"auth"
	{
		"token" "iris_stream_assistant"
	}
	
	"data"
	{
		"provider"              "1"
		"match_stats"           "1"
		"player_id"             "1"
		"player_state"          "1"
		"player_match_stats"    "1"
		"player_weapons"        "1"
		"player_position"       "1"
		"round"                 "1"
		"phase_countdowns"      "1"
		"bomb"                  "1"
		"map"                   "1"
		"map_round_wins"        "1"
		"allplayers_id"         "1"
		"allplayers_state"      "1"
		"allplayers_match_stats"    "1"
		"allplayers_weapons"        "1"
		"allplayers_position"       "1"
		"allgrenades"           "1"
	}
}
</file>

<file path="src/__init__.py">
from .voice_recognition import VoiceRecognition, TextInputFallback
from .cs2_gsi import CS2GameStateIntegration, GameEvent
from .streamelements_client import StreamElementsClient, StreamEvent
from .iris_core.brain import IrisBrain
from .windows_audio import WindowsAudioController
from .achievements import AchievementSystem, Achievement, StreamStats

__all__ = [
    'TTSEngine',
    'VoiceRecognition', 
    'TextInputFallback',
    'CS2GameStateIntegration',
    'GameEvent',
    'StreamElementsClient',
    'StreamEvent',
    'IrisBrain',
    'WindowsAudioController',
    'AchievementSystem',
    'Achievement',
    'StreamStats'
]
</file>

<file path="src/cs2_gsi.py">
import json
import time
import threading
from flask import Flask, request, jsonify
from dataclasses import dataclass, field
from typing import Optional, Callable, Dict, List, Any, Tuple
from collections import deque

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# DATACLASSES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class PlayerState:
    name: str = ""
    team: str = ""
    health: int = 100
    armor: int = 0
    helmet: bool = False
    money: int = 0
    round_kills: int = 0
    round_killhs: int = 0
    equip_value: int = 0
    kills: int = 0
    assists: int = 0
    deaths: int = 0
    mvps: int = 0
    score: int = 0
    weapon: str = ""
    
    # ‚úÖ –ù–û–í–´–ï –ü–û–õ–Ø –î–õ–Ø REAL-TIME –ò–ù–§–û–†–ú–ê–¶–ò–ò
    ammo_in_magazine: int = 0          # –ü–∞—Ç—Ä–æ–Ω—ã –≤ –º–∞–≥–∞–∑–∏–Ω–µ
    ammo_in_reserve: int = 0           # –ü–∞—Ç—Ä–æ–Ω—ã –≤ —Ä–µ–∑–µ—Ä–≤–µ
    defuse_kit: bool = False           # –ï—Å—Ç—å –ª–∏ –∫–∏—Ç –¥–µ—Ñ—å—é–∑–∞
    has_bomb: bool = False             # –ï—Å—Ç—å –ª–∏ –±–æ–º–±–∞
    fatigue: int = 100                 # –£—Å—Ç–∞–ª–æ—Å—Ç—å (0-100)
    
    # ‚úÖ –ö–û–û–†–î–ò–ù–ê–¢–´ –ù–ê –ö–ê–†–¢–ï
    position: Tuple[float, float] = (0, 0)  # (x, y)
    position_z: float = 0.0            # z –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ (–≤—ã—Å–æ—Ç–∞)
    
    # ‚úÖ –í–†–ï–ú–ï–ù–ê –û–ë–ù–û–í–õ–ï–ù–ò–ô
    last_health_update_time: float = 0
    last_ammo_warning_time: float = 0

@dataclass
class RoundState:
    phase: str = ""
    bomb: str = ""
    win_team: str = ""

@dataclass
class MapState:
    name: str = ""
    mode: str = ""
    phase: str = ""
    round: int = 0
    ct_score: int = 0
    t_score: int = 0

@dataclass
class GameEvent:
    event_type: str
    data: Dict[str, Any]
    timestamp: float = field(default_factory=time.time)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ì–õ–ê–í–ù–´–ô –ö–õ–ê–°–° GSI
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class CS2GameStateIntegration:
    def __init__(self,
                 port: int = 3000,
                 event_callback: Optional[Callable[[GameEvent], None]] = None):
        self.port = port
        self.event_callback = event_callback
        self.player = PlayerState()
        self.round = RoundState()
        self.map = MapState()
        self.previous_state: Dict = {}
        self.events_history: deque = deque(maxlen=100)
        self.kill_streak = 0
        self.round_start_kills = 0
        self.clutch_situation = False
        self.clutch_enemies = 0
        
        # ‚úÖ –ù–û–í–´–ï –ü–û–õ–Ø –î–õ–Ø FULL DATA TRACKING
        self.all_grenades: List[Dict] = []          # –í–°–ï –ì–†–ï–ù–ê–î–´ –í –ò–ì–†–ï
        self.all_players_positions: Dict = {}       # –ü–û–ó–ò–¶–ò–ò –í–°–ï–• –í–†–ê–ì–û–í {steamid: {x, y, z}}
        self.all_players_states: Dict = {}          # –°–¢–ê–¢–£–° –í–°–ï–• {steamid: {alive, team}}
        self.phase_countdown: float = 0.0           # –í–†–ï–ú–Ø –û–°–¢–ê–í–®–ï–ï–°–Ø –í –†–ê–£–ù–î–ï
        
        self.app = Flask(__name__)
        self._setup_routes()
        self.server_thread = None
        self.is_running = False

    def _setup_routes(self):
        @self.app.route('/', methods=['POST'])
        def gsi_handler():
            try:
                data = request.get_json()
                if data:
                    self._process_game_state(data)
                return jsonify({"status": "ok"})
            except Exception as e:
                print(f"[CS2 GSI] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
                return jsonify({"status": "error"}), 500

        @self.app.route('/health', methods=['GET'])
        def health_check():
            return jsonify({
                "status": "running",
                "player": self.player.name,
                "map": self.map.name,
                "round": self.map.round
            })

    def _process_game_state(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã —Å –ø–æ–ª–Ω—ã–º —Å–±–æ—Ä–æ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # –û–ë–†–ê–ë–û–¢–ö–ê –ò–ì–†–û–ö–ê
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        player_data = data.get('player', {})
        if player_data:
            state = player_data.get('state', {})
            match_stats = player_data.get('match_stats', {})
            weapons = player_data.get('weapons', {})
            position_data = player_data.get('position', {})  # ‚úÖ –ü–û–ó–ò–¶–ò–Ø
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
            old_health = self.player.health
            old_kills = self.player.kills
            old_deaths = self.player.deaths
            old_round_kills = self.player.round_kills
            old_ammo = (self.player.ammo_in_magazine + self.player.ammo_in_reserve)
            
            # ‚úÖ –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            self.player.name = player_data.get('name', self.player.name)
            self.player.team = player_data.get('team', self.player.team)
            self.player.health = state.get('health', self.player.health)
            self.player.armor = state.get('armor', self.player.armor)
            self.player.helmet = state.get('helmet', self.player.helmet)
            self.player.money = state.get('money', self.player.money)
            self.player.round_kills = state.get('round_kills', self.player.round_kills)
            self.player.round_killhs = state.get('round_killhs', self.player.round_killhs)
            self.player.equip_value = state.get('equip_value', self.player.equip_value)
            
            # ‚úÖ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –º–∞—Ç—á–∞
            self.player.kills = match_stats.get('kills', self.player.kills)
            self.player.assists = match_stats.get('assists', self.player.assists)
            self.player.deaths = match_stats.get('deaths', self.player.deaths)
            self.player.mvps = match_stats.get('mvps', self.player.mvps)
            self.player.score = match_stats.get('score', self.player.score)
            
            # ‚úÖ –û—Ä—É–∂–∏–µ –∏ –ø–∞—Ç—Ä–æ–Ω—ã
            for weapon_key, weapon_data in weapons.items():
                if weapon_data.get('state') == 'active':
                    self.player.weapon = weapon_data.get('name', '')
                    self.player.ammo_in_magazine = weapon_data.get('ammo_clip', 0)
                    self.player.ammo_in_reserve = weapon_data.get('ammo_clip_reserve', 0)
                    break
            
            # ‚úÖ –ù–û–í–û–ï: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            self.player.defuse_kit = state.get('defusekit', False)
            self.player.has_bomb = state.get('bomb', False)
            self.player.fatigue = state.get('fatigue', 100)
            self.player.last_health_update_time = time.time()
            
            # ‚úÖ –ù–û–í–û–ï: –ü–û–ó–ò–¶–ò–Ø –ù–ê –ö–ê–†–¢–ï
            if position_data:
                self.player.position = (
                    position_data.get('x', 0),
                    position_data.get('y', 0)
                )
                self.player.position_z = position_data.get('z', 0)
            
            # ‚úÖ –°–û–ë–´–¢–ò–Ø
            new_ammo = (self.player.ammo_in_magazine + self.player.ammo_in_reserve)
            if new_ammo < old_ammo and new_ammo <= 10 and new_ammo > 0:
                if time.time() - self.player.last_ammo_warning_time > 3.0:
                    self._emit_event('low_ammo_warning', {
                        'ammo_magazine': self.player.ammo_in_magazine,
                        'ammo_reserve': self.player.ammo_in_reserve,
                        'total_ammo': new_ammo,
                        'weapon': self.player.weapon
                    })
                    self.player.last_ammo_warning_time = time.time()
            
            if self.player.kills > old_kills:
                self._emit_kill_event(self.player.kills - old_kills)
            
            if self.player.deaths > old_deaths:
                self._emit_death_event()
            
            if self.player.health < old_health and self.player.health > 0:
                self._emit_damage_event(old_health - self.player.health)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # –û–ë–†–ê–ë–û–¢–ö–ê –†–ê–£–ù–î–ê
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        round_data = data.get('round', {})
        if round_data:
            old_phase = self.round.phase
            old_bomb = self.round.bomb
            self.round.phase = round_data.get('phase', self.round.phase)
            self.round.bomb = round_data.get('bomb', self.round.bomb)
            self.round.win_team = round_data.get('win_team', self.round.win_team)
            
            if self.round.phase == 'freezetime' and old_phase != 'freezetime':
                self._emit_round_start_event()
            
            if self.round.phase == 'over' and old_phase != 'over':
                self._emit_round_end_event()
            
            if self.round.bomb == 'planted' and old_bomb != 'planted':
                self._emit_bomb_planted_event()
            
            if self.round.bomb == 'defused' and old_bomb != 'defused':
                self._emit_bomb_defused_event()
            
            if self.round.bomb == 'exploded' and old_bomb != 'exploded':
                self._emit_bomb_exploded_event()
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # –û–ë–†–ê–ë–û–¢–ö–ê –ö–ê–†–¢–´ –ò –ú–ê–¢–ß–ê
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        map_data = data.get('map', {})
        if map_data:
            old_round = self.map.round
            self.map.name = map_data.get('name', self.map.name)
            self.map.mode = map_data.get('mode', self.map.mode)
            self.map.phase = map_data.get('phase', self.map.phase)
            self.map.round = map_data.get('round', self.map.round)
            team_ct = map_data.get('team_ct', {})
            team_t = map_data.get('team_t', {})
            self.map.ct_score = team_ct.get('score', self.map.ct_score)
            self.map.t_score = team_t.get('score', self.map.t_score)
            
            if self.map.phase == 'gameover':
                self._emit_match_end_event()
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ù–û–í–û–ï: –û–ë–†–ê–ë–û–¢–ö–ê –í–°–ï–• –ò–ì–†–û–ö–û–í –ò –ò–• –ü–û–ó–ò–¶–ò–ô
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        all_players_data = data.get('allplayers', {})
        if all_players_data:
            self.all_players_positions = {}
            self.all_players_states = {}
            
            for steamid, player_info in all_players_data.items():
                if steamid == self.player.name:  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–µ–±—è
                    continue
                
                # –ü–æ–∑–∏—Ü–∏–∏ –≤—Ä–∞–≥–æ–≤
                position = player_info.get('position', {})
                self.all_players_positions[steamid] = {
                    'x': position.get('x', 0),
                    'y': position.get('y', 0),
                    'z': position.get('z', 0),
                    'team': player_info.get('team', 'unknown'),
                    'name': player_info.get('name', 'unknown')
                }
                
                # –°—Ç–∞—Ç—É—Å –≤—Å–µ—Ö
                state = player_info.get('state', {})
                self.all_players_states[steamid] = {
                    'alive': state.get('health', 0) > 0,
                    'health': state.get('health', 0),
                    'team': player_info.get('team', 'unknown'),
                    'name': player_info.get('name', 'unknown')
                }
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ù–û–í–û–ï: –û–ë–†–ê–ë–û–¢–ö–ê –ì–†–ï–ù–ê–î
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        all_grenades_data = data.get('allgrenades', {})
        if all_grenades_data:
            self.all_grenades = []
            for grenade_id, grenade_info in all_grenades_data.items():
                self.all_grenades.append({
                    'type': grenade_info.get('type', 'unknown'),
                    'position': {
                        'x': grenade_info.get('position', {}).get('x', 0),
                        'y': grenade_info.get('position', {}).get('y', 0),
                        'z': grenade_info.get('position', {}).get('z', 0)
                    },
                    'team': grenade_info.get('team', 'unknown'),
                    'owner': grenade_info.get('owner', 'unknown')
                })
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ù–û–í–û–ï: –û–ë–†–ê–ë–û–¢–ö–ê –í–†–ï–ú–ï–ù–ò –†–ê–£–ù–î–ê
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        phase_countdowns = data.get('phase_countdowns', {})
        if phase_countdowns:
            # phase_countdowns —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–∑–Ω—ã—Ö —Ñ–∞–∑
            self.phase_countdown = phase_countdowns.get('phase', 0)
        
        # ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ
        self.previous_state = data

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # EMITTERS (–°–û–ë–´–¢–ò–Ø)
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _emit_event(self, event_type: str, data: Dict = None):
        event = GameEvent(event_type=event_type, data=data or {})
        self.events_history.append(event)
        if self.event_callback:
            try:
                self.event_callback(event)
            except Exception as e:
                print(f"[CS2 GSI] –û—à–∏–±–∫–∞ callback: {e}")

    def _emit_kill_event(self, kill_count: int):
        self.kill_streak += kill_count
        event_data = {
            'kills_this_action': kill_count,
            'round_kills': self.player.round_kills,
            'total_kills': self.player.kills,
            'kill_streak': self.kill_streak,
            'headshot': self.player.round_killhs > 0,
            'weapon': self.player.weapon,
            'clutch': self.clutch_situation,
            'clutch_enemies': self.clutch_enemies
        }
        
        if self.player.round_kills >= 5:
            event_data['ace'] = True
            self._emit_event('ace', event_data)
        elif self.player.round_kills >= 4:
            self._emit_event('quadra_kill', event_data)
        elif self.player.round_kills >= 3:
            self._emit_event('triple_kill', event_data)
        elif self.player.round_kills >= 2:
            self._emit_event('double_kill', event_data)
        else:
            self._emit_event('kill', event_data)

    def _emit_death_event(self):
        self.kill_streak = 0
        event_data = {
            'total_deaths': self.player.deaths,
            'kd_ratio': self.player.kills / max(1, self.player.deaths),
            'round': self.map.round
        }
        self._emit_event('death', event_data)

    def _emit_damage_event(self, damage: int):
        event_data = {
            'damage': damage,
            'current_health': self.player.health,
            'armor': self.player.armor
        }
        
        if self.player.health <= 25:
            self._emit_event('low_health', event_data)
        elif damage >= 50:
            self._emit_event('heavy_damage', event_data)

    def _emit_round_start_event(self):
        self.kill_streak = 0
        self.round_start_kills = self.player.kills
        self.clutch_situation = False
        event_data = {
            'round': self.map.round,
            'ct_score': self.map.ct_score,
            't_score': self.map.t_score,
            'money': self.player.money,
            'equip_value': self.player.equip_value
        }
        
        if self.player.money < 2000:
            event_data['eco_round'] = True
        
        self._emit_event('round_start', event_data)

    def _emit_round_end_event(self):
        round_kills = self.player.kills - self.round_start_kills
        event_data = {
            'round': self.map.round,
            'win_team': self.round.win_team,
            'player_team': self.player.team,
            'won': self.round.win_team.lower() == self.player.team.lower() if self.round.win_team else False,
            'round_kills': round_kills,
            'clutch_win': self.clutch_situation and round_kills > 0
        }
        
        if round_kills >= 3:
            event_data['mvp_candidate'] = True
        
        self._emit_event('round_end', event_data)

    def _emit_bomb_planted_event(self):
        event_data = {
            'round': self.map.round,
            'player_team': self.player.team
        }
        self._emit_event('bomb_planted', event_data)

    def _emit_bomb_defused_event(self):
        event_data = {
            'round': self.map.round,
            'player_team': self.player.team,
            'ninja_defuse': self.player.health <= 10
        }
        self._emit_event('bomb_defused', event_data)

    def _emit_bomb_exploded_event(self):
        event_data = {
            'round': self.map.round,
            'player_team': self.player.team
        }
        self._emit_event('bomb_exploded', event_data)

    def _emit_match_end_event(self):
        event_data = {
            'ct_score': self.map.ct_score,
            't_score': self.map.t_score,
            'player_team': self.player.team,
            'won': (self.player.team == 'CT' and self.map.ct_score > self.map.t_score) or
                   (self.player.team == 'T' and self.map.t_score > self.map.ct_score),
            'kills': self.player.kills,
            'deaths': self.player.deaths,
            'assists': self.player.assists,
            'mvps': self.player.mvps,
            'map': self.map.name
        }
        self._emit_event('match_end', event_data)

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –£–ü–†–ê–í–õ–ï–ù–ò–ï –°–ï–†–í–ï–†–û–ú
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def start(self):
        if self.is_running:
            return
        
        self.is_running = True
        self.server_thread = threading.Thread(
            target=lambda: self.app.run(host='0.0.0.0', port=self.port, debug=False, use_reloader=False),
            daemon=True
        )
        self.server_thread.start()
        print(f"[CS2 GSI] –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {self.port}")

    def stop(self):
        self.is_running = False

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –ú–ï–¢–û–î–´ –ü–û–õ–£–ß–ï–ù–ò–Ø –ò–ù–§–û–†–ú–ê–¶–ò–ò
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def get_player_stats(self) -> Dict:
        return {
            'name': self.player.name,
            'team': self.player.team,
            'health': self.player.health,
            'armor': self.player.armor,
            'money': self.player.money,
            'kills': self.player.kills,
            'deaths': self.player.deaths,
            'assists': self.player.assists,
            'kd_ratio': round(self.player.kills / max(1, self.player.deaths), 2),
            'mvps': self.player.mvps,
            'score': self.player.score
        }

    def get_match_info(self) -> Dict:
        return {
            'map': self.map.name,
            'mode': self.map.mode,
            'round': self.map.round,
            'ct_score': self.map.ct_score,
            't_score': self.map.t_score,
            'phase': self.map.phase
        }

    # ‚úÖ –ù–û–í–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê

    def get_enemy_positions(self) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–∑–∏—Ü–∏–∏ –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤"""
        enemies = []
        for steamid, pos in self.all_players_positions.items():
            if pos['team'] != self.player.team:
                enemies.append(pos)
        return enemies

    def get_alive_enemies_count(self) -> int:
        """–°–∫–æ–ª—å–∫–æ –∂–∏–≤—ã—Ö –≤—Ä–∞–≥–æ–≤"""
        count = 0
        for steamid, state in self.all_players_states.items():
            if state['alive'] and state['team'] != self.player.team:
                count += 1
        return count

    def get_grenades_nearby(self, distance: float = 500) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –≥—Ä–µ–Ω–∞–¥—ã —Ä—è–¥–æ–º (–≤ –º–µ—Ç—Ä–∞—Ö)"""
        nearby = []
        for grenade in self.all_grenades:
            gx, gy = grenade['position']['x'], grenade['position']['y']
            px, py = self.player.position
            dist = ((gx - px)**2 + (gy - py)**2)**0.5
            if dist <= distance:
                nearby.append(grenade)
        return nearby

    def get_player_health_status(self) -> str:
        """–°—Ç–∞—Ç—É—Å –∑–¥–æ—Ä–æ–≤—å—è"""
        if self.player.health <= 1:
            return "critical"
        elif self.player.health <= 15:
            return "very_low"
        elif self.player.health <= 30:
            return "low"
        elif self.player.health <= 60:
            return "medium"
        else:
            return "healthy"

    def get_ammo_status(self) -> str:
        """–°—Ç–∞—Ç—É—Å –ø–∞—Ç—Ä–æ–Ω–æ–≤"""
        total = self.player.ammo_in_magazine + self.player.ammo_in_reserve
        if total == 0:
            return "empty"
        elif total <= 3:
            return "critical"
        elif total <= 10:
            return "low"
        elif total <= 30:
            return "medium"
        else:
            return "plenty"

    def analyze_threat_level(self) -> int:
        """–£—Ä–æ–≤–µ–Ω—å —É–≥—Ä–æ–∑—ã (1-10)"""
        threat = 5
        
        if self.player.health <= 15:
            threat += 5
        if (self.player.ammo_in_magazine + self.player.ammo_in_reserve) <= 5:
            threat += 2
        if self.player.money < 2000:
            threat += 1
        if self.get_alive_enemies_count() >= 3:
            threat += 2
        
        return min(threat, 10)

    def get_round_time_remaining(self) -> float:
        """–û—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è —Ä–∞—É–Ω–¥–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö"""
        return self.phase_countdown

    def generate_config_file(self) -> str:
        config = f'''\"Iris Stream Assistant v2.1\"
{{
	\"uri\" \"http://localhost:{self.port}/\"
	\"timeout\" \"5.0\"
	\"buffer\"  \"0.1\"
	\"throttle\" \"0.1\"
	\"heartbeat\" \"10.0\"
	
	\"auth\"
	{{
		\"token\" \"iris_stream_assistant\"
	}}
	
	\"data\"
	{{
		\"provider\"              \"1\"
		\"match_stats\"           \"1\"
		\"player_id\"             \"1\"
		\"player_state\"          \"1\"
		\"player_match_stats\"    \"1\"
		\"player_weapons\"        \"1\"
		\"player_position\"       \"1\"
		\"round\"                 \"1\"
		\"phase_countdowns\"      \"1\"
		\"bomb\"                  \"1\"
		\"map\"                   \"1\"
		\"map_round_wins\"        \"1\"
		\"allplayers_id\"         \"1\"
		\"allplayers_state\"      \"1\"
		\"allplayers_match_stats\"    \"1\"
		\"allplayers_weapons\"        \"1\"
		\"allplayers_position\"       \"1\"
		\"allgrenades\"           \"1\"
	}}
}}
'''
        return config

    def save_config_file(self, path: str = "gamestate_integration_iris.cfg"):
        config = self.generate_config_file()
        with open(path, 'w') as f:
            f.write(config)
        print(f"[CS2 GSI] –ö–æ–Ω—Ñ–∏–≥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {path}")
        print(f"[CS2 GSI] –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤: /steamapps/common/Counter-Strike Global Offensive/game/csgo/cfg/")
        return path
</file>

<file path="src/streamelements_client.py">
import os
import json
import time
import threading
import websocket
from dataclasses import dataclass, field
from typing import Optional, Callable, Dict, List, Any
from collections import deque

@dataclass
class StreamEvent:
    event_type: str
    data: Dict[str, Any]
    timestamp: float = field(default_factory=time.time)

class StreamElementsClient:
    WS_URL = "wss://realtime.streamelements.com/socket.io/?EIO=4&transport=websocket"
    
    def __init__(self, 
                 jwt_token: Optional[str] = None,
                 event_callback: Optional[Callable[[StreamEvent], None]] = None):
        
        self.jwt_token = jwt_token or os.getenv('STREAMELEMENTS_JWT_TOKEN', '')
        self.event_callback = event_callback
        
        self.ws = None
        self.is_connected = False
        self.reconnect_delay = 5
        self.max_reconnect_delay = 60
        
        self.events_history: deque = deque(maxlen=500)
        self.chat_history: deque = deque(maxlen=100)
        
        self.viewer_stats = {
            'total_tips': 0,
            'total_subs': 0,
            'total_followers': 0,
            'top_donator': None,
            'recent_events': []
        }
        
        self.ws_thread = None
        self.heartbeat_thread = None
        
    def connect(self):
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ StreamElements WebSocket"""
        try:
            print("[StreamElements] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...")
            
            if not self.jwt_token or self.jwt_token == "your_jwt_token_here":
                print("[StreamElements] ‚ö†Ô∏è JWT —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ")
                return
            
            self.ws = websocket.WebSocketApp(
                self.WS_URL,
                on_open=self._on_open,
                on_message=self._on_message,
                on_error=self._on_error,
                on_close=self._on_close
            )
            
            self.ws_thread = threading.Thread(target=self._run_forever, daemon=True)
            self.ws_thread.start()
            
            return True
            
        except Exception as e:
            print(f"[StreamElements] –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {e}")
            return False
        
    def _run_forever(self):
        """–ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è"""
        while True:
            try:
                self.ws.run_forever()
            except Exception as e:
                print(f"[StreamElements] –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {e}")
                
            if not self.is_connected:
                break
                
            print(f"[StreamElements] –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {self.reconnect_delay} —Å–µ–∫...")
            time.sleep(self.reconnect_delay)
            self.reconnect_delay = min(self.reconnect_delay * 2, self.max_reconnect_delay)
            
    def _on_open(self, ws):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        print("[StreamElements] WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ")
        self._authenticate()
        self._start_heartbeat()
        
    def _authenticate(self):
        """–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —Å JWT —Ç–æ–∫–µ–Ω–æ–º"""
        auth_message = json.dumps({
            "method": "jwt",
            "token": self.jwt_token
        })
        self.ws.send(f"42{auth_message}")
        print("[StreamElements] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω –∑–∞–ø—Ä–æ—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏")
        
    def _start_heartbeat(self):
        """–ó–∞–ø—É—Å–∫ heartbeat –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        def heartbeat():
            while self.is_connected:
                try:
                    self.ws.send("2")
                    time.sleep(25)
                except Exception:
                    break
                    
        self.heartbeat_thread = threading.Thread(target=heartbeat, daemon=True)
        self.heartbeat_thread.start()
        
    def _on_message(self, ws, message: str):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            if message.startswith('0'):
                self.is_connected = True
                self.reconnect_delay = 5
                print("[StreamElements] –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É")
                return
                
            if message.startswith('40'):
                print("[StreamElements] –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!")
                return
                
            if message.startswith('42'):
                data_str = message[2:]
                try:
                    data = json.loads(data_str)
                    if isinstance(data, list) and len(data) >= 2:
                        event_type = data[0]
                        event_data = data[1] if len(data) > 1 else {}
                        self._handle_event(event_type, event_data)
                except json.JSONDecodeError:
                    print(f"[StreamElements] –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON: {data_str}")
                return
                
            if message == '3':
                return  # Heartbeat response
                
        except Exception as e:
            print(f"[StreamElements] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
            
    def _handle_event(self, event_type: str, event_data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è"""
        stream_event = StreamEvent(event_type=event_type, data=event_data)
        self.events_history.append(stream_event)
        
        if event_type == 'event' or event_type == 'event:test':
            self._process_stream_event(event_data)
        elif event_type == 'message':
            self._process_chat_message(event_data)
        else:
            print(f"[StreamElements] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è: {event_type}")
            
    def _process_stream_event(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ stream —Å–æ–±—ã—Ç–∏—è"""
        listener = data.get('listener', '')
        event_data = data.get('event', data)
        
        event_type = data.get('type', '')
        
        if 'tip' in listener or 'tip' in event_type:
            self._handle_tip(event_data)
        elif 'subscriber' in listener or 'subscriber' in event_type:
            self._handle_subscriber(event_data)
        elif 'follower' in listener or 'follower' in event_type:
            self._handle_follower(event_data)
        elif 'raid' in listener or 'raid' in event_type:
            self._handle_raid(event_data)
        elif 'cheer' in listener or 'cheer' in event_type:
            self._handle_cheer(event_data)
        elif 'host' in listener or 'host' in event_type:
            self._handle_host(event_data)
        else:
            print(f"[StreamElements] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π listener: {listener}")
            
    def _process_chat_message(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–∞—Ç–∞"""
        username = data.get('displayName', data.get('username', '–ê–Ω–æ–Ω–∏–º'))
        message = data.get('message', data.get('text', ''))
        
        chat_event = {
            'username': username,
            'message': message,
            'timestamp': time.time(),
            'badges': data.get('badges', []),
            'emotes': data.get('emotes', [])
        }
        
        self.chat_history.append(chat_event)
        
        stream_event = StreamEvent(
            event_type='chat_message',
            data=chat_event
        )
        
        if self.event_callback:
            self.event_callback(stream_event)
            
        print(f"[–ß–ê–¢] {username}: {message}")
        
    def _handle_tip(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–Ω–∞—Ç–∞"""
        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))
        amount = float(data.get('amount', 0))
        currency = data.get('currency', 'USD')
        tip_message = data.get('message', '')
        
        self.viewer_stats['total_tips'] += amount
        
        if not self.viewer_stats['top_donator'] or amount > self.viewer_stats['top_donator'].get('amount', 0):
            self.viewer_stats['top_donator'] = {'username': username, 'amount': amount}
            
        stream_event = StreamEvent(
            event_type='donation',
            data={
                'username': username,
                'amount': amount,
                'currency': currency,
                'message': tip_message,
                'formatted': f"{amount} {currency}"
            }
        )
        
        self.viewer_stats['recent_events'].append(stream_event)
        if len(self.viewer_stats['recent_events']) > 20:
            self.viewer_stats['recent_events'].pop(0)
            
        if self.event_callback:
            self.event_callback(stream_event)
            
        print(f"[–î–û–ù–ê–¢] {username}: {amount} {currency} - {tip_message}")
        
    def _handle_subscriber(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏"""
        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))
        tier = data.get('tier', '1000')
        months = data.get('amount', data.get('months', 1))
        is_gift = data.get('gifted', False)
        gifter = data.get('sender', '')
        
        self.viewer_stats['total_subs'] += 1
        
        tier_name = {'1000': 'Tier 1', '2000': 'Tier 2', '3000': 'Tier 3'}.get(str(tier), 'Tier 1')
        
        stream_event = StreamEvent(
            event_type='subscription',
            data={
                'username': username,
                'tier': tier_name,
                'months': months,
                'is_gift': is_gift,
                'gifter': gifter,
                'message': data.get('message', '')
            }
        )
        
        if self.event_callback:
            self.event_callback(stream_event)
            
        if is_gift:
            print(f"[–ü–û–î–ü–ò–°–ö–ê] {gifter} –ø–æ–¥–∞—Ä–∏–ª –ø–æ–¥–ø–∏—Å–∫—É {username} ({tier_name})")
        else:
            print(f"[–ü–û–î–ü–ò–°–ö–ê] {username} –ø–æ–¥–ø–∏—Å–∞–ª—Å—è! ({tier_name}, {months} –º–µ—Å.)")
            
    def _handle_follower(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ–ª–ª–æ–≤–µ—Ä–∞"""
        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))
        
        self.viewer_stats['total_followers'] += 1
        
        stream_event = StreamEvent(
            event_type='follow',
            data={'username': username}
        )
        
        if self.event_callback:
            self.event_callback(stream_event)
            
        print(f"[–§–û–õ–õ–û–£] {username} –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –Ω–∞ –∫–∞–Ω–∞–ª!")
        
    def _handle_raid(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–π–¥–∞"""
        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))
        viewers = data.get('amount', data.get('viewers', 0))
        
        stream_event = StreamEvent(
            event_type='raid',
            data={
                'username': username,
                'viewers': viewers
            }
        )
        
        if self.event_callback:
            self.event_callback(stream_event)
            
        print(f"[–†–ï–ô–î] {username} –≤–æ—Ä–≤–∞–ª—Å—è —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏!")
        
    def _handle_cheer(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∏—Ç–æ–≤ (cheer)"""
        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))
        amount = data.get('amount', 0)
        message = data.get('message', '')
        
        stream_event = StreamEvent(
            event_type='cheer',
            data={
                'username': username,
                'bits': amount,
                'message': message
            }
        )
        
        if self.event_callback:
            self.event_callback(stream_event)
            
        print(f"[–ë–ò–¢–´] {username}: {amount} –±–∏—Ç–æ–≤ - {message}")
        
    def _handle_host(self, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ö–æ—Å—Ç–∞"""
        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))
        viewers = data.get('amount', data.get('viewers', 0))
        
        stream_event = StreamEvent(
            event_type='host',
            data={
                'username': username,
                'viewers': viewers
            }
        )
        
        if self.event_callback:
            self.event_callback(stream_event)
            
        print(f"[–•–û–°–¢] {username} —Ö–æ—Å—Ç–∏—Ç –∫–∞–Ω–∞–ª —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏!")
        
    def _on_error(self, ws, error):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
        print(f"[StreamElements] –û—à–∏–±–∫–∞: {error}")
        
    def _on_close(self, ws, close_status_code, close_msg):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        self.is_connected = False
        print(f"[StreamElements] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ: {close_status_code} - {close_msg}")
        
    def disconnect(self):
        """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç StreamElements"""
        self.is_connected = False
        if self.ws:
            self.ws.close()
            
    def get_chat_history(self, limit: int = 50) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞"""
        return list(self.chat_history)[-limit:]
        
    def get_recent_events(self, limit: int = 20) -> List[StreamEvent]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–æ–±—ã—Ç–∏–π"""
        return list(self.events_history)[-limit:]
        
    def get_viewer_stats(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑—Ä–∏—Ç–µ–ª–µ–π"""
        return self.viewer_stats.copy()
</file>

<file path="temp_repo/attached_assets/streamelements_client_1765902075685.py">
import json
import websocket

# –í—Å—Ç–∞–≤—å—Ç–µ –≤–∞—à —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω —Å—é–¥–∞
YOUR_JWT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjaXRhZGVsIiwiZXhwIjoxNzgxNDUzNDYwLCJqdGkiOiJjYzM3ZjUwNS1lNGRkLTQxZjktOGIwZS1lNTNhZjUzM2M0ODIiLCJjaGFubmVsIjoiNjk0MTg0OTNjMjdmNzk4NGQ1Y2UwNmNkIiwicm9sZSI6Im93bmVyIiwiYXV0aFRva2VuIjoiMVdQckRUYUZUN21mc3RHSlNfZFpxV3NtNmlicFhYeGdDbmdjcThpeHlCbG9HTXpVIiwidXNlciI6IjY5NDE4NDkzYzI3Zjc5ODRkNWNlMDZjYyIsInVzZXJfaWQiOiIwYjhiZTJhZS1kNjIyLTRlNGEtODdmMy01NjJhYTcxMGM5YWYiLCJ1c2VyX3JvbGUiOiJjcmVhdG9yIiwicHJvdmlkZXIiOiJ0d2l0Y2giLCJwcm92aWRlcl9pZCI6IjE4NzU3MjUyNyIsImNoYW5uZWxfaWQiOiJlMjU4YzczZS04ZTgxLTQyNzktOGNjMS0wZWI2OTE2ZmIyMDMiLCJjcmVhdG9yX2lkIjoiNGQ4Zjk5YzktMGE3OC00YjlkLWJlNWEtZjVmNDY2ZGMyZjk4In0.UDj-xNNlOjOplW8gliL0-cb9S8_rnuCZaQCpLUvMq1o"

def on_message(ws, message):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç StreamElements."""
    try:
        data = json.loads(message)
    except json.JSONDecodeError:
        # –ò–Ω–æ–≥–¥–∞ –ø—Ä–∏—Ö–æ–¥—è—Ç —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –∏—Ö –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å
        return

    # StreamElements –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–±—ã—Ç–∏—è –≤ –ø–æ–ª–µ 'type'
    event_type = data.get('type')
    listener = data.get('listener')

    # –°–æ–±—ã—Ç–∏–µ —á–∞—Ç–∞
    if listener == 'chat-message':
        event_data = data.get('data', {})
        username = event_data.get('displayName', '–ê–Ω–æ–Ω–∏–º')
        user_message = event_data.get('message', '')
        print(f'[–ß–ê–¢] {username}: {user_message}')
        # –¢—É—Ç –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≤–∞—à –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

    # –°–æ–±—ã—Ç–∏–µ –¥–æ–Ω–∞—Ç–∞ (—Ç–∏–ø 'tip')
    elif event_type == 'tip':
        event_data = data.get('data', {})
        donor = event_data.get('username', '–ê–Ω–æ–Ω–∏–º')
        amount = event_data.get('amount', 0)
        currency = event_data.get('currency', 'USD')
        print(f'[–î–û–ù–ê–¢] {donor} - {amount} {currency}')
        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º

    # –°–æ–±—ã—Ç–∏–µ –Ω–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ (—Ç–∏–ø 'subscriber')
    elif event_type == 'subscriber':
        event_data = data.get('data', {})
        subscriber = event_data.get('username', '–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫')
        print(f'[–ü–û–î–ü–ò–°–ö–ê] {subscriber}')
        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏

def on_error(ws, error):
    print(f"–û—à–∏–±–∫–∞ WebSocket: {error}")

def on_close(ws, close_status_code, close_msg):
    print("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å StreamElements –∑–∞–∫—Ä—ã—Ç–æ")

def on_open(ws):
    print("–£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ StreamElements WebSocket!")
    # –ü–æ—Å–ª–µ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω—É–∂–Ω–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å—Å—è
    auth_message = {
        "method": "jwt",
        "token": YOUR_JWT_TOKEN
    }
    ws.send(json.dumps(auth_message))

if __name__ == "__main__":
    ws_url = "wss://realtime.streamelements.com/socket.io/?EIO=4&transport=websocket"
    ws = websocket.WebSocketApp(ws_url,
                                on_open=on_open,
                                on_message=on_message,
                                on_error=on_error,
                                on_close=on_close)
    ws.run_forever()
</file>

<file path="requirements.txt">
# IRIS AI Assistant - Clean Dependencies

# TTS (—Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏)
edge-tts>=7.0.0
pygame>=2.6.1

# ASR (—Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏)
vosk>=0.3.45
SpeechRecognition>=3.10.0

# AI (–ª–æ–∫–∞–ª—å–Ω–æ–µ + –æ–±–ª–∞—á–Ω–æ–µ)
ollama>=0.1.0
groq>=0.5.0

# –í–µ–± –∏ API
flask>=3.0.0
websocket-client>=1.6.0
websockets>=12.0
requests>=2.31.0

# –£—Ç–∏–ª–∏—Ç—ã
python-dotenv>=1.0.0
numpy>=1.26.4
</file>

<file path="src/iris_visual.py">
"""
IRIS Visual Interface - IO-style pulsating orb
–í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ò—Ä–∏—Å —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è/—Å—É–∂–µ–Ω–∏—è –ø—Ä–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ
"""
import pygame
import math
import threading
import time
import os
import numpy as np
from typing import Optional, Callable

class IrisVisual:
    """
    –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ò—Ä–∏—Å –≤ —Å—Ç–∏–ª–µ IO –∏–∑ Dota 2
    –ü—É–ª—å—Å–∏—Ä—É—é—â–∏–π —à–∞—Ä, —Ä–∞—Å—à–∏—Ä—è—é—â–∏–π—Å—è –ø—Ä–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ
    """
    
    def __init__(self, width: int = 400, height: int = 400):
        self.width = width
        self.height = height
        self.center_x = width // 2
        self.center_y = height // 2
        
        self.base_radius = 80
        self.current_radius = self.base_radius
        self.target_radius = self.base_radius
        self.max_expand = 40
        
        self.is_speaking = False
        self.speech_intensity = 0.0
        self.pulse_phase = 0.0
        self.glow_phase = 0.0
        
        self.running = False
        self.initialized = False
        
        self.core_color = (100, 180, 255)
        self.glow_color = (50, 150, 255)
        self.particle_color = (150, 200, 255)
        
        self.particles = []
        self.energy_rings = []
        
        self.startup_sound_path = None
        self.startup_complete = False
        self.startup_animation_progress = 0.0
        
        self.screen = None
        self.clock = None
        
    def set_status(self, text: str):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞"""
        if hasattr(self, 'status_label'):
            self.status_label.config(text=text)
        elif hasattr(self, 'status_text'):
            self.status_text = text
        print(f"[VISUAL] –°—Ç–∞—Ç—É—Å: {text}")

    def _init_pygame(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è pygame display"""
        if self.initialized:
            return True
            
        try:
            pygame.init()
            
            os.environ['SDL_VIDEO_WINDOW_POS'] = '100,100'
            
            self.screen = pygame.display.set_mode((self.width, self.height))
            pygame.display.set_caption("üå∏ IRIS - AI Companion")
            
            self.clock = pygame.time.Clock()
            self.initialized = True
            
            for _ in range(20):
                self.particles.append(self._create_particle())
                
            return True
            
        except Exception as e:
            print(f"[VISUAL] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ pygame display: {e}")
            return False
    
    def _create_particle(self) -> dict:
        """–°–æ–∑–¥–∞—Ç—å —á–∞—Å—Ç–∏—Ü—É –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —ç–Ω–µ—Ä–≥–∏–∏"""
        angle = np.random.uniform(0, 2 * math.pi)
        distance = np.random.uniform(self.base_radius * 0.5, self.base_radius * 2)
        speed = np.random.uniform(0.5, 2.0)
        size = np.random.uniform(2, 6)
        
        return {
            'angle': angle,
            'distance': distance,
            'speed': speed,
            'size': size,
            'alpha': np.random.uniform(100, 255),
            'orbit_speed': np.random.uniform(-0.02, 0.02)
        }
    
    def _draw_glow(self, surface, center, radius, color, intensity=1.0):
        """–†–∏—Å–æ–≤–∞—Ç—å —Å–≤–µ—á–µ–Ω–∏–µ"""
        for i in range(10, 0, -1):
            glow_radius = int(radius + i * 8)
            alpha = int(30 * intensity * (i / 10))
            glow_surface = pygame.Surface((glow_radius * 2, glow_radius * 2), pygame.SRCALPHA)
            glow_color_alpha = (*color, alpha)
            pygame.draw.circle(glow_surface, glow_color_alpha, (glow_radius, glow_radius), glow_radius)
            surface.blit(glow_surface, (center[0] - glow_radius, center[1] - glow_radius))
    
    def _draw_core(self, surface, center, radius):
        """–†–∏—Å–æ–≤–∞—Ç—å —è–¥—Ä–æ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º"""
        for i in range(int(radius), 0, -2):
            ratio = i / radius
            r = int(self.core_color[0] * ratio + 255 * (1 - ratio))
            g = int(self.core_color[1] * ratio + 255 * (1 - ratio))
            b = int(self.core_color[2] * ratio + 255 * (1 - ratio))
            pygame.draw.circle(surface, (r, g, b), center, i)
    
    def _draw_energy_rings(self, surface, center, base_radius):
        """–†–∏—Å–æ–≤–∞—Ç—å —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ –∫–æ–ª—å—Ü–∞"""
        ring_count = 3
        for i in range(ring_count):
            offset = (self.glow_phase + i * 0.3) % 1.0
            ring_radius = int(base_radius * (1.2 + offset * 0.8))
            alpha = int(150 * (1 - offset))
            
            ring_surface = pygame.Surface((ring_radius * 2 + 10, ring_radius * 2 + 10), pygame.SRCALPHA)
            ring_color = (*self.glow_color, alpha)
            pygame.draw.circle(ring_surface, ring_color, (ring_radius + 5, ring_radius + 5), ring_radius, 2)
            surface.blit(ring_surface, (center[0] - ring_radius - 5, center[1] - ring_radius - 5))
    
    def _draw_particles(self, surface, center, speaking_intensity):
        """–†–∏—Å–æ–≤–∞—Ç—å –æ—Ä–±–∏—Ç–∞–ª—å–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã"""
        for p in self.particles:
            p['angle'] += p['orbit_speed'] * (1 + speaking_intensity * 2)
            
            if self.is_speaking:
                p['distance'] += math.sin(self.pulse_phase * 3 + p['angle']) * 2
            
            x = center[0] + math.cos(p['angle']) * p['distance']
            y = center[1] + math.sin(p['angle']) * p['distance']
            
            size = int(p['size'] * (1 + speaking_intensity * 0.5))
            alpha = int(p['alpha'] * (0.5 + speaking_intensity * 0.5))
            
            particle_surface = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)
            particle_color = (*self.particle_color, alpha)
            pygame.draw.circle(particle_surface, particle_color, (size, size), size)
            surface.blit(particle_surface, (int(x) - size, int(y) - size))
    
    def _draw_speech_waves(self, surface, center, radius, intensity):
        """–†–∏—Å–æ–≤–∞—Ç—å –≤–æ–ª–Ω—ã —Ä–µ—á–∏ –∫–æ–≥–¥–∞ –ò—Ä–∏—Å –≥–æ–≤–æ—Ä–∏—Ç"""
        if intensity < 0.1:
            return
            
        wave_count = 5
        for i in range(wave_count):
            wave_offset = (self.pulse_phase * 2 + i * 0.2) % 1.0
            wave_radius = int(radius + wave_offset * 60 * intensity)
            alpha = int(100 * intensity * (1 - wave_offset))
            
            wave_surface = pygame.Surface((wave_radius * 2 + 10, wave_radius * 2 + 10), pygame.SRCALPHA)
            wave_color = (200, 230, 255, alpha)
            pygame.draw.circle(wave_surface, wave_color, (wave_radius + 5, wave_radius + 5), wave_radius, 3)
            surface.blit(wave_surface, (center[0] - wave_radius - 5, center[1] - wave_radius - 5))
    
    def _update_animation(self, dt):
        """–û–±–Ω–æ–≤–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é"""
        self.pulse_phase += dt * 2
        self.glow_phase += dt * 0.5
        
        if self.glow_phase > 1.0:
            self.glow_phase -= 1.0
        
        if self.is_speaking:
            self.target_radius = self.base_radius + self.max_expand * self.speech_intensity
            
            wave_expansion = math.sin(self.pulse_phase * 8) * self.max_expand * 0.3 * self.speech_intensity
            self.target_radius += wave_expansion
        else:
            idle_pulse = math.sin(self.pulse_phase) * 5
            self.target_radius = self.base_radius + idle_pulse
        
        self.current_radius += (self.target_radius - self.current_radius) * 0.15
    
    def _render_frame(self):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –æ–¥–Ω–æ–≥–æ –∫–∞–¥—Ä–∞"""
        if not self.screen:
            return
            
        self.screen.fill((10, 15, 25))
        
        center = (self.center_x, self.center_y)
        
        glow_intensity = 0.6 + self.speech_intensity * 0.4
        self._draw_glow(self.screen, center, self.current_radius, self.glow_color, glow_intensity)
        
        self._draw_energy_rings(self.screen, center, self.current_radius)
        
        self._draw_particles(self.screen, center, self.speech_intensity)
        
        if self.is_speaking:
            self._draw_speech_waves(self.screen, center, self.current_radius, self.speech_intensity)
        
        self._draw_core(self.screen, center, int(self.current_radius))
        
        inner_radius = int(self.current_radius * 0.3)
        pygame.draw.circle(self.screen, (255, 255, 255), center, inner_radius)
        
        pygame.display.flip()
    
    def set_speaking(self, speaking: bool, intensity: float = 1.0):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞"""
        self.is_speaking = speaking
        self.speech_intensity = max(0.0, min(1.0, intensity))
    
    def pulse(self, intensity: float = 0.8, duration: float = 0.3):
        """–°–æ–∑–¥–∞—Ç—å –ø—É–ª—å—Å–∞—Ü–∏—é"""
        self.speech_intensity = intensity
        threading.Thread(target=self._pulse_fade, args=(duration,), daemon=True).start()
    
    def _pulse_fade(self, duration: float):
        """–ü–ª–∞–≤–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –ø—É–ª—å—Å–∞"""
        steps = int(duration * 60)
        for i in range(steps):
            self.speech_intensity = self.speech_intensity * 0.95
            time.sleep(1/60)
        self.speech_intensity = 0
    
    def generate_startup_sound(self, sound_type: str = 'power_up') -> Optional[str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–≤—É–∫–æ–≤ –∑–∞–ø—É—Å–∫–∞ –≤ —Å—Ç–∏–ª–µ Iron Man"""
        try:
            sample_rate = 44100
            
            if sound_type == 'power_up':
                duration = 2.0
                t = np.linspace(0, duration, int(sample_rate * duration))
                power_up = np.sin(2 * np.pi * 80 * t) * np.exp(-t * 0.3)
                power_up += np.sin(2 * np.pi * 160 * t) * np.exp(-t * 0.5) * 0.5
                sweep_freq = 100 + 400 * (t / duration)
                sweep = np.sin(2 * np.pi * sweep_freq * t) * 0.3
                sweep *= np.exp(-np.abs(t - 1.0) * 2)
                harmonics = np.sin(2 * np.pi * 440 * t) * 0.2
                harmonics += np.sin(2 * np.pi * 880 * t) * 0.1
                harmonics *= np.exp(-t * 0.8)
                hum = np.sin(2 * np.pi * 60 * t) * 0.1 * (1 - np.exp(-t * 2))
                sound = power_up + sweep + harmonics + hum
                
            elif sound_type == 'scan':
                duration = 1.0
                t = np.linspace(0, duration, int(sample_rate * duration))
                sweep_freq = 200 + 1000 * np.sin(t / duration * np.pi)
                sound = np.sin(2 * np.pi * sweep_freq * t) * 0.4
                sound += np.sin(2 * np.pi * 880 * t) * 0.1 * np.sin(t * 30)
                sound *= (1 - np.exp(-t * 10)) * np.exp(-(t - duration) * 3)
                
            elif sound_type == 'confirm':
                duration = 0.5
                t = np.linspace(0, duration, int(sample_rate * duration))
                sound = np.sin(2 * np.pi * 880 * t) * 0.3
                sound += np.sin(2 * np.pi * 1320 * t) * 0.2
                sound *= np.exp(-t * 4)
                
            elif sound_type == 'loading':
                duration = 1.5
                t = np.linspace(0, duration, int(sample_rate * duration))
                base_freq = 150 + 100 * (t / duration)
                sound = np.sin(2 * np.pi * base_freq * t) * 0.3
                pulse = (np.sin(t * 15) > 0).astype(float) * 0.3
                sound += pulse * np.sin(2 * np.pi * 600 * t) * 0.2
                hum = np.sin(2 * np.pi * 60 * t) * 0.15
                sound += hum
                
            elif sound_type == 'connect':
                duration = 0.8
                t = np.linspace(0, duration, int(sample_rate * duration))
                beep1 = np.sin(2 * np.pi * 1000 * t) * (t < 0.15).astype(float)
                beep2 = np.sin(2 * np.pi * 1200 * t) * ((t > 0.2) & (t < 0.35)).astype(float)
                beep3 = np.sin(2 * np.pi * 1500 * t) * ((t > 0.4) & (t < 0.55)).astype(float)
                sound = (beep1 + beep2 + beep3) * 0.4
                sound *= np.exp(-np.abs(t - 0.4) * 2)
                
            elif sound_type == 'ready':
                duration = 1.2
                t = np.linspace(0, duration, int(sample_rate * duration))
                chord = np.sin(2 * np.pi * 523 * t) * 0.3
                chord += np.sin(2 * np.pi * 659 * t) * 0.25
                chord += np.sin(2 * np.pi * 784 * t) * 0.2
                chord += np.sin(2 * np.pi * 1047 * t) * 0.15
                sound = chord * (1 - np.exp(-t * 5)) * np.exp(-(t - 0.3) * 1.5)
                shimmer = np.sin(2 * np.pi * 2000 * t) * 0.05 * np.sin(t * 20)
                sound += shimmer
            else:
                return None
            
            envelope = np.ones_like(t)
            attack = int(0.05 * sample_rate)
            release = int(0.1 * sample_rate)
            if len(envelope) > attack:
                envelope[:attack] = np.linspace(0, 1, attack)
            if len(envelope) > release:
                envelope[-release:] = np.linspace(1, 0, release)
            sound *= envelope
            
            if np.max(np.abs(sound)) > 0:
                sound = sound / np.max(np.abs(sound)) * 0.7
            
            sound_int = np.int16(sound * 32767)
            
            import tempfile
            temp_file = tempfile.NamedTemporaryFile(suffix='.wav', delete=False, prefix=f'iris_{sound_type}_')
            
            import wave
            with wave.open(temp_file.name, 'w') as wav_file:
                wav_file.setnchannels(1)
                wav_file.setsampwidth(2)
                wav_file.setframerate(sample_rate)
                wav_file.writeframes(sound_int.tobytes())
            
            return temp_file.name
            
        except Exception as e:
            print(f"[VISUAL] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∑–≤—É–∫–∞ {sound_type}: {e}")
            return None
    
    def play_sound(self, sound_type: str, volume: float = 0.7):
        """–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∑–≤—É–∫–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç"""
        sound_path = self.generate_startup_sound(sound_type)
        if sound_path and pygame.mixer.get_init():
            try:
                sound = pygame.mixer.Sound(sound_path)
                sound.set_volume(volume)
                sound.play()
                return sound_path
            except Exception as e:
                print(f"[VISUAL] –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è {sound_type}: {e}")
        return None
    
    def play_startup_sequence(self, callback: Optional[Callable] = None, phase_callback: Optional[Callable] = None):
        """–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –ø–æ–ª–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é –∑–∞–ø—É—Å–∫–∞ —Å —Ñ–∞–∑–∞–º–∏"""
        def startup_thread():
            temp_files = []
            
            sound_path = self.generate_startup_sound('power_up')
            if sound_path:
                temp_files.append(sound_path)
                if pygame.mixer.get_init():
                    try:
                        startup_sound = pygame.mixer.Sound(sound_path)
                        startup_sound.set_volume(0.7)
                        startup_sound.play()
                    except:
                        pass
            
            start_time = time.time()
            duration = 2.0
            
            while time.time() - start_time < duration:
                progress = (time.time() - start_time) / duration
                self.startup_animation_progress = progress
                if progress < 0.3:
                    self.speech_intensity = progress / 0.3 * 0.6
                elif progress < 0.7:
                    self.speech_intensity = 0.6 + math.sin((progress - 0.3) / 0.4 * math.pi * 4) * 0.3
                else:
                    self.speech_intensity = max(0.2, (1 - progress) / 0.3 * 0.6)
                time.sleep(0.016)
            
            if phase_callback:
                phase_callback('power_up_complete')
            
            time.sleep(0.5)
            
            self.startup_complete = True
            self.speech_intensity = 0
            
            for f in temp_files:
                try:
                    os.unlink(f)
                except:
                    pass
            
            if callback:
                callback()
        
        threading.Thread(target=startup_thread, daemon=True).start()
    
    def animate_phase(self, phase_name: str, duration: float = 1.0):
        """–ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—É—é —Ñ–∞–∑—É –∑–∞–ø—É—Å–∫–∞"""
        def phase_thread():
            sound_map = {
                'scan': 'scan',
                'check': 'scan', 
                'connect': 'connect',
                'loading': 'loading',
                'confirm': 'confirm',
                'ready': 'ready'
            }
            
            sound_type = sound_map.get(phase_name, 'confirm')
            sound_path = self.play_sound(sound_type, 0.5)
            
            start_time = time.time()
            while time.time() - start_time < duration:
                progress = (time.time() - start_time) / duration
                wave = math.sin(progress * math.pi * 6) * 0.3
                self.speech_intensity = 0.4 + wave
                time.sleep(0.016)
            
            self.speech_intensity = 0.2
            
            if sound_path:
                try:
                    time.sleep(0.3)
                    os.unlink(sound_path)
                except:
                    pass
        
        threading.Thread(target=phase_thread, daemon=True).start()
    
    def run(self, startup_callback: Optional[Callable] = None):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å"""
        if not self._init_pygame():
            print("[VISUAL] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å")
            return
        
        self.running = True
        
        self.play_startup_sequence(startup_callback)
        
        while self.running:
            dt = self.clock.tick(60) / 1000.0
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                    break
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        self.running = False
                        break
                    elif event.key == pygame.K_SPACE:
                        self.is_speaking = not self.is_speaking
                        self.speech_intensity = 0.8 if self.is_speaking else 0
            
            self._update_animation(dt)
            self._render_frame()
        
        pygame.quit()
    
    def run_async(self, startup_callback: Optional[Callable] = None):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
        thread = threading.Thread(target=self.run, args=(startup_callback,), daemon=True)
        thread.start()
        return thread
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å"""
        self.running = False
        
    def pulse_animation(self, duration=1.5, intensity=0.8):
        self.pulse(intensity=intensity, duration=duration)

    def show_message(self, text, duration=2.0):
        self.set_status(text)

if __name__ == "__main__":
    print("=== –¢–µ—Å—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ IRIS ===")
    
    visual = IrisVisual()
    
    def on_startup_complete():
        print("[VISUAL] –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
    
    visual.run(on_startup_complete)
</file>

<file path="src/utils/__init__.py">
<<<<<<< HEAD
"""
Iris Utils - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã
"""

def synthesize_and_play(text: str, lang: str = 'ru', cleanup: bool = True) -> bool:
    """
    –ë—ã—Å—Ç—Ä–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∏–Ω—Ç–µ–∑–∞ –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
    –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API
    """
    from src.tts_engine import TTSEngine
    import time
    
    engine = TTSEngine(voice='ru_female_soft')
    engine.speak(text, emotion='neutral')
    
    while engine.is_busy():
        time.sleep(0.1)
    
    engine.stop()
    return True

__all__ = ['synthesize_and_play']
=======
# Package initializer
>>>>>>> 6d0ea0cd1396a0d7b9b7fabfc564c9750f26d5aa
</file>

<file path="src/voice_input.py">
#!/usr/bin/env python3

"""
IRIS VOICE INPUT - Complete Voice Recognition System v4.2 FIXED

‚úÖ –ì–õ–ê–í–ù–´–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø v4.2:
1. last_vosk_result_time –û–ë–ù–û–í–õ–Ø–ï–¢–°–Ø –Ω–∞ –ö–ê–ñ–î–û–ú —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ (final –∏–ª–∏ partial)
2. Pause detector —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ (1.5s –ø–∞—É–∑–∞ = –∫–æ–Ω–µ—Ü —Ñ—Ä–∞–∑—ã)
3. –í—Ç–æ—Ä–∞—è –∫–æ–º–∞–Ω–¥–∞ –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–¢–°–Ø –∫–∞–∫ is_final=True
4. AI –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç voice)
"""

import os
import sys
import threading
import time
import queue
import json
import logging
from typing import Optional, Callable, List, Dict, Any, Tuple
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('voice.log', encoding='utf-8')
    ]
)

logger = logging.getLogger('VoiceInput')

# Import voice recognition libraries
try:
    from vosk import Model, KaldiRecognizer, SetLogLevel
    SetLogLevel(-1)
    VOSK_AVAILABLE = True
    logger.info("‚úÖ Vosk —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω")
except ImportError:
    VOSK_AVAILABLE = False
    logger.warning("‚ö†Ô∏è Vosk –Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω. pip install vosk")

try:
    import speech_recognition as sr
    SR_AVAILABLE = True
    logger.info("‚úÖ SpeechRecognition —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω")
except ImportError:
    SR_AVAILABLE = False
    logger.warning("‚ö†Ô∏è SpeechRecognition –Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω. pip install SpeechRecognition")

try:
    import pyaudio
    PYAUDIO_AVAILABLE = True
    logger.info("‚úÖ PyAudio —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω")
except ImportError:
    PYAUDIO_AVAILABLE = False
    logger.warning("‚ö†Ô∏è PyAudio –Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω. pip install pyaudio")

try:
    import sounddevice as sd
    SOUNDDEVICE_AVAILABLE = True
except Exception:
    SOUNDDEVICE_AVAILABLE = False
    logger.info("‚ö†Ô∏è SoundDevice –ø—Ä–æ–ø—É—â–µ–Ω (—Ç—Ä–µ–±—É–µ—Ç PortAudio)")

# Constants
WAKEWORD_VARIANTS = ['–∏—Ä–∏—Å', 'iris', '–∞–π—Ä–∏—Å', '–∏—Ä—É—Å', '–∏—Ä–∏—à', 'ai iris']

QUICK_COMMANDS = {
    '—Å—Ç–æ–ø': 'stop',
    '—Å—Ç–æ–ø–ø': 'stop',
    '–≤—ã—Ö–æ–¥': 'exit',
    '–ø–∞—É–∑–∞': 'pause',
    '–ø—Ä–æ–¥–æ–ª–∂–∞–π': 'resume',
    '–≥—Ä–æ–º—á–µ': 'volume_up',
    '—Ç–∏—à–µ': 'volume_down',
    '–≤—ã—Ä—É–±': 'mute',
    '–≤–∫–ª—é—á–∏': 'unmute',
    '–ø–æ–º–æ—â—å': 'help',
    '–∫–æ–º–∞–Ω–¥—ã': 'commands',
    '—Å—Ç–∞—Ç—É—Å': 'stats',
}

# Sentence ending markers
SENTENCE_ENDINGS = ['.', '!', '?', '...']
PAUSE_THRESHOLD = 1.5  # 1.5 —Å–µ–∫ –ø–∞—É–∑—ã = –∫–æ–Ω–µ—Ü —Ñ—Ä–∞–∑—ã

@dataclass
class RecognitionStats:
    """Statistics for voice recognition"""
    total_phrases: int = 0
    wake_detected: int = 0
    vosk_success: int = 0
    google_success: int = 0
    avg_confidence: float = 0.0
    last_recognition: str = ""
    audio_quality: float = 0.0

@dataclass
class AudioSettings:
    """Audio configuration"""
    sample_rate: int = 16000
    chunk_size: int = 1600
    channels: int = 1
    energy_threshold: int = 3000
    pause_threshold: float = 0.5
    phrase_threshold: float = 0.3
    non_speaking_duration: float = 0.3
    dynamic_threshold: bool = True

class VoiceInput:
    """
    Complete voice input system with Vosk + Google Speech Recognition
    
    ‚úÖ FIXED v4.2:
    - last_vosk_result_time –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –Ω–∞ –ö–ê–ñ–î–û–ú —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ
    - Pause detector —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ
    - –í—Ç–æ—Ä–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è
    - AI –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    """

    def __init__(
        self,
        wake_word: str = '–∏—Ä–∏—Å',
        sensitivity: float = 0.8,
        mode: str = 'hybrid',
        vosk_model_path: Optional[str] = None,
        audio_device_index: Optional[int] = None,
        sample_rate: int = 16000,
        enable_analytics: bool = True,
        conversation_timeout: float = 30.0,
        tts_interrupt_callback: Optional[Callable[[], None]] = None
    ):
        """Initialize VoiceInput system"""

        print("=" * 60)
        print("[VOICE] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞ v4.2 FIXED...")
        print("=" * 60)

        # Core settings
        self.wake_word = wake_word.lower()
        self.sensitivity = max(0.1, min(1.0, sensitivity))
        self.mode = mode
        self.audio_device_index = audio_device_index
        self.sample_rate = sample_rate
        self.enable_analytics = enable_analytics
        self.conversation_timeout = conversation_timeout
        self.tts_interrupt_callback = tts_interrupt_callback

        # Audio settings
        self.audio_settings = AudioSettings(
            sample_rate=sample_rate,
            energy_threshold=int(1500 + (3500 - 1500) * (1 - self.sensitivity))
        )

        # State management
        self.is_listening = False
        self.is_active = False
        self.is_calibrating = False
        self.conversation_active = False
        self.is_processing_command = False

        # Timeouts
        self.activation_timeout = conversation_timeout
        self.last_activation_time = 0
        self.last_audio_time = 0
        self.last_speech_time = 0
        self.last_phrase_text = ""
        self.current_partial_phrase = ""
        self.speech_started_time = 0
        self.user_speaking = False

        # ‚úÖ FIXED: last_vosk_result_time –û–ë–ù–û–í–õ–Ø–ï–¢–°–Ø –ù–ê –ö–ê–ñ–î–û–ú –†–ï–ó–£–õ–¨–¢–ê–¢–ï!
        self.last_vosk_result_time = 0  # –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –æ—Ç Vosk (final –∏–ª–∏ partial)
        self.phrase_finalization_timeout = 1.5  # 1.5s –ø–∞—É–∑—ã = –∫–æ–Ω–µ—Ü —Ñ—Ä–∞–∑—ã

        # Command queue and history
        self.command_queue = queue.PriorityQueue()
        self.audio_buffer = queue.Queue()

        # Callbacks
        self.command_callback: Optional[Callable[[str], None]] = None
        self.wake_callback: Optional[Callable[[], None]] = None
        self.error_callback: Optional[Callable[[Exception], None]] = None

        # Recognition history
        self.recognition_history: List[Dict[str, Any]] = []
        self.max_history = 100
        self.stats = RecognitionStats()

        # Duplicate command prevention
        self.last_command = ""
        self.last_command_time = 0
        self.duplicate_timeout = 0.3

        # Vosk setup
        self.vosk_model = None
        self.vosk_recognizer = None
        self._init_vosk(vosk_model_path)

        # Google Speech Recognition setup
        self.sr_recognizer = None
        self._init_google_speech()

        # Audio device setup
        self.audio_stream = None
        self.pyaudio_instance = None
        self._init_audio_device()

        # Threads
        self.listener_thread: Optional[threading.Thread] = None
        self.processor_thread: Optional[threading.Thread] = None
        self.analytics_thread: Optional[threading.Thread] = None
        self.pause_detector_thread: Optional[threading.Thread] = None

        # Print system info
        self._print_system_info()

        print("=" * 60)
        print("[VOICE] ‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
        print(f"[VOICE] ‚è±Ô∏è –†–µ–∂–∏–º —Ä–∞–∑–≥–æ–≤–æ—Ä–∞: {self.conversation_timeout}s (—Ç–∞–π–º–µ—Ä –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏ —Ä–µ—á–∏!)")
        print("[VOICE] üéôÔ∏è –ü—Ä–∏ –≤–∞—à–µ–π —Ä–µ—á–∏ –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω TTS interrupt callback")
        print(f"[VOICE] ‚è∏Ô∏è –î–µ—Ç–µ–∫—Ç–æ—Ä –ø–∞—É–∑—ã: {self.phrase_finalization_timeout}s")
        print("=" * 60)

    def _init_vosk(self, model_path: Optional[str] = None):
        """Initialize Vosk model for offline speech recognition"""
        if not VOSK_AVAILABLE:
            logger.warning("[VOICE] Vosk –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            return

        model_paths = [
            model_path,
            'models/vosk-model-ru-0.22',
            'vosk-model-ru-0.22',
            os.path.expanduser('~/.vosk/vosk-model-ru-0.22'),
            '/usr/share/vosk/vosk-model-ru-0.22',
        ]

        for path in model_paths:
            if path and os.path.exists(path):
                try:
                    self.vosk_model = Model(path)
                    self.vosk_recognizer = KaldiRecognizer(self.vosk_model, self.sample_rate)
                    self.vosk_recognizer.SetWords(True)
                    logger.info(f"[VOICE] ‚úÖ –ú–æ–¥–µ–ª—å Vosk –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {path}")
                    return
                except Exception as e:
                    logger.error(f"[VOICE] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Vosk: {e}")

        logger.warning("[VOICE] Vosk –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    def _init_google_speech(self):
        """Initialize Google Speech Recognition"""
        if not SR_AVAILABLE:
            logger.warning("[VOICE] Google Speech Recognition –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            return

        try:
            self.sr_recognizer = sr.Recognizer()
            self.sr_recognizer.pause_threshold = self.audio_settings.pause_threshold
            self.sr_recognizer.phrase_threshold = self.audio_settings.phrase_threshold
            self.sr_recognizer.non_speaking_duration = self.audio_settings.non_speaking_duration
            self.sr_recognizer.energy_threshold = self.audio_settings.energy_threshold
            self.sr_recognizer.dynamic_energy_threshold = self.audio_settings.dynamic_threshold
            logger.info("[VOICE] ‚úÖ SpeechRecognition –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        except Exception as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ SpeechRecognition: {e}")

    def _init_audio_device(self):
        """Initialize audio device and list available devices"""
        logger.info("[VOICE] –ü–æ–∏—Å–∫ –∞—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤...")

        if not PYAUDIO_AVAILABLE:
            logger.warning("[VOICE] PyAudio –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            return

        try:
            self.pyaudio_instance = pyaudio.PyAudio()
            device_count = self.pyaudio_instance.get_device_count()
            logger.info(f"[VOICE] –ù–∞–π–¥–µ–Ω–æ –∞—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤: {device_count}")

            for i in range(device_count):
                device_info = self.pyaudio_instance.get_device_info_by_index(i)
                if device_info.get('maxInputChannels', 0) > 0:
                    print(f" [{i}] {device_info.get('name')}")

            self.audio_device_index = self.audio_device_index or self.pyaudio_instance.get_default_input_device_info()['index']
            logger.info(f"[VOICE] –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {self.audio_device_index}")

        except Exception as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ PyAudio: {e}")

    def _print_system_info(self):
        """Print system information"""
        print("\n[VOICE] üìä –°–ò–°–¢–ï–ú–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø")
        print(f" ‚Ä¢ Wake word: '{self.wake_word}'")
        print(f" ‚Ä¢ –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {self.sensitivity:.1f}")
        print(f" ‚Ä¢ –†–µ–∂–∏–º —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: {self.mode}")
        print(f" ‚Ä¢ –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏: {self.sample_rate} Hz")
        print(f" ‚Ä¢ Vosk –¥–æ—Å—Ç—É–ø–µ–Ω: {'‚úÖ' if VOSK_AVAILABLE else '‚ùå'}")
        print(f" ‚Ä¢ Google Speech –¥–æ—Å—Ç—É–ø–µ–Ω: {'‚úÖ' if SR_AVAILABLE else '‚ùå'}")
        print(f" ‚Ä¢ PyAudio –¥–æ—Å—Ç—É–ø–µ–Ω: {'‚úÖ' if PYAUDIO_AVAILABLE else '‚ùå'}")
        print(f" ‚Ä¢ SoundDevice –¥–æ—Å—Ç—É–ø–µ–Ω: {'‚úÖ' if SOUNDDEVICE_AVAILABLE else '‚ùå'}")
        print(f" ‚Ä¢ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞: {'‚úÖ' if self.enable_analytics else '‚ùå'}")

    def check_wakeword(self, text: str, confidence: float = 1.0) -> Tuple[bool, str]:
        """
        Check if wake word is in text with fuzzy matching
        Returns: (is_wake_word, cleaned_text)
        """
        if not text or len(text.strip()) < 2:
            return False, text

        text_lower = text.lower().strip()
        words = text_lower.split()

        # Method 1: Exact substring match
        for variant in WAKEWORD_VARIANTS:
            if variant in text_lower:
                logger.debug(f"[VOICE] Wake word variant found: {variant}")
                return True, text_lower.replace(variant, '', 1).strip()

        # Method 2: Fuzzy matching
        for word in words:
            if len(word) >= 4:
                for variant in WAKEWORD_VARIANTS:
                    if word.startswith(variant[:4]) and len(variant) >= 4:
                        logger.debug(f"[VOICE] Wake word fuzzy match: {word} ~= {variant}")
                        return True, text_lower.replace(word, '', 1).strip()

        # Method 3: Prefix matching
        for variant in WAKEWORD_VARIANTS:
            if text_lower.startswith(variant):
                logger.debug(f"[VOICE] Wake word prefix match: {variant}")
                return True, text_lower[len(variant):].strip()

        # Method 4: Character overlap
        wake_chars = set(self.wake_word)
        for word in words:
            if len(word) >= 3:
                word_chars = set(word)
                overlap = len(wake_chars & word_chars)
                if overlap >= len(wake_chars) * 0.7:
                    logger.debug(f"[VOICE] Wake word fuzzy overlap: {word}")
                    return True, text_lower.replace(word, '', 1).strip()

        return False, text_lower

    def extract_command(self, text: str) -> str:
        """Extract and clean command from text"""
        if not text:
            return ""

        text_lower = text.lower().strip()

        # Check for quick commands
        for cmd_key, cmd_value in QUICK_COMMANDS.items():
            if cmd_key in text_lower:
                return cmd_value

        # Remove wake word if present
        is_wake, cleaned = self.check_wakeword(text_lower)
        if is_wake:
            return cleaned

        return text_lower

    def is_phrase_complete(self, text: str, time_since_last_speech: float) -> bool:
        """
        Determine if phrase is complete
        Returns True if text ends with punctuation OR pause > 1.5s
        """
        # Check for ending punctuation
        for ending in SENTENCE_ENDINGS:
            if text.rstrip().endswith(ending):
                logger.debug(f"[VOICE] –§—Ä–∞–∑–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (–ø—É–Ω–∫—Ç—É–∞—Ü–∏—è): {text}")
                return True

        # Check for pause duration
        if time_since_last_speech > PAUSE_THRESHOLD:
            logger.debug(f"[VOICE] –§—Ä–∞–∑–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (–ø–∞—É–∑–∞ {time_since_last_speech:.1f}s): {text}")
            return True

        return False

    def process_recognition(self, text: str, is_final: bool = False):
        """
        ‚úÖ –û–ë–†–ê–ë–û–¢–ò–¢–¨ –†–ê–°–ü–û–ó–ù–ê–ù–ù–´–ô –¢–ï–ö–°–¢
        –ö–æ–≥–¥–∞ is_final=True ‚Üí –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è command_callback
        """
        if not text or len(text.strip()) < 2:
            return

        # üéôÔ∏è –û–ë–ù–û–í–õ–Ø–ï–ú –¢–ê–ô–ú–ï–† –ò last_vosk_result_time
        current_time = time.time()
        self.last_speech_time = current_time
        self.last_vosk_result_time = current_time  # ‚úÖ –û–ë–ù–û–í–õ–Ø–ï–¢–°–Ø –ù–ê –ö–ê–ñ–î–û–ú –†–ï–ó–£–õ–¨–¢–ê–¢–ï!

        # –ï—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ –±–µ—Å–µ–¥—ã - –æ–±–Ω–æ–≤–ª—è–µ–º activation_timeout!
        if self.conversation_active:
            self.last_activation_time = current_time
            logger.debug(f"[VOICE] ‚è±Ô∏è –¢–∞–π–º–µ—Ä –æ–±–Ω–æ–≤–ª—ë–Ω: {self.conversation_timeout}s")

        # üéôÔ∏è –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≥–æ–≤–æ—Ä–∏—Ç - –ø—Ä–µ—Ä—ã–≤–∞–µ–º TTS!
        if self.tts_interrupt_callback:
            try:
                logger.info("[VOICE] üîá –ü—Ä–µ—Ä—ã–≤–∞—é TTS (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞—á–∞–ª –≥–æ–≤–æ—Ä–∏—Ç—å)")
                self.tts_interrupt_callback()
            except Exception as e:
                logger.error(f"[VOICE] –û—à–∏–±–∫–∞ TTS interrupt: {e}")

        # Filter pure numbers
        text_clean = text.strip()
        parts = text_clean.split()
        all_numbers = all(all(c.isdigit() or c == '.' or c == '-' for c in part) for part in parts)

        if all_numbers and len(parts) > 0:
            logger.debug(f"[VOICE] –ü—Ä–æ–ø—É—â–µ–Ω–∞ —á–∏—Å–ª–æ–≤–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {text_clean}")
            return

        # Update statistics
        self.stats.total_phrases += 1
        self.stats.last_recognition = text

        # Store in history
        self.recognition_history.append({
            'text': text,
            'timestamp': current_time,
            'is_final': is_final
        })

        if len(self.recognition_history) > self.max_history:
            self.recognition_history.pop(0)

        logger.info(f"üåê [VOICE] –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: '{text}' (final={is_final})")

        # Check for wake word
        is_wake, cleaned_text = self.check_wakeword(text)

        if is_wake:
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # –†–ï–ñ–ò–ú 1: –û–ë–ù–ê–†–£–ñ–ï–ù WAKE WORD
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            if current_time - self.last_activation_time < 1.0:
                logger.debug(f"[VOICE] –î—É–±–ª—å wake word, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
                return

            self.stats.wake_detected += 1
            logger.info(f"[VOICE] ‚úÖ Wake word –Ω–∞–π–¥–µ–Ω: '{self.wake_word}'")

            # Activate conversation mode
            self.is_active = True
            self.conversation_active = True
            self.last_activation_time = current_time
            self.last_speech_time = current_time
            self.current_partial_phrase = cleaned_text

            # Call wake callback
            if self.wake_callback:
                try:
                    self.wake_callback()
                except Exception as e:
                    logger.error(f"[VOICE] –û—à–∏–±–∫–∞ wake callback: {e}")
                    if self.error_callback:
                        self.error_callback(e)

            # –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–∫—Å—Ç –ø–æ—Å–ª–µ wake word - –æ–±—Ä–∞–±–æ—Ç–∞–π –µ–≥–æ –∫–∞–∫ –∫–æ–º–∞–Ω–¥—É
            if cleaned_text and len(cleaned_text.strip()) > 2:
                self.handle_command(cleaned_text)

        elif self.conversation_active:
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # –†–ï–ñ–ò–ú 2: –†–ï–ñ–ò–ú –†–ê–ó–ì–û–í–û–†–ê
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            self.current_partial_phrase = text

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à—ë–Ω–Ω–æ—Å—Ç—å —Ñ—Ä–∞–∑—ã
            time_since_speech = current_time - self.last_speech_time

            # ‚úÖ –ì–õ–ê–í–ù–û–ï –£–°–õ–û–í–ò–ï: –ö–æ–≥–¥–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ó–ê–í–ï–†–®–ï–ù–û
            if is_final:
                # –§–†–ê–ó–ê –ó–ê–í–ï–†–®–ï–ù–ê - –æ–±—Ä–∞–±–æ—Ç–∞–µ–º –∫–æ–º–∞–Ω–¥—É!
                self.last_phrase_text = text
                logger.info(f"[VOICE] üìù –ü–æ–ª–Ω–∞—è —Ñ—Ä–∞–∑–∞: '{text}' (is_final=True)")

                # ‚úÖ –í–´–ó–´–í–ê–ï–ú HANDLE_COMMAND
                self.handle_command(text)

            else:
                # Still waiting for more input
                logger.debug(f"[VOICE] ‚è≥ –ù–µ–ø–æ–ª–Ω–∞—è —Ñ—Ä–∞–∑–∞: '{text}' (–∂–¥—É –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ...)")

    def handle_command(self, command: str):
        """
        ‚úÖ –û–ë–†–ê–ë–û–¢–ö–ê –ö–û–ú–ê–ù–î–´ - –ó–¥–µ—Å—å –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è command_callback!
        """
        if not command:
            return

        # Clean command
        clean_command = command.strip().lower()

        # Remove wake word if still present
        if clean_command.startswith(self.wake_word):
            clean_command = clean_command[len(self.wake_word):].strip()

        if not clean_command or len(clean_command.strip()) < 2:
            return

        # Check for duplicate commands
        current_time = time.time()
        if self.last_command == clean_command and current_time - self.last_command_time < self.duplicate_timeout:
            logger.debug(f"[VOICE] –î—É–±–ª—å –∫–æ–º–∞–Ω–¥—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º: {clean_command}")
            return

        # Update command history
        self.last_command = clean_command
        self.last_command_time = current_time

        # Log command
        logger.info(f"üí¨ [VOICE] –ö–æ–º–∞–Ω–¥–∞: '{clean_command}'")

        # Mark as processing
        self.is_processing_command = True

        # ‚úÖ –í–´–ó–´–í–ê–ï–ú COMMAND CALLBACK
        if self.command_callback:
            try:
                logger.info(f"[VOICE] üì§ –í—ã–∑—ã–≤–∞—é command_callback —Å: '{clean_command}'")
                self.command_callback(clean_command)
                logger.info(f"[VOICE] ‚úÖ Callback –≤—ã–ø–æ–ª–Ω–µ–Ω –¥–ª—è: '{clean_command}'")
            except Exception as e:
                logger.error(f"[VOICE] –û—à–∏–±–∫–∞ command callback: {e}")
                if self.error_callback:
                    self.error_callback(e)
        else:
            logger.warning(f"[VOICE] ‚ö†Ô∏è Command callback –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")

        self.is_processing_command = False

        # ‚úÖ –ù–ï –í–´–ö–õ–Æ–ß–ê–ï–ú conversation_active!
        # –ü–æ–∑–≤–æ–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –¥–∞–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥ –ø–æ–¥—Ä—è–¥

    def _pause_detector_loop(self):
        """‚≠ê –î–µ—Ç–µ–∫—Ç–æ—Ä –ø–∞—É–∑—ã - –≤—ã–∑—ã–≤–∞–µ—Ç process_recognition —Å is_final=True –∫–æ–≥–¥–∞ –ø–∞—É–∑–∞ >= 1.5s"""
        logger.info("[VOICE] ‚è∏Ô∏è Pause detector –∑–∞–ø—É—â–µ–Ω")

        while self.is_listening:
            try:
                current_time = time.time()

                # –ï—Å–ª–∏ –º—ã –≤ —Ä–µ–∂–∏–º–µ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏ –±—ã–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç Vosk
                if self.conversation_active and self.last_vosk_result_time > 0:
                    time_since_last = current_time - self.last_vosk_result_time

                    # –ï—Å–ª–∏ –ø—Ä–æ—à–ª–æ >= 1.5 —Å–µ–∫ –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏ –µ—Å—Ç—å —Ç–µ–∫—É—â–∞—è —Ñ—Ä–∞–∑–∞
                    if time_since_last >= self.phrase_finalization_timeout and self.current_partial_phrase:
                        logger.info(f"[VOICE] ‚è∏Ô∏è –ü–∞—É–∑–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞ ({time_since_last:.1f}s) ‚Üí –≤—ã–∑—ã–≤–∞—é is_final=True")

                        # –í—ã–∑—ã–≤–∞–µ–º process_recognition —Å is_final=True
                        self.process_recognition(self.current_partial_phrase, is_final=True)

                        # –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä
                        self.current_partial_phrase = ""
                        self.last_vosk_result_time = 0

                time.sleep(0.1)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 100ms

            except Exception as e:
                logger.error(f"[VOICE] –û—à–∏–±–∫–∞ pause detector: {e}")
                time.sleep(0.1)

    def recognize_with_vosk(self, audio_data: bytes) -> Tuple[Optional[str], bool]:
        """
        Recognize speech using Vosk (offline)
        Returns: (text, is_final)
        """
        if not self.vosk_recognizer:
            return None, False

        try:
            if self.vosk_recognizer.AcceptWaveform(audio_data):
                result_json = self.vosk_recognizer.Result()
                result = json.loads(result_json)

                text = result.get('result', [])

                if text:
                    if isinstance(text, str):
                        if text.strip():
                            return text.strip(), True
                    elif isinstance(text, list) and len(text) > 0:
                        parts = []
                        for item in text:
                            extracted = None
                            if isinstance(item, dict):
                                extracted = item.get('conf') or item.get('result') or item.get('text') or item.get('word')
                            elif isinstance(item, str):
                                extracted = item
                            elif isinstance(item, (int, float)):
                                continue

                            if extracted:
                                extracted_str = str(extracted).strip()
                                if extracted_str:
                                    parts.append(extracted_str)

                        if parts:
                            result_text = ' '.join(parts).strip()
                            if result_text and len(result_text) > 1:
                                return result_text, True

                text = result.get('text', '').strip()
                if text and len(text) > 1:
                    return text, True

            # Check partial result
            partial_json = self.vosk_recognizer.PartialResult()
            partial = json.loads(partial_json)
            text = partial.get('partial', '').strip()

            if text and len(text) > 3:
                return text, False

        except json.JSONDecodeError:
            pass
        except Exception as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ Vosk: {e}")

        return None, False

    def recognize_with_google(self, audio_data) -> Optional[str]:
        """Recognize speech using Google Speech Recognition (online fallback)"""
        if not self.sr_recognizer:
            return None

        try:
            text = self.sr_recognizer.recognize_google(audio_data, language='ru-RU')
            return text
        except sr.UnknownValueError:
            return None
        except sr.RequestError as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ Google Speech: {e}")
            return None

    def listen_loop_vosk(self):
        """Main Vosk listening loop"""
        print("[VOICE] üéØ VOSK LOOP STARTED")
        logger.info("[VOICE] ‚úÖ –ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ –≤ —Ä–µ–∂–∏–º–µ 'hybrid'")
        logger.info(f"[VOICE] –ó–∞–ø—É—Å–∫ Vosk –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è... (—Å–∫–∞–∂–∏—Ç–µ '{self.wake_word}')")

        if not VOSK_AVAILABLE or not self.vosk_recognizer:
            logger.error("[VOICE] Vosk –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω!")
            return

        if not PYAUDIO_AVAILABLE:
            logger.warning("[VOICE] PyAudio –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–µ—Ä–µ–∫–ª—é—á–∞—é—Å—å –Ω–∞ Google")
            self.listen_loop_google()
            return

        try:
            p = pyaudio.PyAudio()

            try:
                self.audio_stream = p.open(
                    format=pyaudio.paInt16,
                    channels=self.audio_settings.channels,
                    rate=self.audio_settings.sample_rate,
                    input=True,
                    input_device_index=self.audio_device_index,
                    frames_per_buffer=self.audio_settings.chunk_size
                )

                logger.info("[VOICE] ‚úÖ –ê—É–¥–∏–æ–ø–æ—Ç–æ–∫ –æ—Ç–∫—Ä—ã—Ç, –Ω–∞—á–∏–Ω–∞–µ–º —Å–ª—É—à–∞—Ç—å...")

                while self.is_listening:
                    try:
                        audio_data = self.audio_stream.read(self.audio_settings.chunk_size, exception_on_overflow=False)

                        # Recognize with Vosk
                        text, is_final = self.recognize_with_vosk(audio_data)

                        if text:
                            self.process_recognition(text, is_final=is_final)

                        # Check conversation timeout
                        if self.conversation_active:
                            elapsed = time.time() - self.last_activation_time
                            if elapsed > self.activation_timeout:
                                logger.info(f"[VOICE] ‚è±Ô∏è –¢–∞–π–º–∞—É—Ç –±–µ—Å–µ–¥—ã ({self.activation_timeout}s), –≤—ã–∫–ª—é—á–∞—é—Å—å")
                                self.conversation_active = False
                                self.is_active = False

                    except Exception as e:
                        logger.error(f"[VOICE] –û—à–∏–±–∫–∞ –≤ Vosk loop: {e}")
                        time.sleep(0.1)

            except Exception as e:
                logger.error(f"[VOICE] –û—à–∏–±–∫–∞ Vosk loop: {e}")
                self.fallback_to_google()

            finally:
                if self.audio_stream:
                    self.audio_stream.stop_stream()
                    self.audio_stream.close()
                logger.info("[VOICE] Vosk loop –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

        except Exception as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ Vosk loop: {e}")
            self.fallback_to_google()

    def listen_loop_google(self):
        """Google Speech Recognition listening loop (fallback)"""
        print("[VOICE] üîÑ GOOGLE LOOP STARTED")
        logger.info("[VOICE] Google Speech Recognition...")

        if not SR_AVAILABLE:
            logger.error("[VOICE] SpeechRecognition –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω!")
            return

        try:
            with sr.Microphone(device_index=self.audio_device_index, sample_rate=self.audio_settings.sample_rate) as source:
                logger.info("[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –Ω–∞ 2 —Å–µ–∫...")
                self.sr_recognizer.adjust_for_ambient_noise(source, duration=2)
                logger.info(f"[VOICE] –ü–æ—Ä–æ–≥–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏: {self.sr_recognizer.energy_threshold}")

                while self.is_listening:
                    try:
                        audio = self.sr_recognizer.listen(source, timeout=10.0)
                        text = self.recognize_with_google(audio)

                        if text:
                            self.process_recognition(text, is_final=True)

                    except sr.WaitTimeoutError:
                        # Check conversation timeout
                        if self.conversation_active:
                            elapsed = time.time() - self.last_activation_time
                            if elapsed > self.activation_timeout:
                                logger.info(f"[VOICE] ‚è±Ô∏è –¢–∞–π–º–∞—É—Ç –±–µ—Å–µ–¥—ã ({self.activation_timeout}s), –≤—ã–∫–ª—é—á–∞—é—Å—å")
                                self.conversation_active = False
                                self.is_active = False
                        continue

                    except Exception as e:
                        logger.error(f"[VOICE] –û—à–∏–±–∫–∞ Google loop: {e}")
                        time.sleep(0.5)

        except OSError as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: {e}")
            self.fallback_to_simple()

        except Exception as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ Google loop: {e}")
            self.fallback_to_simple()

        finally:
            logger.info("[VOICE] Google loop –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    def listen_loop_simple(self):
        """Simple input loop for testing"""
        print("[VOICE] üìù SIMPLE LOOP STARTED")
        logger.info(f"[VOICE] Simple —Ä–µ–∂–∏–º. –°–∫–∞–∂–∏—Ç–µ '{self.wake_word}'")

        while self.is_listening:
            try:
                user_input = input().strip().lower()
                if user_input:
                    self.process_recognition(user_input, is_final=True)
            except EOFError:
                break
            except KeyboardInterrupt:
                break
            except Exception as e:
                logger.error(f"[VOICE] –û—à–∏–±–∫–∞ Simple loop: {e}")

    def fallback_to_google(self):
        """Fallback from Vosk to Google"""
        logger.warning("[VOICE] Fallback to Google Speech")
        self.mode = 'google'
        if self.is_listening:
            self.listen_loop_google()

    def fallback_to_simple(self):
        """Fallback to simple input mode"""
        logger.warning("[VOICE] Fallback to Simple mode")
        self.mode = 'simple'
        if self.is_listening:
            self.listen_loop_simple()

    def calibrate_microphone(self):
        """Calibrate microphone for better recognition"""
        if self.is_calibrating:
            return

        self.is_calibrating = True
        logger.info("[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...")

        try:
            if self.sr_recognizer:
                with sr.Microphone(device_index=self.audio_device_index) as source:
                    logger.info("[VOICE] –°–ª—É—à–∞—é –æ–∫—Ä—É–∂–∞—é—â–∏–µ –∑–≤—É–∫–∏ –Ω–∞ 2 —Å–µ–∫...")
                    self.sr_recognizer.adjust_for_ambient_noise(source, duration=2)
                    logger.info(f"[VOICE] –ù–æ–≤–æ–µ –ø–æ—Ä–æ–≥–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {self.sr_recognizer.energy_threshold}")

        except Exception as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: {e}")

        finally:
            self.is_calibrating = False

    def set_command_callback(self, callback: Callable[[str], None]):
        """Set callback for voice commands"""
        self.command_callback = callback
        logger.info("[VOICE] ‚úÖ Command callback —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    def set_wake_callback(self, callback: Callable[[], None]):
        """Set callback for wake word detection"""
        self.wake_callback = callback
        logger.info("[VOICE] ‚úÖ Wake callback —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    def set_error_callback(self, callback: Callable[[Exception], None]):
        """Set callback for errors"""
        self.error_callback = callback
        logger.info("[VOICE] ‚úÖ Error callback —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    def set_tts_interrupt_callback(self, callback: Callable[[], None]):
        """Set callback to interrupt TTS when user speaks"""
        self.tts_interrupt_callback = callback
        logger.info("[VOICE] ‚úÖ TTS interrupt callback —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    def get_recognition_stats(self) -> Dict[str, Any]:
        """Get recognition statistics"""
        remaining_timeout = 0
        if self.conversation_active:
            remaining_timeout = max(0, self.activation_timeout - (time.time() - self.last_activation_time))

        return {
            'total_phrases': self.stats.total_phrases,
            'wake_detected': self.stats.wake_detected,
            'vosk_success': self.stats.vosk_success,
            'google_success': self.stats.google_success,
            'avg_confidence': self.stats.avg_confidence,
            'last_recognition': self.stats.last_recognition,
            'audio_quality': self.stats.audio_quality,
            'queue_size': self.command_queue.qsize(),
            'conversation_active': self.conversation_active,
            'conversation_timeout_remaining': remaining_timeout
        }

    def save_stats(self, filename: str = 'voice_stats.json'):
        """Save statistics to file"""
        try:
            stats_data = {
                'timestamp': time.time(),
                'stats': self.get_recognition_stats(),
                'history': self.recognition_history[-50:]
            }

            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(stats_data, f, indent=2, ensure_ascii=False)

            logger.info(f"[VOICE] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {filename}")

        except Exception as e:
            logger.error(f"[VOICE] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")

    def start(self):
        """Start voice input system"""
        if self.is_listening:
            logger.warning("[VOICE] –£–∂–µ –∑–∞–ø—É—â–µ–Ω–æ")
            return

        self.is_listening = True

        # Select listening mode
        if self.mode == 'vosk':
            target = self.listen_loop_vosk
        elif self.mode == 'google':
            target = self.listen_loop_google
        elif self.mode == 'simple':
            target = self.listen_loop_simple
        else:  # hybrid (default)
            target = self.listen_loop_vosk

        # Start listener thread
        self.listener_thread = threading.Thread(
            target=target,
            daemon=True,
            name='VoiceInput-Listener'
        )
        self.listener_thread.start()

        # ‚≠ê Start pause detector thread
        self.pause_detector_thread = threading.Thread(
            target=self._pause_detector_loop,
            daemon=True,
            name='VoiceInput-PauseDetector'
        )
        self.pause_detector_thread.start()

        logger.info(f"[VOICE] ‚úÖ –ó–∞–ø—É—â–µ–Ω–æ –≤ —Ä–µ–∂–∏–º–µ '{self.mode}'")

    def stop(self):
        """Stop voice input system"""
        if not self.is_listening:
            return

        self.is_listening = False
        self.is_active = False
        self.conversation_active = False

        # Wait for thread
        if self.listener_thread and self.listener_thread.is_alive():
            self.listener_thread.join(timeout=2.0)

        logger.info("[VOICE] ‚úÖ –ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")

def create_voice_input(
    wake_word: str = '–∏—Ä–∏—Å',
    sensitivity: float = 0.8,
    mode: str = 'hybrid',
    conversation_timeout: float = 30.0,
    tts_interrupt_callback: Optional[Callable[[], None]] = None,
    **kwargs
) -> VoiceInput:
    """Factory function to create VoiceInput instance"""
    logger.info(f"[VOICE] –°–æ–∑–¥–∞–Ω–∏–µ VoiceInput: wake_word={wake_word}, mode={mode}, timeout={conversation_timeout}s")

    return VoiceInput(
        wake_word=wake_word,
        sensitivity=sensitivity,
        mode=mode,
        conversation_timeout=conversation_timeout,
        tts_interrupt_callback=tts_interrupt_callback,
        **kwargs
    )
</file>

<file path="replit.md">
# –ò—Ä–∏—Å - AI Stream Companion

## –û–ø–∏—Å–∞–Ω–∏–µ
–ò—Ä–∏—Å ‚Äî —ç—Ç–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∏ —Å–æ-–≤–µ–¥—É—â–∞—è –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤. –û–Ω–∞ —É–º–µ–µ—Ç:
- –†–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏—è –≤ CS2 (—É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, clutch, ace, –±–æ–º–±–∞)
- –ß–∏—Ç–∞—Ç—å —á–∞—Ç –∏ –æ—Ç–≤–µ—á–∞—Ç—å –∑—Ä–∏—Ç–µ–ª—è–º —á–µ—Ä–µ–∑ StreamElements
- –ë–ª–∞–≥–æ–¥–∞—Ä–∏—Ç—å –∑–∞ –¥–æ–Ω–∞—Ç—ã –∏ –ø–æ–¥–ø–∏—Å–∫–∏
- –£–ø—Ä–∞–≤–ª—è—Ç—å –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –≥–æ–ª–æ—Å–æ–º
- –í–µ—Å—Ç–∏ –∂–∏–≤–æ–π —Ä–∞–∑–≥–æ–≤–æ—Ä —Å–æ —Å—Ç—Ä–∏–º–µ—Ä–æ–º
- –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å—Ç—Ä–∏–º–∞
<<<<<<< HEAD
- ‚ú® **IO-style –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å** —Å –ø—É–ª—å—Å–∏—Ä—É—é—â–∏–º —à–∞—Ä–æ–º
- üöÄ **Iron Man —Å—Ç–∏–ª—å –∑–∞–ø—É—Å–∫–∞** —Å–æ –∑–≤—É–∫–æ–≤—ã–º —ç—Ñ—Ñ–µ–∫—Ç–æ–º

## üå∏ –ß—Ç–æ –Ω–æ–≤–æ–≥–æ (–í–µ—Ä—Å–∏—è 2.1 - Visual Update)

### ‚ú® IO-Style –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (NEW!):
- **–ü—É–ª—å—Å–∏—Ä—É—é—â–∏–π —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π —à–∞—Ä** - –∫–∞–∫ IO –∏–∑ Dota 2
- **–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø—Ä–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ** - —à–∞—Ä —Ä–∞—Å—à–∏—Ä—è–µ—Ç—Å—è –∫–æ–≥–¥–∞ –ò—Ä–∏—Å –≥–æ–≤–æ—Ä–∏—Ç
- **–ó–≤—É–∫ –∑–∞–ø—É—Å–∫–∞ Iron Man** - —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π startup sound
- **–û—Ä–±–∏—Ç–∞–ª—å–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã** - —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏—Ü—ã –≤–æ–∫—Ä—É–≥ —è–¥—Ä–∞
- **–í–æ–ª–Ω—ã —Ä–µ—á–∏** - –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –≤–æ–ª–Ω—ã –ø—Ä–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ
- **–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å** - —Ä–∞–∑–Ω–∞—è —Å–∏–ª–∞ –ø—É–ª—å—Å–∞—Ü–∏–∏ –¥–ª—è —ç–º–æ—Ü–∏–π

### –ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:
- **Edge TTS** - –Ω–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å (–≤–º–µ—Å—Ç–æ OpenAI TTS)
- **Vosk** - –æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ (–≤–º–µ—Å—Ç–æ Whisper API)
- **Groq LLM** - –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI –¥–ª—è –æ—Ç–≤–µ—Ç–æ–≤ (–≤–º–µ—Å—Ç–æ GPT-4o)
- **Google Speech** - –æ–Ω–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤
- **Pygame** - –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ –∑–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã

### –£–ª—É—á—à–µ–Ω–∏—è –≥–æ–ª–æ—Å–∞:
- –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å (ru-RU-SvetlanaNeural)
- –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏ (—Ä–∞–¥–æ—Å—Ç—å, –ø–æ–¥–¥–µ—Ä–∂–∫–∞, –≤–æ–ª–Ω–µ–Ω–∏–µ)
- –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏ —Ç–æ–Ω —Ä–µ—á–∏
- –ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–∞—É–∑—ã –º–µ–∂–¥—É –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º–∏

### –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ wake-word "–ò—Ä–∏—Å":
- Fuzzy matching –¥–ª—è –ø–æ—Ö–æ–∂–∏—Ö —Å–ª–æ–≤
- –í–∞—Ä–∏–∞–Ω—Ç—ã: "–∏—Ä–∏—Å", "iris", "–∏—Ä–∏—Å–∫–∞", "–∞–π—Ä–∏—Å" –∏ –¥—Ä.
- –í—ã—Å–æ–∫–∞—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫ –±—ã—Å—Ç—Ä–æ–π —Ä–µ—á–∏
- –û—Ñ–ª–∞–π–Ω —Ä–∞–±–æ—Ç–∞ —Å Vosk
=======
>>>>>>> 6d0ea0cd1396a0d7b9b7fabfc564c9750f26d5aa

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

```
src/
<<<<<<< HEAD
‚îú‚îÄ‚îÄ iris_visual.py        # ‚ú® IO-style –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (NEW!)
‚îú‚îÄ‚îÄ tts_engine.py         # Edge TTS –¥–ª—è –Ω–µ–∂–Ω–æ–≥–æ –∂–µ–Ω—Å–∫–æ–≥–æ –≥–æ–ª–æ—Å–∞
‚îú‚îÄ‚îÄ voice_input.py        # Vosk/Google —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏
‚îú‚îÄ‚îÄ cs2_gsi.py           # CS2 Game State Integration —Å–µ—Ä–≤–µ—Ä
‚îú‚îÄ‚îÄ streamelements_client.py  # StreamElements WebSocket –∫–ª–∏–µ–Ω—Ç
‚îú‚îÄ‚îÄ iris_brain.py        # Groq LLM –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤
‚îú‚îÄ‚îÄ windows_audio.py     # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π
‚îú‚îÄ‚îÄ achievements.py      # –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ tts_utils.py     # –£—Ç–∏–ª–∏—Ç—ã —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
=======
‚îú‚îÄ‚îÄ tts_engine.py         # OpenAI TTS –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≥–æ–ª–æ—Å–∞
‚îú‚îÄ‚îÄ voice_recognition.py  # Whisper API –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞
‚îú‚îÄ‚îÄ cs2_gsi.py           # CS2 Game State Integration —Å–µ—Ä–≤–µ—Ä
‚îú‚îÄ‚îÄ streamelements_client.py  # StreamElements WebSocket –∫–ª–∏–µ–Ω—Ç
‚îú‚îÄ‚îÄ iris_brain.py        # GPT-4o –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤
‚îú‚îÄ‚îÄ windows_audio.py     # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π
‚îú‚îÄ‚îÄ achievements.py      # –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
>>>>>>> 6d0ea0cd1396a0d7b9b7fabfc564c9750f26d5aa
‚îî‚îÄ‚îÄ __init__.py

main.py                  # –ì–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª –∑–∞–ø—É—Å–∫–∞
```

## –ù–∞—Å—Ç—Ä–æ–π–∫–∞

<<<<<<< HEAD
### –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Å–µ–∫—Ä–µ—Ç—ã:
- `GROQ_API_KEY` - –∫–ª—é—á Groq API (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π, –¥–ª—è AI –æ—Ç–≤–µ—Ç–æ–≤)
- `STREAMELEMENTS_JWT_TOKEN` - JWT —Ç–æ–∫–µ–Ω StreamElements (–¥–ª—è —á–∞—Ç–∞)

### –ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å Groq API –∫–ª—é—á (–±–µ—Å–ø–ª–∞—Ç–Ω–æ):
1. –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ https://console.groq.com
2. –°–æ–∑–¥–∞–π—Ç–µ API –∫–ª—é—á
3. –î–æ–±–∞–≤—å—Ç–µ –≤ —Å–µ–∫—Ä–µ—Ç—ã Replit
=======
### –ù–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ–∫—Ä–µ—Ç—ã:
- `OPENAI_API_KEY` - –∫–ª—é—á OpenAI API
- `STREAMELEMENTS_JWT_TOKEN` - JWT —Ç–æ–∫–µ–Ω StreamElements (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
>>>>>>> 6d0ea0cd1396a0d7b9b7fabfc564c9750f26d5aa

### CS2 Game State Integration:
1. –ü—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Å–æ–∑–¥–∞—ë—Ç—Å—è —Ñ–∞–π–ª `gamestate_integration_iris.cfg`
2. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤ `<Steam>/steamapps/common/Counter-Strike Global Offensive/game/csgo/cfg/`
3. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ CS2

## –§—É–Ω–∫—Ü–∏–∏

<<<<<<< HEAD
### üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
- –°–∫–∞–∂–∏—Ç–µ "–ò—Ä–∏—Å" –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
- –ö–æ–º–∞–Ω–¥—ã: "—Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ", "–≤—ã–∫–ª—é—á–∏ –¥–∏—Å–∫–æ—Ä–¥", "–≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ 50%"
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞: "–ø—Ä–∏–≤–µ—Ç", "–∫–∞–∫ –¥–µ–ª–∞", "—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", "–¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è"

### üéÆ CS2 –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
- –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –ø—Ä–∏ —É–±–∏–π—Å—Ç–≤–∞—Ö, —Å–º–µ—Ä—Ç—è—Ö, clutch —Å–∏—Ç—É–∞—Ü–∏—è—Ö
- –†–µ–∞–∫—Ü–∏–∏ –Ω–∞ –±–æ–º–±—É, —Ä–∞—É–Ω–¥—ã, MVP
- –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —é–º–æ—Ä –∏ —ç–º–æ—Ü–∏–∏
- –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∏—Ç—É–∞—Ü–∏–∏

### üí¨ StreamElements
=======
### –ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
- –°–∫–∞–∂–∏—Ç–µ "–ò—Ä–∏—Å" –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
- –ö–æ–º–∞–Ω–¥—ã: "—Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ", "–≤—ã–∫–ª—é—á–∏ –¥–∏—Å–∫–æ—Ä–¥", "–≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ 50%"

### CS2 –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
- –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –ø—Ä–∏ —É–±–∏–π—Å—Ç–≤–∞—Ö, —Å–º–µ—Ä—Ç—è—Ö, clutch —Å–∏—Ç—É–∞—Ü–∏—è—Ö
- –†–µ–∞–∫—Ü–∏–∏ –Ω–∞ –±–æ–º–±—É, —Ä–∞—É–Ω–¥—ã, MVP
- –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —é–º–æ—Ä –∏ —ç–º–æ—Ü–∏–∏

### StreamElements
>>>>>>> 6d0ea0cd1396a0d7b9b7fabfc564c9750f26d5aa
- –ß—Ç–µ–Ω–∏–µ —á–∞—Ç–∞ –∏ –æ—Ç–≤–µ—Ç—ã –∑—Ä–∏—Ç–µ–ª—è–º
- –ë–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç–∏ –∑–∞ –¥–æ–Ω–∞—Ç—ã —Å —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º —Å—É–º–º—ã
- –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –∏ —Ä–µ–π–¥–æ–≤

<<<<<<< HEAD
### üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
- 20+ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è –≥–æ–ª–æ—Å–æ–º
- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤ stream_stats.json

## –ì–æ–ª–æ—Å–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏

### –î–æ—Å—Ç—É–ø–Ω—ã–µ –≥–æ–ª–æ—Å–∞:
- `ru_female_soft` - –°–≤–µ—Ç–ª–∞–Ω–∞ (–º—è–≥–∫–∏–π, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
- `ru_female_warm` - –î–∞—Ä—å—è (—Ç—ë–ø–ª—ã–π)
- `ru_male` - –î–º–∏—Ç—Ä–∏–π
- `en_female_soft` - Jenny (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π)
- `en_female_warm` - Aria (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π)

### –≠–º–æ—Ü–∏–∏:
- `neutral` - –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π
- `excited` - –≤–æ–∑–±—É–∂–¥—ë–Ω–Ω—ã–π
- `happy` - —Ä–∞–¥–æ—Å—Ç–Ω—ã–π
- `sad` - –≥—Ä—É—Å—Ç–Ω—ã–π
- `supportive` - –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–π
- `gentle` - –Ω–µ–∂–Ω—ã–π
- `tense` - –Ω–∞–ø—Ä—è–∂—ë–Ω–Ω—ã–π

## –ó–∞–ø—É—Å–∫

=======
### –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
- 20+ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è
- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏

## –ó–∞–ø—É—Å–∫
>>>>>>> 6d0ea0cd1396a0d7b9b7fabfc564c9750f26d5aa
```bash
python main.py
```

<<<<<<< HEAD
## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞

### Windows:
- Python 3.9+
- –ú–∏–∫—Ä–æ—Ñ–æ–Ω
- –î–∏–Ω–∞–º–∏–∫–∏/–Ω–∞—É—à–Ω–∏–∫–∏
- CS2 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

### –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:
```bash
pip install edge-tts pygame vosk groq flask websockets python-dotenv sounddevice SpeechRecognition
```

### –î–ª—è Vosk (–æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ):
```bash
# –°–∫–∞—á–∞–π—Ç–µ —Ä—É—Å—Å–∫—É—é –º–æ–¥–µ–ª—å
wget https://alphacephei.com/vosk/models/vosk-model-small-ru-0.22.zip
unzip vosk-model-small-ru-0.22.zip -d models/
```

## –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏

- Python 3.11
- Edge TTS (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ Microsoft)
- Vosk (–æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏)
- Groq LLM (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI)
- Flask (HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è CS2 GSI)
- WebSocket (StreamElements)
- pygame (–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ)

## –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

- –¢–æ–ª—å–∫–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
- –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å
- –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ wake-word
- –ö—Ä–æ—Å—Å–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ—Å—Ç—å (Windows, Linux, macOS)
=======
## –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏
- Python 3.11
- Flask (HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è CS2 GSI)
- OpenAI API (GPT-4o, Whisper, TTS)
- WebSocket (StreamElements)
- pygame (–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ)
>>>>>>> 6d0ea0cd1396a0d7b9b7fabfc564c9750f26d5aa
</file>

<file path="src/tts_engine.py">
"""
IRIS TTS Engine v3.1 - –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –≥–æ–ª–æ—Å —Å –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏–µ–π
–ü–æ–¥–¥–µ—Ä–∂–∫–∞ SSML –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —Ä–µ—á–∏
+ –ù–û–í–û–ï: interrupt(), flush(), wait_until_silent()
"""

import asyncio
import threading
import queue
import time
import os
import tempfile
from typing import Optional, Callable, Dict, Any, Tuple
from enum import Enum

try:
    import edge_tts
    EDGE_TTS_AVAILABLE = True
except ImportError:
    EDGE_TTS_AVAILABLE = False
    print("[TTS] Edge TTS –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install edge-tts")

try:
    import pygame
    PYGAME_AVAILABLE = True
except ImportError:
    PYGAME_AVAILABLE = False
    print("[TTS] Pygame –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install pygame")

class EmotionType(Enum):
    NEUTRAL = "neutral"
    HAPPY = "happy"
    EXCITED = "excited"
    GENTLE = "gentle"
    SUPPORTIVE = "supportive"
    TENSE = "tense"
    SAD = "sad"
    SARCASTIC = "sarcastic"
    PROUD = "proud"
    ENCOURAGING = "encouraging"

class TTSEngine:
    """
    –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –¥–≤–∏–∂–æ–∫ —Å–∏–Ω—Ç–µ–∑–∞ —Ä–µ—á–∏ –¥–ª—è –ò—Ä–∏—Å
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Edge TTS —Å SSML –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏
    """

    VOICE_PRESETS = {
        'ru_female_soft': 'ru-RU-SvetlanaNeural',
        'ru_female_energetic': 'ru-RU-DariyaNeural',
        'ru_male_deep': 'ru-RU-DmitryNeural',
        'en_female': 'en-US-JennyNeural',
        'en_male': 'en-US-GuyNeural',
    }

    EMOTION_SSML_PARAMS = {
        'neutral': {'rate': '+0%', 'pitch': '+0Hz', 'volume': '+0%'},
        'happy': {'rate': '+10%', 'pitch': '+15Hz', 'volume': '+5%'},
        'excited': {'rate': '+20%', 'pitch': '+25Hz', 'volume': '+10%'},
        'gentle': {'rate': '-10%', 'pitch': '-5Hz', 'volume': '-5%'},
        'supportive': {'rate': '+0%', 'pitch': '+8Hz', 'volume': '+0%'},
        'tense': {'rate': '+5%', 'pitch': '+5Hz', 'volume': '+5%'},
        'sad': {'rate': '-15%', 'pitch': '-10Hz', 'volume': '-10%'},
        'sarcastic': {'rate': '+5%', 'pitch': '-8Hz', 'volume': '+5%'},
        'proud': {'rate': '+8%', 'pitch': '+12Hz', 'volume': '+8%'},
        'encouraging': {'rate': '+5%', 'pitch': '+10Hz', 'volume': '+5%'},
    }

    EMOTION_PHRASES = {
        'happy': ['–£—Ä–∞!', '–û—Ç–ª–∏—á–Ω–æ!', '–ü—Ä–µ–∫—Ä–∞—Å–Ω–æ!', '–°—É–ø–µ—Ä!'],
        'excited': ['–í–∞—É!', '–ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!', '–ü–æ—Ç—Ä—è—Å–∞—é—â–µ!'],
        'supportive': ['–ù–µ –≤–æ–ª–Ω—É–π—Å—è', '–í—Å—ë –±—É–¥–µ—Ç —Ö–æ—Ä–æ—à–æ', '–¢—ã —Å–ø—Ä–∞–≤–∏—à—å—Å—è'],
        'proud': ['–ì–æ—Ä–∂—É—Å—å —Ç–æ–±–æ–π!', '–ú–æ–ª–æ–¥–µ—Ü!', '–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!'],
    }

    def __init__(self,
                 voice: str = 'ru_female_soft',
                 rate: int = 0,
                 volume: float = 0.9,
                 visual_callback: Optional[Callable] = None,
                 max_queue_size: int = 10):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ TTS –¥–≤–∏–∂–∫–∞
        Args:
            voice: –ü—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥–æ–ª–æ—Å–∞
            rate: –ë–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å —Ä–µ—á–∏
            volume: –ì—Ä–æ–º–∫–æ—Å—Ç—å (0.0 –¥–æ 1.0)
            visual_callback: –§—É–Ω–∫—Ü–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–π –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏
            max_queue_size: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏
        """
        print("[TTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –¥–≤–∏–∂–∫–∞ –ò—Ä–∏—Å v3.1...")
        
        if not EDGE_TTS_AVAILABLE:
            raise RuntimeError("Edge TTS –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        if not PYGAME_AVAILABLE:
            raise RuntimeError("Pygame –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        
        self._init_pygame()

        self.voice_preset = voice
        self.base_rate = rate
        self.base_volume = volume
        self.visual_callback = visual_callback
        
        # ‚úÖ –ù–û–í–û–ï: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å —Å max_queue_size
        self.message_queue = queue.PriorityQueue(maxsize=max_queue_size)
        self.max_queue_size = max_queue_size
        
        self.is_running = False
        self.currently_speaking = False
        self.current_emotion = EmotionType.NEUTRAL
        self.processing_thread = None
        self._message_counter = 0
        self.temp_files = []
        
        # ‚úÖ –ù–û–í–û–ï: –§–ª–∞–≥ –¥–ª—è –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ä–µ—á–∏
        self._interrupt_flag = False
        
        # ‚úÖ –ù–û–í–û–ï: Event –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        self._speaking_done = threading.Event()
        self._speaking_done.set()
        
        print(f"[TTS] –ì–æ–ª–æ—Å: {voice}, –ì—Ä–æ–º–∫–æ—Å—Ç—å: {volume}")
        print(f"[TTS] Max queue size: {max_queue_size}")
        print("[TTS] –î–≤–∏–∂–æ–∫ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")

    def _init_pygame(self):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è pygame mixer"""
        self.audio_available = False
        try:
            if pygame.mixer.get_init() is None:
                pygame.mixer.init(frequency=24000, size=-16, channels=1, buffer=2048)
            self.audio_available = True
            print("[TTS] Pygame mixer –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        except Exception as e:
            print(f"[TTS] –ê—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ: {e}")
            print("[TTS] –†–µ–∂–∏–º —Å–∏–º—É–ª—è—Ü–∏–∏ (—Ç–µ–∫—Å—Ç –±—É–¥–µ—Ç –≤—ã–≤–æ–¥–∏—Ç—å—Å—è –≤ –∫–æ–Ω—Å–æ–ª—å)")
            try:
                pygame.mixer.quit()
                pygame.mixer.init(frequency=22050, size=-16, channels=1, buffer=4096)
                self.audio_available = True
            except:
                self.audio_available = False

    def _get_voice_id(self) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ ID –≥–æ–ª–æ—Å–∞ Edge TTS"""
        if self.voice_preset in self.VOICE_PRESETS:
            return self.VOICE_PRESETS[self.voice_preset]
        return self.VOICE_PRESETS['ru_female_soft']

    def _build_ssml(self, text: str, emotion: str) -> str:
        """
        –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ SSML —Ä–∞–∑–º–µ—Ç–∫–∏ –¥–ª—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —Ä–µ—á–∏
        Args:
            text: –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç
            emotion: –¢–∏–ø —ç–º–æ—Ü–∏–∏
        Returns:
            SSML —Å—Ç—Ä–æ–∫–∞ —Å —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —Ä–∞–∑–º–µ—Ç–∫–æ–π
        """
        voice_id = self._get_voice_id()
        params = self.EMOTION_SSML_PARAMS.get(emotion, self.EMOTION_SSML_PARAMS['neutral'])
        
        ssml = f'''<speak version="1.0" xml:lang="ru-RU">
<voice name="{voice_id}" rate="{params['rate']}" pitch="{params['pitch']}">
{self._add_pauses(text, emotion)}
</voice>
</speak>'''
        return ssml

    def _add_pauses(self, text: str, emotion: str) -> str:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–∞—É–∑ –≤ —Ç–µ–∫—Å—Ç"""
        import re
        text = re.sub(r'([.!?])\s+', r'\1', text)
        text = re.sub(r'([,;:])\s+', r'\1', text)
        if emotion in ['happy', 'excited', 'proud']:
            text = re.sub(r'!', r'!', text)
        return text

    async def _synthesize_async(self, text: str, emotion: str = 'neutral') -> Optional[str]:
        """
        –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ —Å Edge TTS
        Returns:
            –ü—É—Ç—å –∫ –≤—Ä–µ–º–µ–Ω–Ω–æ–º—É –∞—É–¥–∏–æ—Ñ–∞–π–ª—É –∏–ª–∏ None
        """
        if not text or not isinstance(text, str):
            return None

        text = text.strip()
        if not text:
            return None

        try:
            voice_id = self._get_voice_id()
            params = self.EMOTION_SSML_PARAMS.get(emotion, self.EMOTION_SSML_PARAMS['neutral'])
            rate = params['rate']
            pitch = params['pitch']

            communicate = edge_tts.Communicate(
                text=text,
                voice=voice_id,
                rate=rate,
                pitch=pitch
            )

            tmp_file = tempfile.NamedTemporaryFile(
                suffix='.mp3',
                delete=False,
                prefix='iris_tts_'
            )

            tmp_path = tmp_file.name
            tmp_file.close()

            await communicate.save(tmp_path)
            self.temp_files.append(tmp_path)
            return tmp_path

        except Exception as e:
            print(f"[TTS] –û—à–∏–±–∫–∞ —Å–∏–Ω—Ç–µ–∑–∞: {e}")
            return None

    def _play_audio(self, audio_path: str) -> bool:
        """
        –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ pygame
        Args:
            audio_path: –ü—É—Ç—å –∫ –∞—É–¥–∏–æ—Ñ–∞–π–ª—É
        Returns:
            True –µ—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ
        """
        if not audio_path or not os.path.exists(audio_path):
            print("[TTS] –ê—É–¥–∏–æ—Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return False

        try:
            if self.visual_callback:
                self.visual_callback(True, 0.8)

            pygame.mixer.music.load(audio_path)
            pygame.mixer.music.set_volume(self.base_volume)
            pygame.mixer.music.play()

            # ‚úÖ –ù–û–í–û–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–ª–∞–≥–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –≤–æ –≤—Ä–µ–º—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
            while pygame.mixer.music.get_busy():
                if self._interrupt_flag:
                    pygame.mixer.music.stop()
                    print("[TTS] ‚ö†Ô∏è –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ")
                    break
                
                pygame.time.Clock().tick(30)

                if self.visual_callback:
                    import random
                    intensity = 0.5 + random.random() * 0.3
                    self.visual_callback(True, intensity)

            pygame.mixer.music.stop()
            
            try:
                pygame.mixer.music.unload()
            except:
                pass

            if self.visual_callback:
                self.visual_callback(False, 0.0)

            return True

        except Exception as e:
            print(f"[TTS] –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: {e}")
            if self.visual_callback:
                self.visual_callback(False, 0.0)
            return False

        finally:
            try:
                if audio_path in self.temp_files:
                    self.temp_files.remove(audio_path)
                if os.path.exists(audio_path):
                    os.unlink(audio_path)
            except:
                pass

    def _process_queue(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏"""
        print("[TTS] –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –æ—á–µ—Ä–µ–¥–∏...")
        
        while self.is_running:
            try:
                # ‚úÖ –ù–û–í–û–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º timeout –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–ª–∞–≥–∞
                try:
                    priority, counter, (text, emotion) = self.message_queue.get(timeout=0.5)
                except queue.Empty:
                    continue

                # ‚úÖ –ù–û–í–û–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–ª–∞–≥–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –ø–µ—Ä–µ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π
                if self._interrupt_flag:
                    self.message_queue.task_done()
                    continue

                self.currently_speaking = True
                self._speaking_done.clear()

                self.current_emotion = EmotionType(emotion) if emotion in [e.value for e in EmotionType] else EmotionType.NEUTRAL

                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    
                    audio_path = loop.run_until_complete(
                        self._synthesize_async(text, emotion)
                    )
                    loop.close()

                    if audio_path:
                        if self.audio_available:
                            success = self._play_audio(audio_path)
                            if success:
                                print(f"[TTS] ‚úÖ –û–∑–≤—É—á–µ–Ω–æ: '{text[:40]}...' [{emotion}]")
                            else:
                                print(f"[TTS] üí¨ [{emotion.upper()}]: {text}")
                        else:
                            print(f"[TTS] üí¨ [{emotion.upper()}]: {text}")

                        try:
                            if os.path.exists(audio_path):
                                os.unlink(audio_path)
                        except:
                            pass

                except Exception as e:
                    print(f"[TTS] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")

                finally:
                    self.currently_speaking = False
                    self._speaking_done.set()  # ‚úÖ –ù–û–í–û–ï: –°–∏–≥–Ω–∞–ª –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
                    self.message_queue.task_done()

            except Exception as e:
                print(f"[TTS] –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: {e}")
                self.currently_speaking = False
                self._speaking_done.set()

    def speak(self, text: str, emotion: str = 'neutral', priority: bool = False):
        """
        –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è
            emotion: –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –æ–∫—Ä–∞—Å–∫–∞
            priority: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        """
        if not text or not isinstance(text, str):
            return

        text = text.strip()
        if not text:
            return

        if emotion not in self.EMOTION_SSML_PARAMS:
            emotion = 'neutral'

        message_priority = 0 if priority else 1
        self._message_counter += 1
        counter = self._message_counter

        try:
            # ‚úÖ –ù–û–í–û–ï: –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è –æ—á–µ—Ä–µ–¥–∏
            try:
                self.message_queue.put(
                    (message_priority, counter, (text, emotion)),
                    block=False
                )
            except queue.Full:
                print(f"[TTS] ‚ö†Ô∏è –û—á–µ—Ä–µ–¥—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞ ({self.max_queue_size}), –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ")
                return

            if not self.is_running:
                print("[TTS] –í–Ω–∏–º–∞–Ω–∏–µ: –¥–≤–∏–∂–æ–∫ –Ω–µ –∑–∞–ø—É—â–µ–Ω, –≤—ã–∑–æ–≤–∏—Ç–µ start()")

        except Exception as e:
            print(f"[TTS] –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è: {e}")

    def speak_with_emotion(self, text: str, context: Dict[str, Any] = None):
        """
        –£–º–Ω–æ–µ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —ç–º–æ—Ü–∏–∏
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç (game_event, user_mood, etc.)
        """
        emotion = self._detect_emotion(text, context)
        self.speak(text, emotion)

    def _detect_emotion(self, text: str, context: Dict[str, Any] = None) -> str:
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —ç–º–æ—Ü–∏–∏ –ø–æ —Ç–µ–∫—Å—Ç—É –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É"""
        text_lower = text.lower()

        happy_words = ['–∫—Ä—É—Ç–æ', '–æ—Ç–ª–∏—á–Ω–æ', '–ø—Ä–µ–∫—Ä–∞—Å–Ω–æ', '–∑–¥–æ—Ä–æ–≤–æ', '—Å—É–ø–µ—Ä', '–∫–ª–∞—Å—Å', '–º–æ–ª–æ–¥–µ—Ü', '—É—Ä–∞']
        excited_words = ['–Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ', '–ø–æ—Ç—Ä—è—Å–∞—é—â–µ', '–≤–∞—É', '–æ—Ñ–∏–≥–µ—Ç—å', '—ç–π—Å', 'ace', '–∫–ª–∞—Ç—á']
        supportive_words = ['–Ω–∏—á–µ–≥–æ', '–±—ã–≤–∞–µ—Ç', '–Ω–µ –ø–µ—Ä–µ–∂–∏–≤–∞–π', '—Å–ø—Ä–∞–≤–∏—à—å—Å—è', '–≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑']
        sad_words = ['–∂–∞–ª—å', '–æ–±–∏–¥–Ω–æ', '–∫ —Å–æ–∂–∞–ª–µ–Ω–∏—é', '—É–≤—ã']

        if any(word in text_lower for word in excited_words):
            return 'excited'
        if any(word in text_lower for word in happy_words):
            return 'happy'
        if any(word in text_lower for word in supportive_words):
            return 'supportive'
        if any(word in text_lower for word in sad_words):
            return 'gentle'

        if context:
            event_type = context.get('event_type', '')
            if event_type == 'kill':
                return 'excited' if context.get('headshot') else 'happy'
            elif event_type == 'death':
                return 'supportive'
            elif event_type == 'round_win':
                return 'proud'
            elif event_type == 'round_loss':
                return 'encouraging'
            elif event_type == 'ace':
                return 'excited'
            elif event_type == 'clutch':
                return 'excited'

        return 'neutral'

    def is_busy(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–Ω—è—Ç–æ—Å—Ç–∏ –¥–≤–∏–∂–∫–∞"""
        return self.currently_speaking or not self.message_queue.empty()

    # ‚úÖ –ù–û–í–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò

    def interrupt(self):
        """
        –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ä–µ—á–∏ (–æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ)
        –í–ê–ñ–ù–û: –ù–µ –æ—á–∏—â–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å, —Ç–æ–ª—å–∫–æ —Ç–µ–∫—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        """
        if self.currently_speaking:
            self._interrupt_flag = True
            print("[TTS] üõë –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ä–µ—á–∏...")
            
            try:
                pygame.mixer.music.stop()
            except:
                pass
            
            # –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
            timeout = time.time() + 1.0
            while self.currently_speaking and time.time() < timeout:
                time.sleep(0.05)
            
            self._interrupt_flag = False

    def flush(self):
        """
        –û—á–∏—Å—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ (—É–¥–∞–ª—è–µ—Ç –≤—Å–µ –æ–∂–∏–¥–∞—é—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è)
        """
        self.interrupt()  # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–µ—Ä—ã–≤–∞–µ–º —Ç–µ–∫—É—â–µ–µ
        
        cleared_count = 0
        while not self.message_queue.empty():
            try:
                self.message_queue.get_nowait()
                self.message_queue.task_done()
                cleared_count += 1
            except queue.Empty:
                break
        
        if cleared_count > 0:
            print(f"[TTS] üßπ –û—á–∏—â–µ–Ω–æ {cleared_count} —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ –æ—á–µ—Ä–µ–¥–∏")

    def wait_until_silent(self, timeout: float = 10.0) -> bool:
        """
        –ñ–¥—ë–º, –ø–æ–∫–∞ –ò—Ä–∏—Å –∑–∞–∫–æ–Ω—á–∏—Ç –≥–æ–≤–æ—Ä–∏—Ç—å (–≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã)
        Args:
            timeout: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        Returns:
            True –µ—Å–ª–∏ —Å–∏—Å—Ç–µ–º–∞ –º–æ–ª—á–∏—Ç, False –µ—Å–ª–∏ timeout
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            if not self.is_busy():
                print("[TTS] ‚úÖ –°–∏—Å—Ç–µ–º–∞ –º–æ–ª—á–∏—Ç")
                return True
            time.sleep(0.1)
        
        print(f"[TTS] ‚ö†Ô∏è Timeout: —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –∑–∞–º–æ–ª—á–∞–ª–∞ –∑–∞ {timeout}—Å")
        return False

    def clear_queue(self):
        """–û—á–∏—Å—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ (–±–µ–∑ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ)"""
        while not self.message_queue.empty():
            try:
                self.message_queue.get_nowait()
                self.message_queue.task_done()
            except queue.Empty:
                break

    def start(self):
        """–ó–∞–ø—É—Å–∫ –¥–≤–∏–∂–∫–∞ TTS"""
        if self.is_running:
            return

        self.is_running = True
        self.processing_thread = threading.Thread(
            target=self._process_queue,
            daemon=True,
            name="IrisTTS-Processor"
        )
        self.processing_thread.start()
        print("[TTS] ‚úÖ –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –¥–≤–∏–∂–æ–∫ –ò—Ä–∏—Å –∑–∞–ø—É—â–µ–Ω")

    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–≤–∏–∂–∫–∞ TTS"""
        if not self.is_running:
            return

        print("[TTS] –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–≤–∏–∂–∫–∞...")
        
        self.flush()  # –û—á–∏—â–∞–µ–º –∏ –ø—Ä–µ—Ä—ã–≤–∞–µ–º
        self.is_running = False

        if self.processing_thread and self.processing_thread.is_alive():
            self.processing_thread.join(timeout=2.0)

        try:
            pygame.mixer.music.stop()
        except:
            pass

        for tmp_file in self.temp_files:
            try:
                if os.path.exists(tmp_file):
                    os.unlink(tmp_file)
            except:
                pass

        self.temp_files.clear()
        print("[TTS] –î–≤–∏–∂–æ–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    def change_voice(self, voice_name: str):
        """–°–º–µ–Ω–∞ –≥–æ–ª–æ—Å–∞"""
        if voice_name in self.VOICE_PRESETS:
            self.voice_preset = voice_name
            print(f"[TTS] –ì–æ–ª–æ—Å: {voice_name}")
        else:
            print(f"[TTS] –ì–æ–ª–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω: {voice_name}")

    def change_volume(self, volume: float):
        """–ò–∑–º–µ–Ω–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç–∏"""
        if 0.0 <= volume <= 1.0:
            self.base_volume = volume

    def get_queue_size(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏"""
        return self.message_queue.qsize()

    def set_max_queue_size(self, size: int):
        """–ò–∑–º–µ–Ω–∏—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏ (—Ç—Ä–µ–±—É–µ—Ç –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è)"""
        self.max_queue_size = size
        print(f"[TTS] Max queue size –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ {size}")


if __name__ == "__main__":
    print("=== –¢–µ—Å—Ç —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ TTS –ò—Ä–∏—Å v3.1 ===\n")

    try:
        tts = TTSEngine(voice='ru_female_soft', volume=0.8, max_queue_size=5)
        tts.start()

        print("1. –ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è —Ä–µ—á—å:")
        tts.speak("–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, —Ç–≤–æ–π AI –∫–æ–º–ø–∞–Ω—å–æ–Ω –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤.", emotion='neutral')
        tts.wait_until_silent(timeout=10)

        print("\n2. –†–∞–¥–æ—Å—Ç–Ω–∞—è —Ä–µ—á—å:")
        tts.speak("–û—Ç–ª–∏—á–Ω–æ —Å—ã–≥—Ä–∞–Ω–æ! –¢—ã –ø—Ä–æ—Å—Ç–æ –º–æ–ª–æ–¥–µ—Ü!", emotion='happy')
        tts.wait_until_silent(timeout=10)

        print("\n3. –í–æ–∑–±—É–∂–¥—ë–Ω–Ω–∞—è —Ä–µ—á—å:")
        tts.speak("–í–∞—É! –ù–µ–≤–µ—Ä–æ—è—Ç–Ω—ã–π —Ö–µ–¥—à–æ—Ç! –≠—Ç–æ –±—ã–ª–æ –ø–æ—Ç—Ä—è—Å–∞—é—â–µ!", emotion='excited')
        tts.wait_until_silent(timeout=10)

        print("\n4. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è —Ä–µ—á—å:")
        tts.speak("–ù–∏—á–µ–≥–æ —Å—Ç—Ä–∞—à–Ω–æ–≥–æ, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–ª—É—á–∏—Ç—Å—è.", emotion='supportive')
        tts.wait_until_silent(timeout=10)

        print("\n5. –¢–µ—Å—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞:")
        tts.speak("–î–æ–ª–≥–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–∏–∑–∫–∏–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º...", emotion='neutral')
        time.sleep(1)
        tts.speak("–°–†–û–ß–ù–û! –ö—Ä–∏—Ç–∏—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è!", emotion='excited', priority=True)
        tts.wait_until_silent(timeout=15)

        print("\n–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω!")
        tts.stop()

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")
        import traceback
        traceback.print_exc()
</file>

<file path=".replit">
modules = ["python-3.11"]
[agent]
expertMode = true

[nix]
channel = "stable-25_05"
packages = ["SDL2", "SDL2_image", "SDL2_mixer", "SDL2_ttf", "alsa-lib", "cairo", "espeak-ng", "ffmpeg-full", "fontconfig", "freetype", "ghostscript", "glibcLocales", "gobject-introspection", "gtk3", "libjpeg", "libpng", "pkg-config", "portaudio", "portmidi", "qhull", "tcl", "tk"]

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Iris Assistant - Local"

[[workflows.workflow]]
name = "Iris Assistant - Local"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "python main.py"

[workflows.workflow.metadata]
outputType = "console"

[[ports]]
localPort = 3000
externalPort = 80
</file>

<file path="stream_stats.json">
{
  "stats": {
    "total_kills": 0,
    "total_deaths": 0,
    "total_assists": 0,
    "rounds_won": 0,
    "rounds_lost": 0,
    "clutches_won": 0,
    "aces": 0,
    "headshots": 0,
    "donations_received": 0,
    "donations_total": 0.0,
    "new_subscribers": 0,
    "raids_received": 0,
    "chat_messages": 0,
    "stream_duration": 0.0,
    "kill_streak_max": 0,
    "death_streak_max": 0,
    "current_kill_streak": 0,
    "current_death_streak": 0,
    "matches_played": 0,
    "matches_won": 0
  },
  "achievements": {
    "first_blood": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "killing_spree": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "unstoppable": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "ace_master": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "clutch_king": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "headhunter": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "survivor": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "comeback_kid": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "popular": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "loved": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "whale_friend": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "raided": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "marathon": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "consistent": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "team_player": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "economical": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "ninja": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "dedication": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "sub_love": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    },
    "perfect_round": {
      "unlocked": false,
      "unlocked_at": null,
      "progress": 0
    }
  },
  "session_start": 1766214144.5655272
}
</file>

<file path="main.py">
#!/usr/bin/env python3

"""
IRIS - AI Assistant with Ollama + Voice + Visual
FIXED v2.3 - –ü–û–õ–ù–û–°–¢–¨–Æ –ò–°–ü–†–ê–í–õ–ï–ù–û

‚ú® –í–°–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø v2.3:
‚úÖ –ö–æ–º–∞–Ω–¥–∞ "–°–¢–û–ü" –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞–±–æ—Ç–∞–µ—Ç
‚úÖ –ù–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –µ—Å–ª–∏ —É–∂–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç
‚úÖ TTS interrupt() —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ
‚úÖ –ö–æ—Ä–æ—Ç–∫–∏ –∏ —á—ë—Ç–∫–∏–µ –æ—Ç–≤–µ—Ç—ã
‚úÖ –ú–Ω–æ–≥–æ–∫–æ–º–∞–Ω–¥–Ω—ã–π —Ä–µ–∂–∏–º —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ (30 —Å–µ–∫)
‚úÖ –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
"""

import os
import sys
import time
import threading
import logging
import json
import random
from dotenv import load_dotenv
from typing import Optional
from collections import deque

load_dotenv()

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –õ–û–ì–ò–†–û–í–ê–ù–ò–ï
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='[%(asctime)s] %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('iris.log', encoding='utf-8')
    ]
)

logger = logging.getLogger("IRIS")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ò–ú–ü–û–†–¢–´ - –õ–û–ö–ê–õ–¨–ù–´–ï –ú–û–î–£–õ–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

from src.tts_engine import TTSEngine
from src.cs2_gsi import CS2GameStateIntegration, GameEvent
from src.windows_audio import WindowsAudioController
from src.achievements import AchievementSystem, Achievement

try:
    from src.iris_visual import IrisVisual
    VISUAL_AVAILABLE = True
except ImportError:
    VISUAL_AVAILABLE = False
    logger.warning("[VISUAL] –ú–æ–¥—É–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")

try:
    from ollama import Client as OllamaClient
    OLLAMA_AVAILABLE = True
except ImportError:
    OLLAMA_AVAILABLE = False
    logger.warning("[OLLAMA] –ü–∞–∫–µ—Ç –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - pip install ollama")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ì–õ–û–ë–ê–õ–¨–ù–ê–Ø –ü–ï–†–ï–ú–ï–ù–ù–ê–Ø - IRIS INSTANCE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

iris_instance = None

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# OLLAMA AI ENGINE - FIXED VERSION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class OllamaAI:
    """–õ–æ–∫–∞–ª—å–Ω—ã–π AI –¥–≤–∏–∂–æ–∫ —á–µ—Ä–µ–∑ Ollama - FIXED —Å —Ç–∞–π–º–∞—É—Ç–æ–º –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""

    def __init__(self, model: str = "qwen3:4b-instruct", host: str = "http://localhost:11434"):
        self.model = model
        self.host = host
        self.client = None
        self.available = False
        self.context_history = deque(maxlen=10)
        self._initialize()

    def _initialize(self):
        if not OLLAMA_AVAILABLE:
            logger.warning("[OLLAMA] Ollama –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞")
            return

        try:
            self.client = OllamaClient(host=self.host)
            logger.info(f"[OLLAMA] ‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å {self.model}")
            self.available = True
        except Exception as e:
            logger.error(f"[OLLAMA] ‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
            self.available = False

    def generate(self, prompt: str, context: str = "", max_tokens: int = 150) -> Optional[str]:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç AI
        ‚úÖ FIXED: –¢–∞–π–º–∞—É—Ç + –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ + –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        """
        if not self.available or not self.client:
            logger.warning("[OLLAMA] AI –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –≤–æ–∑–≤—Ä–∞—â–∞—é fallback")
            return self._fallback_response()

        try:
            full_prompt = f"{context}\n\n{prompt}" if context else prompt

            logger.info(f"[OLLAMA] ü§î –û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –∫ Ollama: '{prompt[:50]}...'")
            start_time = time.time()

            response = self.client.generate(
                model=self.model,
                prompt=full_prompt,
                stream=False,
                options={'num_predict': max_tokens}
            )

            elapsed = time.time() - start_time
            logger.info(f"[OLLAMA] ‚è±Ô∏è Ollama –æ—Ç–≤–µ—Ç–∏–ª–∞ –∑–∞ {elapsed:.2f}s")

            text = response.get('response', '').strip()
            if text and len(text) > 3:
                self.context_history.append(text)
                logger.info(f"[OLLAMA] ‚úÖ –û—Ç–≤–µ—Ç –ø–æ–ª—É—á–µ–Ω ({len(text)} —Å–∏–º–≤–æ–ª–æ–≤): {text[:100]}...")
                return text

            logger.warning(f"[OLLAMA] –û—Ç–≤–µ—Ç –ø—É—Å—Ç–æ–π –∏–ª–∏ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π")
            return self._fallback_response()

        except Exception as e:
            logger.error(f"[OLLAMA] ‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
            return self._fallback_response()

    def _fallback_response(self) -> str:
        """Fallback –æ—Ç–≤–µ—Ç—ã –µ—Å–ª–∏ AI –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"""
        responses = [
            "–•–º, –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –º–æ–º–µ–Ω—Ç. –î–∞–π –º–Ω–µ —Å–µ–∫—É–Ω–¥—É –ø–æ–¥—É–º–∞—Ç—å.",
            "–°–æ–≥–ª–∞—Å–Ω–∞ —Å —Ç–æ–±–æ–π! –î–∞–≤–∞–π –ø—Ä–æ–¥–æ–ª–∂–∏–º.",
            "–≠—Ç–æ –±—ã–ª–æ —ç–ø–∏—á–Ω–æ! –ì–æ—Ç–æ–≤–∞ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Ä–∞—É–Ω–¥—É.",
            "–ù–∏—á–µ–≥–æ —Å–µ–±–µ! –í–æ—Ç —ç—Ç–æ –¥–∞!",
            "–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ! –°–ø–∞—Å–∏–±–æ –∑–∞ –≤–æ–ø—Ä–æ—Å.",
            "–î–∞, —è –≤–∏–∂—É —á—Ç–æ —Ç—ã –∏–º–µ–µ—à—å –≤ –≤–∏–¥—É.",
        ]
        return random.choice(responses)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# VOICE CALLBACKS - –û–ü–†–ï–î–ï–õ–ï–ù–´ –ü–ï–†–ï–î VOICEINPUT!
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def on_voice_wake():
    """Callback when wake word detected"""
    logger.info("[VOICE] üé§ Wake word detected - listening mode activated!")
    if iris_instance:
        iris_instance.on_voice_wake()

def on_voice_command(cmd: str):
    """Callback when voice command received"""
    logger.info(f"[VOICE] üí¨ Command received: {cmd}")
    if iris_instance:
        iris_instance.process_voice_command(cmd)

def on_voice_error(error: Exception):
    """Callback when error occurs"""
    logger.error(f"[VOICE] ‚ùå Error: {error}")

def on_tts_interrupt():
    """Callback when user starts speaking"""
    logger.info("[VOICE] üîá User started speaking - interrupting TTS")
    if iris_instance:
        iris_instance.interrupt_tts()

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ò–ú–ü–û–†–¢ –ò –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø VOICE_INPUT
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

VOICE_INPUT_AVAILABLE = False
VoiceInput = None
create_voice_input = None

try:
    from src.voice_input import VoiceInput, create_voice_input
    VOICE_INPUT_AVAILABLE = True
    logger.info("[VOICE] ‚úÖ voice_input.py –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ src/")
except ImportError as e:
    logger.error(f"[VOICE] ‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å voice_input: {e}")
    logger.error("[VOICE] –£–±–µ–¥–∏—Å—å —á—Ç–æ —Ñ–∞–π–ª –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ src/voice_input.py")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IRIS ASSISTANT - MAIN CLASS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class IrisAssistant:
    """IRIS v2.3 - FIXED —Å –û–°–¢–ê–ù–û–í–ö–û–ô –ò –ò–ù–¢–ï–õ–õ–ï–ö–¢–û–ú"""

    def __init__(self):
        global iris_instance
        iris_instance = self

        logger.info("‚ïê" * 60)
        logger.info("üå∏ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è IRIS - AI Assistant v2.3 FIXED")
        logger.info("‚ïê" * 60)

        self.is_running = False
        # ‚úÖ –®–ê–ì 1: –§–õ–ê–ì–ò –î–õ–Ø –£–ü–†–ê–í–õ–ï–ù–ò–Ø
        self.is_currently_generating = False  # –ù–µ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
        self.should_stop_speaking = False     # –§–ª–∞–≥ –∫–æ–º–∞–Ω–¥—ã –°–¢–û–ü

        self.config = {
            'cs2_gsi_port': int(os.getenv('CS2_GSI_PORT', 3000)),
            'voice_enabled': os.getenv('VOICE_ENABLED', 'true').lower() == 'true',
            'wake_word': os.getenv('WAKE_WORD', '–∏—Ä–∏—Å'),
            'tts_voice': os.getenv('TTS_VOICE', 'ru_female_soft'),
            'ollama_url': os.getenv('OLLAMA_URL', 'http://localhost:11434'),
            'ollama_model': os.getenv('OLLAMA_MODEL', 'qwen3:4b-instruct'),
            'conversation_timeout': float(os.getenv('CONVERSATION_TIMEOUT', '30.0')),
        }

        # ‚ú® Visual Interface
        if VISUAL_AVAILABLE:
            logger.info("[VISUAL] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é IO-—Å—Ç–∏–ª—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å...")
            self.visual = IrisVisual(width=500, height=500)
        else:
            self.visual = None

        # ü§ñ AI Engine
        logger.info("[AI] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é Ollama AI...")
        self.ai = OllamaAI(
            model=self.config['ollama_model'],
            host=self.config['ollama_url']
        )

        # üîä Text-to-Speech
        logger.info("[TTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏...")
        self.tts = TTSEngine(
            voice=self.config['tts_voice'],
            visual_callback=self._on_visual_update if self.visual else None
        )

        # üé§ Voice Input
        if self.config['voice_enabled'] and VOICE_INPUT_AVAILABLE:
            logger.info("[VOICE] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥...")
            self.voice_input = create_voice_input(
                wake_word=self.config['wake_word'],
                sensitivity=0.8,
                conversation_timeout=self.config['conversation_timeout'],
                tts_interrupt_callback=on_tts_interrupt
            )

            # ‚úÖ –£–°–¢–ê–ù–û–í–ò–¢–¨ CALLBACKS
            self.voice_input.set_wake_callback(on_voice_wake)
            self.voice_input.set_command_callback(on_voice_command)
            self.voice_input.set_error_callback(on_voice_error)
        else:
            self.voice_input = None

        # üéÆ CS2 Game State Integration
        logger.info("[CS2] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é Game State Integration...")
        self.cs2_gsi = CS2GameStateIntegration(
            port=self.config['cs2_gsi_port'],
            event_callback=self._on_game_event
        )

        # üîä Audio Control
        logger.info("[AUDIO] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –∫–æ–Ω—Ç—Ä–æ–ª—å –∑–≤—É–∫–∞...")
        self.audio_controller = WindowsAudioController()

        # üèÜ Achievements System
        logger.info("[ACHIEVEMENTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é —Å–∏—Å—Ç–µ–º—É –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π...")
        self.achievements = AchievementSystem(
            achievement_callback=self._on_achievement
        )

        logger.info("‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞")

    def _on_visual_update(self, speaking: bool, intensity: float):
        """Update visual interface"""
        if self.visual:
            self.visual.set_speaking(speaking, intensity)

    def _on_achievement(self, achievement: Achievement):
        """Achievement callback"""
        message = f"–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ! {achievement.icon} {achievement.name}!"
        self.tts.speak(message, emotion='excited', priority=True)

    def _on_game_event(self, event: GameEvent):
        """Game event callback"""
        logger.info(f"[CS2] –°–æ–±—ã—Ç–∏–µ: {event.event_type}")

        responses = {
            'kill': ("–ö—Ä–æ–≤–∞–≤–æ–µ —à–æ—É! –û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª!", 'excited'),
            'death': ("–ù–µ –ø–µ—Ä–µ–∂–∏–≤–∞–π, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –ø–æ–ª—É—á–∏—Ç—Å—è!", 'supportive'),
            'round_end': ("–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à—ë–Ω! –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º—Å—è –∫ —Å–ª–µ–¥—É—é—â–µ–º—É", 'neutral'),
            'ace': ("–ê–°–ï–ï–ï–ï!!! –≠—Ç–æ –±—ã–ª–∞ —ç–ø–æ—Ö–∞! –ü—è—Ç—å —Ñ—Ä–∞–≥–æ–≤ –ø–æ–¥—Ä—è–¥!", 'excited'),
        }

        text, emotion = responses.get(event.event_type, ("–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –º–æ–º–µ–Ω—Ç", 'neutral'))
        self.tts.speak(text, emotion=emotion)

    def on_voice_wake(self):
        """Called when wake word detected"""
        logger.info("[IRIS] üëÇ Voice activation detected")
        if self.visual:
            self.visual.play_sound('activate', 0.7)

    # ‚úÖ –®–ê–ì 2: –ù–û–í–´–ô –ú–ï–¢–û–î interrupt_tts()
    def interrupt_tts(self):
        """Interrupt TTS but keep engine alive"""
        logger.info("[IRIS] üîá Interrupting TTS")
        if self.tts:
            try:
                # ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º interrupt() –≤–º–µ—Å—Ç–æ stop()!
                # stop() —É–±–∏–≤–∞–µ—Ç –≤–µ—Å—å –¥–≤–∏–∂–æ–∫, interrupt() —Ç–æ–ª—å–∫–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∑–≤—É–∫
                if hasattr(self.tts, 'interrupt'):
                    self.tts.interrupt()
                    logger.info("[IRIS] ‚úÖ TTS interrupted")
                elif hasattr(self.tts, 'queue'):
                    self.tts.queue.clear()
                    logger.info("[IRIS] ‚úÖ TTS queue cleared")
            except Exception as e:
                logger.error(f"[IRIS] –û—à–∏–±–∫–∞ interrupt: {e}")

    # ‚úÖ –®–ê–ì 3: –ü–ï–†–ï–ü–ò–°–ê–ù–ù–´–ô –ú–ï–¢–û–î process_voice_command()
    def process_voice_command(self, command: str):
        """
        ‚úÖ FIXED v2.3: –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥
        ‚Ä¢ –ö–æ–º–∞–Ω–¥–∞ –°–¢–û–ü —Ä–∞–±–æ—Ç–∞–µ—Ç
        ‚Ä¢ –ù–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
        ‚Ä¢ –ö–æ—Ä–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç—ã
        """
        logger.info(f"[IRIS] üì® –ö–æ–º–∞–Ω–¥–∞: {command}")

        if not command or len(command.strip()) < 2:
            return

        command_lower = command.lower().strip()

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ö–û–ú–ê–ù–î–ê 1: –°–¢–û–ü
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if any(kw in command_lower for kw in ['—Å—Ç–æ–ø', '—Å—Ç–æ–ø–ø', '–æ—Å—Ç–∞–Ω–æ–≤–∏', '—Ö–≤–∞—Ç–∏—Ç']):
            logger.info("[IRIS] üõë –ö–û–ú–ê–ù–î–ê –°–¢–û–ü!")
            self.should_stop_speaking = True
            self.is_currently_generating = False
            self.tts.interrupt()
            self.tts.speak("–û–∫–µ–π, —è —Å–ª—É—à–∞—é.", emotion='neutral')
            return

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ö–û–ú–ê–ù–î–ê 2: –ê–£–î–ò–û –ö–û–ù–¢–†–û–õ–¨
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if any(kw in command_lower for kw in ['—Ç–∏—Ö–æ', '–≥—Ä–æ–º—á–µ', '–≥—Ä–æ–º–∫–æ—Å—Ç—å', '–∑–≤—É–∫']):
            response = self.audio_controller.execute_voice_command(command)
            self.tts.speak(response, emotion='neutral')
            return

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ö–û–ú–ê–ù–î–ê 3: –ü–†–ò–í–ï–¢–°–¢–í–ò–ï
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if command_lower in ['–ø—Ä–∏–≤–µ—Ç', '–ø—Ä–∏–≤–µ–µ—Ç']:
            self.tts.speak("–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, —Ç–≤–æ–π AI –ø–æ–º–æ—â–Ω–∏–∫!", emotion='happy')
            return

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ü–†–û–í–ï–†–ö–ê: —É–∂–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º?
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if self.is_currently_generating:
            logger.warning("[IRIS] ‚ö†Ô∏è –£–∂–µ –≥–µ–Ω–µ—Ä–∏—Ä—É—é, –ø—Ä–æ–ø—É—Å–∫–∞—é –∫–æ–º–∞–Ω–¥—É")
            return

        logger.info("[IRIS-AI] üöÄ –ó–∞–ø—É—Å–∫–∞—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ")

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚úÖ –ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –û–¢–í–ï–¢ –í –û–¢–î–ï–õ–¨–ù–û–ú –ü–û–¢–û–ö–ï
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        def generate_and_speak():
            """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø–æ—Ç–æ–∫–µ"""
            self.is_currently_generating = True
            self.should_stop_speaking = False

            try:
                logger.info(f"[IRIS-AI] ü§ñ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –¥–ª—è: '{command[:50]}...'")

                response = self.ai.generate(command, max_tokens=150)

                # ‚úÖ –ü–†–û–í–ï–†–Ø–ï–ú —Ñ–ª–∞–≥ –°–¢–û–ü
                if self.should_stop_speaking:
                    logger.info("[IRIS-AI] ‚ö†Ô∏è –°–¢–û–ü –ø–µ—Ä–µ—Ö–≤–∞—Ç–∏–ª–∞ –æ—Ç–≤–µ—Ç")
                    self.is_currently_generating = False
                    return

                # ‚úÖ –û–ó–í–£–ß–ò–í–ê–ï–ú
                if response and len(response.strip()) > 0:
                    logger.info(f"[IRIS-AI] ‚úÖ –û–∑–≤—É—á–∏–≤–∞—é: {response[:80]}...")
                    self.tts.speak(response, emotion='neutral')
                else:
                    logger.warning("[IRIS-AI] –û—Ç–≤–µ—Ç –ø—É—Å—Ç–æ–π")
                    self.tts.speak("–•–º, –¥–∞–π –º–Ω–µ —Å–µ–∫—É–Ω–¥—É –ø–æ–¥—É–º–∞—Ç—å...", emotion='neutral')

            except Exception as e:
                logger.error(f"[IRIS-AI] ‚ùå –û—à–∏–±–∫–∞: {e}")
                if not self.should_stop_speaking:
                    self.tts.speak("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞.", emotion='neutral')

            finally:
                self.is_currently_generating = False
                logger.info("[IRIS-AI] ‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞")

        # ‚úÖ –ó–ê–ü–£–°–¢–ò–¢–¨ –í –û–¢–î–ï–õ–¨–ù–û–ú –ü–û–¢–û–ö–ï
        ai_thread = threading.Thread(
            target=generate_and_speak,
            daemon=True,
            name='IRIS-AI-Generator'
        )
        ai_thread.start()
        logger.info("[IRIS-AI] ‚úÖ –ü–æ—Ç–æ–∫ –∑–∞–ø—É—â–µ–Ω")

    def _startup_sequence(self):
        """Startup animation with sounds and phrases"""
        phrases = [
            ("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —è–¥—Ä–∞.........", 'scan', 1.5),
            ("–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏.........", 'loading', 1.5),
            ("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä–∞–º.........", 'connect', 1.3),
            ("–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –≥–æ–ª–æ—Å–∞.........", 'check', 1.2),
        ]

        time.sleep(2)
        for text, sound, duration in phrases:
            if self.visual:
                self.visual.animate_phase(sound, duration)
            self.tts.speak(text, emotion='neutral')
            while self.tts.is_busy():
                time.sleep(0.1)
            time.sleep(0.3)

        if self.visual:
            self.visual.play_sound('ready', 0.8)

        greeting = random.choice([
            "–í—Å–µ —Å–∏—Å—Ç–µ–º—ã –∞–∫—Ç–∏–≤–Ω—ã! –ü—Ä–∏–≤–µ—Ç, —è –ò—Ä–∏—Å! –ì–æ—Ç–æ–≤–∞ –ø–æ–º–æ–≥–∞—Ç—å!",
            "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ò—Ä–∏—Å –Ω–∞ —Å–≤—è–∑–∏!",
            "–°–∏—Å—Ç–µ–º—ã –≤ –Ω–æ—Ä–º–µ! –ù–∞—á–∏–Ω–∞–µ–º!",
        ])

        self.tts.speak(greeting, emotion='excited')

    def start(self):
        """Start IRIS"""
        self.is_running = True

        logger.info("[IRIS] üöÄ –ó–∞–ø—É—Å–∫ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞...")
        if self.visual:
            self.visual.run_async()

        threading.Thread(target=self._startup_sequence, daemon=True).start()

        logger.info("[TTS] –ó–∞–ø—É—Å–∫ —Å–∏–Ω—Ç–µ–∑–∞ —Ä–µ—á–∏...")
        self.tts.start()

        logger.info("[CS2] –ó–∞–ø—É—Å–∫ Game State —Å–µ—Ä–≤–µ—Ä–∞...")
        self.cs2_gsi.start()
        self.cs2_gsi.save_config_file()

        if self.voice_input:
            logger.info("[VOICE] –ó–∞–ø—É—Å–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...")
            self.voice_input.start()

        logger.info("‚ïê" * 60)
        logger.info("‚úÖ IRIS —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞ v2.3 FIXED!")
        logger.info("‚ïê" * 60)
        logger.info("üìã –§—É–Ω–∫—Ü–∏–∏:")
        logger.info(" üéÆ CS2 Game State (–ø–æ—Ä—Ç 3000)")
        logger.info(" ü§ñ Ollama AI ‚ú® FIXED: async –≥–µ–Ω–µ—Ä–∞—Ü–∏—è")
        logger.info(" üîä Text-to-Speech (–ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Ä–µ—á–∏)")
        if self.voice_input:
            logger.info(" üé§ Voice Control ‚ú® FIXED: –º–Ω–æ–≥–æ–∫–æ–º–∞–Ω–¥–Ω—ã–π —Ä–µ–∂–∏–º")
        logger.info(" üëÅÔ∏è  IO-—Å—Ç–∏–ª—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è")
        logger.info("‚ïê" * 60)

    def stop(self):
        """Stop IRIS"""
        logger.info("[IRIS] –û—Å—Ç–∞–Ω–æ–≤–∫–∞...")
        self.is_running = False

        if self.voice_input:
            self.voice_input.stop()
        self.cs2_gsi.stop()
        self.tts.stop()
        if self.visual:
            self.visual.stop()

        logger.info("[IRIS] –î–æ –≤—Å—Ç—Ä–µ—á–∏! üå∏")

    def run(self):
        """Main loop"""
        import signal

        def signal_handler(sig, frame):
            self.stop()
            sys.exit(0)

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        self.start()

        try:
            while self.is_running:
                time.sleep(1)
        except KeyboardInterrupt:
            self.stop()

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ENTRY POINT
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def main():
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                            ‚ïë
‚ïë        üå∏ IRIS - AI Assistant v2.3 FIXED                  ‚ïë
‚ïë        –õ–æ–∫–∞–ª—å–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å + –≥–æ–ª–æ—Å + –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è         ‚ïë
‚ïë                                                            ‚ïë
‚ïë        ‚ú® –ò–°–ü–†–ê–í–õ–ï–ù–û:                                      ‚ïë
‚ïë           ‚Ä¢ ‚è≥ AI –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ           ‚ïë
‚ïë           ‚Ä¢ üîá TTS interrupt –í–°–ï–ì–î–ê —Ä–∞–±–æ—Ç–∞–µ—Ç              ‚ïë
‚ïë           ‚Ä¢ üí¨ –ú–Ω–æ–≥–æ–∫–æ–º–∞–Ω–¥–Ω—ã–π —Ä–µ–∂–∏–º —Ä–∞–∑–≥–æ–≤–æ—Ä–∞             ‚ïë
‚ïë           ‚Ä¢ ‚è±Ô∏è –¢–∞–π–º–µ—Ä –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏ —Ä–µ—á–∏                ‚ïë
‚ïë           ‚Ä¢ üìä –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏                    ‚ïë
‚ïë           ‚Ä¢ üõë –ö–æ–º–∞–Ω–¥–∞ –°–¢–û–ü –†–ê–ë–û–¢–ê–ï–¢ –ü–û–õ–ù–û–°–¢–¨–Æ             ‚ïë
‚ïë           ‚Ä¢ ‚è∏Ô∏è –ù–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ                 ‚ïë
‚ïë                                                            ‚ïë
‚ïë        üíª –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:                                      ‚ïë
‚ïë           ‚Ä¢ Ollama (Qwen3) - –ª–æ–∫–∞–ª—å–Ω—ã–π AI                ‚ïë
‚ïë           ‚Ä¢ Edge TTS - —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏                        ‚ïë
‚ïë           ‚Ä¢ Vosk - —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏                     ‚ïë
‚ïë           ‚Ä¢ Pygame - –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è IO-—Å—Ç–∏–ª—å               ‚ïë
‚ïë                                                            ‚ïë
‚ïë        –î–ª—è –ª—É—á—à–µ–π —Ä–∞–±–æ—Ç—ã:                                 ‚ïë
‚ïë        ‚Ä¢ –ó–∞–ø—É—Å—Ç–∏—Ç–µ Ollama: ollama serve                  ‚ïë
‚ïë        ‚Ä¢ –ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞: qwen3:4b-instruct                ‚ïë
‚ïë        ‚Ä¢ Vosk –º–æ–¥–µ–ª—å –≤ –ø–∞–ø–∫–µ 'models'                    ‚ïë
‚ïë                                                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
""")

    iris = IrisAssistant()
    iris.run()

if __name__ == "__main__":
    main()
</file>

</files>
